<!DOCTYPE html>
<html lang="en">
<title>Atari 8-bit rom image file explorer</title>
<style>
    @font-face {
        font-family: 'Atari';
        src: url(data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAADLEAA0AAAAArcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABHREVGAAAyrAAAABYAAAAWABEBYk9TLzIAABeMAAAAUgAAAGBiXnzJY21hcAAAF+AAAAA2AAAARADy4XdjdnQgAAAYGAAAAAQAAAAEACICiGdhc3AAADKkAAAACAAAAAj//wADZ2x5ZgAAATAAABIHAABXivhCQvdoZWFkAAAW1AAAADMAAAA2FVu3/2hoZWEAABdwAAAAGgAAACQIfQNhaG10eAAAFwgAAABmAAADgGOAYCJsb2NhAAATWAAAA3kAAAN65cnP6G1heHAAABM4AAAAHwAAACABzACxbmFtZQAAGBwAABTzAAA+qbGNiBVwb3N0AAAtEAAABZIAAA5qQUfDxnja7VvniiTJEc7M6r5hGZZRaSiWYzmWumY4jgMJrmj0555DDyBz8t7bTXnvvffuZHflpVe4R9ArSE/QVaXMcBkZVT17cCAQ9PSaya7KyMiMiC9clQvuUef8k+EZ17gz96J73r34qftnG/fvJ+89tP3XU/ebkH5195r89TZ/ff/sIX946r7P3w9t3z42tLtH/Qv+8+yz4ZnxpY+Gp908++hciI174UP+ZS6NXfSxwfHLYZx+Ng7Gr8DrzqXrMY1fqcb5+tM8Tvfn669yQN9Hov9qR+vR/a/h++n6a2m9SOu9jq4zP6+H+W5O9Hwev6HwG/L4jU72A9ffZPh7sxm/xYzfasZvM+O3m/E7zPidZvwuM363Gb/HjN9b+A/5/N5X9gvj9+NYzv8D5Xzg+geFHp7/XUM/mvGHzPjDZvwRM/6oGX/MjD9uxp8w40+a8afM+NNm/Bkz/qwZf07pWx5/3lz/ghl/0Yy/ZMZfNuOvmPFXzfhrZvx1M/6G4e+b5vq3zPjbZvwdYy/fNde/Z+zn+2QPvN4Piv26rA8/TL96D9rVxIQgzvfd0PX7nU9f352zHqUfWQN06kdmzR8XHYPrPzHXf+rq+T9TOpuv/xyvz6yzvzDzfyn34x5+xTZA158x9//a3P+bcuZA/7eGn9+Z8e8NP38w43vm/vtm/EfDz5/M9T+b8V8Mf3811/9m1v+7uf4PlCGu5y6ce9zvd+1uP6RP3/Vt38QpSzGh4ux8VoY8mFCTZpB8ovLPTIWQAqi8JM3cZ20YukSt69O8NB0IJXIBiAAbnv1DnuWHfG+at2th9cblu9J9d33iscm/ReCAVst66W6lwa6Dzx4+MBf+bmCdiJNgJRllxfR5B9m3oO628Nm4CXaa/Ez6LY+cTyvjfWm5LdwDZ7GBXbtsAenalmmEOMY8Gz4x3zGLhWxplZDWmOAuvBV2hMjsMqWtuitEuIfuAD5ulz3Dp2+Hffn0vO/Z8X5DtfMYa1rbfr8rnxblRp+NK1Si/hFSilYLtIb6s3GHeibNCjDLq1OdXNKM4BYU26Ebap4URRFypuhFTl4o+kwyyyn9X66F6low8w5gT144cYrLfK3II6gdhLKDIPp57i6B6q4l2Xs4obyLKVsDqloWNBwqGAr8Ozk8J9RS1AuvdDSAhoaIOgh3VPx75/VJnhcdLzQmUj8vv2V9Z3zIc66yRZJNNdny2Xy9lr235yNS9MpufGU3tKuF7WWrY354b9ZGD475Fp5BFo2VBazlI9FQJzjS/KB2jPr2uM93dOqTMDBxHoB7/r/YlMxGDAP6hJ9DPrOMYNmGssFkXn2xGz0P7BgsECg0ZL+EI45AeKJ5iJmXxefuGbN3HWI2mi0CTGV31WxcNc3bZxrEMUwGRpFnNTtwfA85A+8WkIo1N7gRgghBdrnTw77yXZMjjIVlshqQtdx2d0jnetjVAL6o79CbJD3MCyb94kPlAwLHYpEKeVLSvS077mnH5OfgQzvPEhZjnJxfIF/eEUuucQ+7R3B3W4XIgsdo8cBJcBo88RtfcTwCFHHG43buMfTHhMpoh8N+R7oFO0l/h3RLt2HvOBFF/mcSV6C3ERxhC2ZTgors+8A7mqgAtWvXgo5MUTQDNsbenLTjgqQ4gARBs0KUUKLsGSwcMzSQDmpzX+lkj1oNOyS5Uyzi6b+FbxEdPy862pL2zaSneR7RmTEKwkwwa2sPvOfziDMGPV5iFcbZfaI2pl89nSTmiflaRhA6SW3lXe21i440lVsNVZCC+kB7uVXjsUfjaLMqFGyenXj+LJkJlGx2NeKcg0x7IgA78YQ2IJ+xuvs23C38onRIAwFvRoroZqe8gxZJRQv3QBa+Q0kDpYF9jJh0swwdqjO5yCiGeNGyxQ2JbD4P8amsd0DSVdxcam4E9xUXUxLo5Erk6I9zQFFrB5LpW5EIICnBFYe+pHNCpWXdaGUfpBczct0AfsyEGAqBLpNW3FYcFHQYrtIvihOxVFy+DukmNINQ0S1oORBaJsrb9E9DM+BkgyOalZACVx60p2i1p0jzsxdOd1JNIt3J9ir2B3RnF/l+tESuWpBm7sT/EUahLqH3XY1etSZBbsRc7gEr0LJHPPV0dpLd6NibI11cnaLmxlWB94opHDnjyrI8SX92xapmZ7zIWGlyq1B6AC1Cu0YBQUAQ0DpRcAsdznhAmQTsBTVHRy/4W6XCjUIUsYR2qX9jDLHSPTZs0rsVi8SddCKRgm8zu/xA2WisUFLimpb2gUkh6CxZEcmmYZOa3BIdOQZsSRsmiDSDIwnr+2+A5yIEydGih2ikASzPIFbHeiKnvLPdnqWEUO0ZtivpnnNc2q76sbzGXHsbRvh+L3vIJ4330RLmfo2EBQHJckJ1QrfY7oAfsbtWbG4mf8KRGGXvKk4AOlveF/KXT3eMKrsHvWwht29Jnpjhzi4KHCIqs7NYnnWZiyenuZtBnr72sxfWzyo010ie1Wlyeu4NdxO0D32JzIR0DTWXljSxaTlRsN2ydtq7nGgs5pcjZxpMK/5I7zplnmLLERlhUyZOOONcsULUUPFrcAqeUJ9TGV0J4PkqN2BdzdYAMGDuY71GDcifrAMhHsuP2qP5EeZ8VnvyHESDFvLudqE9eW7jMKKtz4B4GyR7T2epMdGTHrElolTnldwuz13nPUiuNS/ixbS+RAOl2kPxFit80K5Xxe1njGKISZi3Ns7Yfac86E5XWorvNCUfHeefFZRB/GIvg4G1VOh6lgJHkVV1SRaqvDTmBo6rL3kdqi4YTVW6ofJulQITXYqdgtQ3brLXpGwjWyxENyMl28XcKZNa2PqVtXUsLNC0hpOV4i8c1lW0D2icChQRyhbr8P0pm4R1kEPUNixvjlUEx7tDv8RogrEbmLCrA7dSldDVYIzFSpbc8HF4ShRLOSNwlRnX7TnLhpVLFABmFmLJ3pcRQOXrSgUFjpVdXY4vqUqf/tzEyO2yh2wz2WsQtw7+NKfWuBRFm5S7n1PER0jX8CwsDIGVBWcRQXm9nnMW8SmkwBntJrZH5vMGZlHIIcrcoyMZS0U7cA2q+Lwea9mCWZ4XIix3qmJ3o5xdOblA0Fjp/nPzcqiNnjWSJPxgL+cqL2dmbsGrFL2YtVJ4p5Si3pmnLL7amQc3XJ+CeK+99V5FA6e6bLASoSEilC6IBvnIzQx79gXjR3EQ2i/Bnc/Rn1F1rGgGYF0+uw7ryeLPKDjgaIi9E1FUK9/mOF8yF66v7OpqZdSx36K6QtJs4ZyLpctOJlxbk6DN1FKSqkLxb8a7LWqXzlQ+h33fVtXWrMFSb3W23wOdGK4RR1WPrqTfiu1p+244E2LDYz8IEu13VR46hJWT81yJvCi1oFb8rfhZCEjW+jSAxumksEeG80qXRfSg9EYk6JbKZellnemeAPVLSEwj/Jt7GwcA+Q1V7BtVYcf8GE4vKKo3Sq03Vz6BTqISFD3Itg0fW5nDfIyRuYn4xQH6ZGWtbV5rW3E/xlzZnxD0lzNu2s4Zd2P4w1lpk7Y7yu/038GVDL6ieKW6Z/vMS9WrYiqzUKSfgyPSGOdYvWAORS8aSZqbquum+0LpswHvvilxcK2dxKW0zRqFgIriVjotAfsok3PX3hGc6twF2w9qXKn0wrWrxbUlZdwNUdY6BlWTlNWofhahaa7YguA30FKbMWagfuyIiiQIZ3XJq+7YGCdSuwDzQJVCpbVVP4p6hqTh+fgr/b4oVuErayNLM1bH6s7dEaF1QbbXMgT0ezpFdtyJdeclWoW+57K3iX1Pv+hri0U/ACcyjTWc8HF95vqe+cTEuKkn3Nie8BGM0WiBuIKcbLCGwPd32EPGbFR/oI/sKTGapCwJGCIoWq98SedPrpMTS5aBuHAwGKlwxXUaPZclwI0JgpeCW2Ykeipfx4UNEBUpeg7UCiRKugmo+DGaryhxGbPvekrV9L6kIWhIqZOubX5Vj7aUweQghPWIaoJ5twFag6ueCvUehV6f1YZqcxCmbitruXR33A7RosQ6oo/Sa7pK1zdcHEeKlOAcJIo5UExEiepIf2moTuEO8koioSoixVtK8zyXcaTZEbA+tHE2bqjR5BHXl3O8KoUB9RDIpZzRqGpv8lQIw2D1mAjlj+X8bkAmd+WegMib+PcpvvFYpcLsZ0cwlP5egefbcNuFW4QHjrQ9fjtLU3nOqQ8AbdTpusVZ3mvRFxH5cevkomRiSbSYOpBprNpBaxR8SwX9FsNbXrl0MDNWBqldKBoXWf6+V11r7aGw52V6maANqp8ZJGQ+yO+rXoAQZGERBYE8FyDqJ0G20F1pAbzgPuIDq1ALvD2T9fgsR0a45ySrA2Vz+t6HC82l/pZodhHL8pc1QlxwfKw94y5LYYd6aryk9MNZjpMg5dGTzmRaOQGuoKI2YaG/nntHIzSZDykBh3cFqaPue7KK2r7RCu2deoiBPQAmRkrrMSKQTtLGRqK1175UHoFgDB8/SHGunCNVBwhFgGIxh3X/0hL8tfxwoIpdcpQFjrhwWD3U4Y5wyDRF4uJ90B+wtL2iiWWh+jw78S+d7LhVmkjGTiozEe5j7azG51v4DAtzx1IfiMOGDqBIR1qz3BhVnEYGy8l5401vGY0HV7MjV9P0+15rPBQkPXMMTz9VZd1r/HRly17cLYTX1qrP0V4KtuDsgi8E/prKMc9JHdyur7NqyDcW1eLNdfpcoofcj9QYllPYiP5qqjOgO9Vzh6v9XvUUIjMSHsBJkZnBApBZ4axAgXfisMvPAne7CqW4SFA8HzcWJ8fQgupGDvC4bVGMC/ZaaS3HuaRPh9KKha8ri7ioaQ74iNuKJUB3aGkFoysWsB4Bd1gmXeRE4gtVbqS6xgsfUu8cHuN7wmOlRbicSgt+QwHgSP3Ao56DcK9IgwAPZUGbrGbfrDz8vi84hFV3dIeI6+sxUEuhh9EEfA5gZB/jpZN5JM8sKfZahHGgvvOIwdjx/YOEhAJMcOI7H7B+7SvmykkEaITYM7i9Egd2VLTvqniwNIN1VBg96Z7NOotMRJYlAhgrLCNdQndCT3VCtY413vQgK1c9xSMybRWpTkVJag8Y7RP/jbHDlRip7RexEVlfkO8qOjfpqWykAxLSVKQB5hnkkRl/VEaD5gdch5YRYkrUMorl0arrYpehLWdlkcY7YfFAeR09AheP4UyJNdCyqvjFk5+dqvAl8pN3mt55hVuttmxHYS70v9fmHMl/s9RHVMEjesPncE2lAdsUk7NZvWhyCz1cfr45EzumyZj6jdfFgliQUc115VtKe52SB91bl57SdfuE6G11n1NkUljROJaV6McdKSIUm1cxtYnUbZZzXqFgqxBwKug3HuFBv5TBoYjCLvFCh6gT+bX16TEAqbhMBX4befpp2WnYUddeop8icx35VOWuZbZ6htXeVmJSqvoe3NE8YVceJ1rUoWLRWK/qBjVGtSWi31H7L1vtVRUXe9JTE8QsqT0A8aTxWaIWaB8YxCOfxg9lFa+M72GU4IzKt0d5wCgv70Z4mJ3ZCj15AInOdSeDqJtyO5MxBDEUOelpRballlke4m1rPY9WQ7APGNQ7Ph1nDchOJzU6jHL4cSfOQSLGiRKBHa2Q12gZqabnOPKRuKXOFlqRU+fxdah2p2uVUkVCpMbkKh7Lg7B/DLH9jHKa2WkHBIGlh7hVZ/f9auzCj8ErBPDs9tdiSbuX2alqWIgWBTrVb+yX0YvEgSJd7VdXY1mRSBUpiOWhA3p+EQs3PqqKu1gOPXshujXSo+5FsfDP6BZ6hTR2rKGlE0LaORYajWS7C928qbK/VkXE5SQmdP7uaIVeRSBdbysoZCghmhKPO9p/kEccBh2dF9kKHslzhityZa9r/C3IlZ6RjM8jLuHS/pG4pC1xydBCHbodqriEo8eN0J0EGR9UU+OXWClXrzIH/aDEWsHO2BK8C8MbJoxDs5n5Ka6J6gfByY4313R9quikqiWuBycP8rbcRDVZPrjFhbtdq/uaDl9EQkditR1qM8VrsianXpKeIqjMWvKXK3WigXvR5SEK1eNemS3lZlXP8er9KHV2p/feTu+9nd57O733dnrv7fTe2+m9t9N7b6f33k7vvZ3eezu993Z67+303tv/9r2307trp3fXTu+und5dO7279n/37trxt8/+CzHL0d0AeNpjYGRgYNzDEMHAyaDBwMrAxIAAegyMDIwAIkkBfwB42i3CbWwTZQAA4Pd9767X3l3vrnfttb1ee+3d9b4aN9OAArqRjMkEXdBpMhwyzMQxcUpCJpo5DDYbU1gkzkkcX8FJUTeykNVMRjDCIkwBMxkzsoVIsjCDGzGkEc2mWfSHeR4AgPu/LFgFKsB6UAPqQAPYDnaCVpAD+0A3OAT6QD8YAmfBKLgMJsA0mAFzoAgWIYIUFKAMNejCLFwFK+B6WAPrYAPcDnfCVpiD+2A3PAT7YD8cgmfhKLwMJ+A0nIFzsAgXEUIUEpCMNLQMPYoq0ZPoWfQ82oqaUQtqQ+2oC/WgI+gEOoW+ROfQt+gqmkQ30W10F/2B/sFwTMUsrAKrx/ZgPVgfVsDGsBvYEm7gq/FqvAnfhbfj3fhxfBC/jt/GiwRDaMSDRDlRQzQSLUQHcYI4T9wk/vbI/yn1POZp8Rz1XCEhyZEOuYZ8lewkPyZPkgXyOrng5b0PeTd7d3uPeS94f/FRvlJfpW+zL+c76Dvnm6EApVFrqUbqXeo4NUxdo+ZoREfpMrqabqY76Tw9Sv/K+BiHKWOeYpqZ/cwgc4WZZ5b8cX+p/2l/vb/Nf9h/xj/un2dp1mKr2C3sW2wPW2DH2Fl2kYtwy7karonr5D7lznCT3H1e4R/hn+Pf5Pfyn/Aj/AS/GAgH0oHywKZAS+Bo4GLgVuCe4BWigiusENYKtcI7Qq8wKEwKRRGIrJgR14m14g6xRxwWp8SloBHMBjcEXwl+FvwpRIeqQy+G2kMnQz+H/pI4SZdWSi9IXVK/dCPsCZeEa8N7wvnwVMQTMSKVkdci70UKkVtRIloSrYvmol9Ev4vOyl7ZkR+Xt8ndcr88LhdjUmxlbGvs/dhw7MfYvMIpy5QtSrtySrmk3I2T8ZJ4RbwpfiA+FL8Wv59QEqsTLyU6Ep8nxhK/q5Raoj6h7lA/UAvquPpnUk4+nNyUzCVPJyeTCyk1tTy1MfVG6mBqIHUhdU+LalXabm2/lte+0X7TMT2oa3qpvkF/Xe/Sh/QpfcGQjTKjzthrDBjnjSljKS2kV6Tr023pY+nR9IyJm4qZNavNRvNt8yNzxPzevGNhVsoqtxqsDitvjVhXrTs2abt2lb3NbrV77QH7B3vaXnAk5wFnnfOy0+Hkna+dKafoBty0u8bd6O5yP3RPu5fc2QzMSJls5plMa6Y381Xm4r8Nk/eAAAAAeNpjYGRgYABilfjLq+L5bb4yzWdhAIHrl2+lgelrM+cwMPxvYGFgbgByOcCSDABd9gwhAHja3ZJdDoAgDINb5SSetEd3kx9dshj1RWOXMVjIRwoUYEFTsaQgKz6K6it6CmnYLhDQ8xjkwKnzyj7nExykGUdNLZv8pK3ureDqZffR01X3nUAhU951brybH+grr3fj52oFzDWB5QAAeNpjYGRgYKn+HwMkGUAASDIyoAIWADjHAekAAHjaY2BhYWCcwMDKwMA0k+kMAwNDP4RmfM1gzMjJARRg4GSAAUYGJODs4afAcICB98F/lur/MQwMLNUMSxIYGPbf/w40q4G5AahEgYERAIuiD/gAAHjaY2BgYGJgYGAGYhEgyQimWRgMgDQHEILkeBnqHvz//x/MUnjAAGR+/f9YIQmsFgwACyoMRAAAACICiHjaxVrbjiPHeW6tZMUqywICGI53kYvCADF2gB7O7kq25AUcmMPh7BDikCOSs+u9EprNItnePrkPM6LfJ3mLBLnJIyQPkFfIVe7yn6oPPOyM5ATSajjF6qr//H//X9XjOM6TD/7R+cCh/x59Cx88/sD5DL7x+JHzN48iGX/ovHhUyPgj5+8e/bOMf+J8+OhfZPyx88tH/ybjnzqfPvpPGX/SGP/M+eLRf8n4U+dXH/5Sxj//2+cfdmT8mfPkF98Cxw8++gSY/esvNjL+wPn7x1/K+JHz2eOpjD90Fo89GX/kdB7/u4x/4nz8+L9l/LHjPv4fGf/U+dWTf5DxJ43xz5z1k9/L+FPn2ZN/kvHPj+ZP/kPGnzlf/P7LcVmEQWxy3UvSTRas1oV+6h/rF8+ef+XqaWFujT5L8jsThvrpuijS/OXpqb9OfH+zTuZxMu/4SXSs40QnxdpktNd8l2Ymz81CJ5kOojQMzEKpXma8AubmG31rMvkovNDEOJuaJA2Njrx4wx8b42W59lZJR0+CNOWNa89/Z2A6TPJCF4kGljoK8iLXyVIXQWQ6oEYYGl8YeZm/Dm5pwRJkWZZFmRm9MrHJvCJI4ryjlZoYPwlCfeflukShga6fxCAesbgeveroQeStzJW3Cvx3MJe8I8bwRHvxQmdgoww2ujDKg7/gAAxEIpcprUjKIi0L2HCll0EItr5bB/5aXydF5vkGicWWJWwKYmA7ff1KVqFcSzt9kcTFRZKtTJMuLIiShcliUDIuUIsgXunrTbFOYv2i8yUuQIHzZFnceWiAsDR6nYQLXBcAAXBukawMetDVd1lQFCAR2C8yOzHwhx45/zKZj5L5MUhFoaKBkwf/r5DileefoZG6QdbpY0SdAY9u4WXBxKzK0MuaJPRL3V7jalkFTz5/dvK7E6R/YMnzzjP75Ft6crKHg43aVVCsS4rX0+bjU0vhhCmgifNDkf7XJImr7kACED032S04FBnpkRcZfUScvwIZjjpKzdZBzg+n1mEwEQa+iTE8yxhcTf6cDoZ6nIKnaPGQF7j6NUQjxLZ+3nneYWKyF8n4SRpgbpgwuXMpiGDSC/NEe7deEHpzSEIS09MX3W+0V7xUqBDok/tZkBZ5Jw/CDkTg6fhiqJQ6+eH/KZL/uj/SF+PRTA8Hvf5o2m+Kr0/0i9/qCzPPSg/A4sWzZ1/+VQzV9aTfvTob9sEskAUJ6E3AAV927KifgoLHGq0PeZcDuEBcFWCcJAsXd8HCqAW4PUzSCAAMqfgAPN48QWCBcMBM1GmW/AmwKHeJRJmmCWLKWp76CIigqTJLACfGMM/3FiYKfPIM4PKqBPCCrxA/URkHRWBy9hoQBOq3IAd4apkZAgSVoBbLDGIKxHyHyckYwrgQeRtwvM7XoNSCfR8hEQIXnXpZAbiYr4OUA5UAPaeABPtcDBEmkjuGkioamTJIA4RLAsG8KBcBDgCTgmXAnBRwBE2yYF4ixKHA4QZxKUwAMBifNmTsOCkAqEKCb5iMchPeGsBpEEIRMxeE9cOSsAsLBWRDcMtGR6XhuQ9IBOLMIVNCFMREc7NY4GhLDBDsFMoCseOgB3oVSop9wdZrr6BHmaSuisHCeSUuVY35riQktFgIrV0/z121Tu6wbpC0SAQEzkxovDrFkSMX1WKTGowOsTobIzN/LoPMUPhRcbOegDkP/GlxopH/iwSkRmZemoYbBWvJgIlfEhVfKjTXj6KSPSG4CbKmAhAW5/2LwWgwG4xHU3XUwqsjkGGJdVpKdG4oQ7j2VVqyg+u+Q12CH0z2ND/eJzsa0IedWYgNQvYO3ZdDUvlrNEdA0a04MrDSlRkUVmLoQiAE4GDBL/aEqEz5B6oc7YJyUwe0Ers8T40vQc3MtbcsGI6VX9WGHAiTY0AXpD6G6SD2Qott2/bxuWdB1AMztaEfMj9NYkMxlKtm9G7bT1f2Q55XNvv28NxKmwgwh7qlBSVVkbjwNDQFfHEV5kc5BxAqSpzQJycWLKi7Q4RJoGbANMXrUhSqhOYZtW0CFxn6ay+mjgHiN/I40mAaYdJGYNsYKLuKzZ028W2QJTHaGJXtltDrZLsq5sEqxhwzyMbgCJJ6BfgY4bgw/joOfC9U2PKAF4E9J1wKVBJSDfuyyuLirpZMwP66P7kaTKeQCPrXujcenUtSXJsMmlMqZhCfQNeAcsAdG16XQRvrBsDxyrhWaGGdzAtIYrCC8rBmV5Zt8aZNJdZ8BN2NSysBeA0RJNgTGN64LejjGpJjv9JEaci76is1CnmTrarZQkRgYbMGWSZYGdBlYK1FQJ31S6WeH+uRCRjBdlwZJ5mNmAA8H8A+QNsSIqQOHhcSWleRAxu2gxqS2xY1KRlAy4RLcMqL4/fv3GtQS82Wju9TL9ytgmE8QAd0iMIQAmdy5YQW4dboGisAjgHhuKY38I4wHmCPa5kFtoUWeyL6FLDnxIMCCnlhviss2q1LOD+dAJQvqJlbwwBzIsnQmCRBCoKmWYDdTARCQmbUyyNTwKiAniIw4SInNXEfMgASc7AndGKM5K3yneTG7pH6CygfAFjfBuauRiuI1gy88zmERrLjlMM+gW30pIXTCnGaywWIk+O5E6wHhwR7gklbCSiZZyXxkwzqeYoBC1m2jaJSVGAFeF+gOcaWJcXjbIXcYMaIDIISY4lAkMbTL59qZRUqjRXzi2PqCGIRW7TdA+BScjXjWmNtKw+xk4MMlu7Bnl3BuVGCKW7iRQLnUqTlLfBsGVAZ3ahts8PS73yTUjrDATtO7iD2V0asJPAH62o51D6ZOYRbQmecJtw9bLtH1e4B2/yGbbOFbxUcAakanNx9JchVUZmTJZopC36AJgkct9tSMAjSJjZhq7pu92DNvNSHei/10N5LH+i9VN17bVeZGVaZURdLS/tUNzeAmEi8hGBAlW6TADr6ZbMgW9Sx6Iy9q0JpIN+xlRtMe8Pu4Ko/UbPLPp/HpuOL2ZvupK8HU309Gb8enPfP4aQ6he9Hrn4zmF2Ob2YaVky6o9lbOCDo7uit/nowOndV/49w0ppO9XiiB1fXw0H/3NWDUW94cz4YvdJnsG80xhPf1WAGRGdj2iqkBn3Yd6FAlt4lfO2eDYaD2VtXXwxmI6R5AUS7+ro7mQ16N8PuRF/fTK7HcHDsjs6B7GgwupgAl/5VfzRTIFVvfP12Mnh1OXNh0wwmXT2bdM/7V93J1y5KOAaVJ5qWdEBKoKH7r/togcvucKjhqapo6Mvx8BxWn/VB+i6cJFkckJ7s5+rz7lX3VX9a08VlrIGqLYAbXvVH/Ul36Orpdb83wAGYbjDp92ZkKzA3KD8kCaGnmPa/uYEJWKeEBfjgsk8sQOYu/N/D0NCk8Qg0RDqz8WRWifJmMO27ujsZTEEEdTEZg7joQtiBTr8BE6K/RiIvugXndgMCVuFuxQqe97tDIDhFMXbWdg5fHjhjp3QKJ3QCJ3aMkzva6TmJkzobJ4O5lbOGp9p56vjOMfx+4TxznjtfOS6Mp/DEOLfwo50z2JM7dzAO4R+ux30F0Mmdl84p/PNhJoFPHyjjaA788LMDM4kTEXWc0fBTwAoD/Gu+xvkOaGUkYQ6fC1qHKwLYm5L8OKvgX4/WeSQdrpsDR01yZlujAlaF8C2u1qbwOyF6qFUEz2NaWY82RDsjS3lgnwQ00M4E+Ke0u+a4hue+84644eqQbFQQ34Q+18IloPmcdFrSE9TKEGX0Rkjy+FsaoRRo1QA0qiksxS5L8mtJttAgpyH/ZmSXANbEsBrpo8UmRD2BefTdHaxBSmVlaZbXp11svVqLa2fkvCJKA7IScrqi3wFpz+sSGbHGvEeTTZF+JnGUCUdX5nKg8ZdqhiOotnIJo5pGQvqm9MkcrsgKAdkuJ73WJNOanmOUZeQhU0kW72jJnAKKkIRi/jVJ3qRl7bXcWX1BtAr6nZFlDsnLFCKYXRDnWDwZi1dLskUMNFD2Dcmb0KoXYPsvKwrWwjlFUkGy2QgIgYqhuMSIWlT0ApGAMxclR0ltDrqkYUarCrHRXHLCPAAH/gARXGf+JeX8iD6PxVY1qmjRyZPPVSXjFXnqrIqkLjzJQPN+hVFnokeXshrlxahegc4hfT8khQZ80u+l41J+N2nxns9B6hPnd/Bj5f9+VJ6D/M929nzb2HPyQB22sXZFlNawr8bX04O7T3dkOGnJcFHF4ffF9B+rkriAaXdiA7Z6TrF8KxlqNdJgAY/iWDtHDZ2/EjscAU3Exxlle97aOd3JsEBQPiBMiSv0LCnjuZ7Z/JwCWg7h95jQLG5RHrYooH1eCzYGkh8YOc9JtlqyNl8rjU8eCKq6YagK3RFVi0SB1LKQUANHt/ATUMzNpRLW1vRI1q7zDY0L8ImqPMT+yYFrRvWwoBqTE62OYOAp6HwBOir6d/Kj/FMN+19D9I9IpzH8npH9BxC5ODuFz0PW10AHo/i3tNeApTLwtCedBUb3M8DlH09DBZpNQP4uYOcZ6NSXaOFakIi/646Dn9wfj5iR7MFj6UFM1Qvk0rkwXhUSOeh3rDcYQ5gHij5vJRZTyj/mxLL40vFg9CVVx8LosKykwm4wcf4kfVFOEW2lKKlLSKo+Zb211686RPapgm9L6ZyafRjWHI+kjcgGdc6EUplK6bz4KeNPRBkf0KwRyew+lpBlvxV7cE4tSaa6Q1BkGyOdQCY4xdZ8V1XOZh/S7BewE9tIxmtCbvbUopX3USVJ3bmgdB7ZIZa4X1MuNxG17tDzBkJy/FxQXnE3gUjT7Ep2sbEpM9uGJS4bnWBOfexCUMyt+qSAurumTkp0ZJ8gBs2pv7K82MKhdM+2J+cOo9k/bRqRHZO23FGFje6bV0YkZ0gW5H6aLaEamrliWZ86sLrvsicKrg0BoW4d6dbTufS+nnRehj65poSVRVCSOX1bVHPvtwZb7FROC7V2TaRn+XZ7yXb8LsQanvSRvCvbqroK5jmG8z3Wrc8a8wfZpLZ0O4ZsbO/bn1NfsKaotOeN2rZWErZwRl41FBW7Vdzq2DypFjCT0l7GjnasNyMDaf+ZkCMjv1n0q09u2znB6zzJz+1+Yn/9X8BOtrXVzCNUxOhXQreOQOynyoYs/tYZunn+KPbYPWl0NwGN93uA0eIcqtEFVNkR/MzgZ0y1VkG/dbi/OhI7LKvzdPsUndOZxVq/ee7b9WUzg/fddyjqj0PR4SnsO36w3W0E+sIzE7yJaPyuyr5cKhVit42OoIHdqoUZ9kxX0pnftDR0BRECyeB2/9XMibaX6/rHXjl6UKd8yA82lppZnlNG+FtI3dQcvy8pyur4UdK1ts8NuUhcZwz7xco+ltUBSRDu9G33xY/fumexvR5H0/u6fq75Ka0wDRzKqc/Zj733xZ/eE39Wz6ud2vcwPd9fbSLpc+q7pUWjUiEFV/aGlGf8xKUuJRN/zqUTKkhTu/eE+uR2Z1Hf3dkeJpFzBq+u8XW55aFdSzfXqHujwK009KlixY07BsbfiOxSYxqvtt3kNga+LzKs3RXJe0dVOqaqmdEuG8fWs12y25o4PcSLOWkaV3XMVNqYao4r9Ur6x6iaLyjO19Sn+mQpVd3ycC4m8llXuFRkSRpes/dluzHezq7DdurIWaUP6HMFtWBKZ7Mxncl+TdmB4/OtSnFNsvDNaX0yY/xkeY14jnW3N7xuq9O25w3ujldy2m5buq013jMUUok5FhR17xaxtmP2sN41p7I659tOdyN9CdN05a6tlrDu9trd8IYy8lDX1zyH5NX9yqFemuvd7tP6RiE/qK3aqy1jhD2xbUfIUvA3oQ6Us4xjayFnKb6zfknx8pwq8oi6jWYPdn9WxhLZbYwJJOcD4ce9bSkYsg95XKnQeg/mMIf7kDoX77VPau1TBsuFvlpKprwgzX84z4dH6LZs26eO/6/zhXvPCcPQuXzdyBBVoRBnZvPMybcIt1UF2a603B0H0lXV5/T9/V3dx+dCsT6XbXdsC5K1GZ+29ymEzwn5jqOKMfk7OQk0e7s19Wy440S68kXjZm4tM7ZOoL1tZNY2SMWiKelu72YisSTXjH3UI6r2PFfIPUVA8biQdyqB2CpuacBSzCU++U6s2ZMfPn0nYtk2n/b5l3v5QDrrW1p5t7e3KqWf5dz5XFAjeUCm/JA8KUV2u+dwP62qfrp5ugjl/aZ938mxx28Stt/BpO+pgO2at20Tn7zD5/O0QliuZff1ou2TCtPg3G93zXF1y5JWb2d3e26OxqgRIdbGcXUvz510Wt0nxAc6DOtpe8b8gqxq7wjiLWu3ffuwDrx9ytWtfm0/3cP10N7JcQ1u3z1sv3flzI1ojak6vQXxzaWPyaRnt+8tg8ZpFPHxvmh3JeYQ6dJGdeY32DFVZcb9VSvCd7s/prfPHurBdm6i8GFLZ61q0rx7uC971N7s4bj5TStu3t+/7XZHLNW+zsl98CkIK2tEUVDHxKEqy/kQyB3H5oG3FM1OsObUjMLDZ9f77sEO1Uv9ve+91P/5vZf+nvdeau+9131nmVl1lhlB5NpTy/ve1c3l7y+iSvJSkMF66Zb+OoPv6JcHT8jbvc5272zvXVVlG67v9lYOT189ZwhSD0B+1AKlvqS3YPX7sSnd8s+cN7BuQs9wn6b3TWPAlQHd753LO9WpPD+iqHtD57hLWHdDtJjGBD6R9lt5g6DpO377mqx4TjnRd/4o77SmRHUMY02SXtM7uz6t07QDtbghjfgvTc6E3wh22Xd8VyQLSzqD+ZprW6oBcWTJlNilBzrw0y7QHhA9lN8lS+F4VMl5IZJ2yUZIeUZvGG/I0hOavYHf17CO3zh2SWeWdkQ6XMBz1qVPEiBnJbbq0VvMt7TiFcg1IymuKfZ4pUsaoj7ntB+5fk2zLNlYvDyhnsVS6YgtWQ78G4nXQg9jAPUf0rse3qv2yKHJ00PiOiEv9MX2XXkn2bQO276OP5TvnN5fdknv6V55LbWmD9TeGLAcXpEWfbLHUP7+AO8fekRpWMUQ7pzQ/KwRVxzd7Plhw4Y9uZvoO98A175ETpfedLe14DxA+Wst2M5d+exVqKEbPh6JD3uVR8cUS7tWeUMZ16dVXfLHVKygKJLGYl2bhczDZvqNROG4kqxtX5stdt1DEIJpWd6q5cFzeks9FAmnlTXup9v5IX958L9prALcAHjaXdVTFGaHFYbh/e2xbdvY//H4/AdjeyasU6RM3aa2baW2mdq2bdtK25W8V90331r75rl8ze3Gu2GuXfe/kf3f6fobv24jbKSNstE2xsbaOBtvE2yiTbLJNsWm2jSbbjNsps2y2TbH5to8m28LbKEtssW2xJbaMltuK2ylrbLVtsbW2jpbbxtso22yzbbFtlrYwBJLLbPcCiutsm223XbYTttlu22P1Ta0xlrrrLe9ts/22wE7aIfssB2xo3bMjtsJO2mn7LSdsbN2zs7bBbtol9ildpldblfYlXKN0EiN0miN0ViN03hN0ERN0mRN0VRN03TN0EzN0mzN0VzN03wt0EIt0mIt0VIt03Kt0Eqt0mqt0Vqt03pt0EZt0mZt0VaFBkqUKlOuQqUqbdN27dBO7dJu7VGtoRq16tRrr/Zpvw7ooA7psI7oqI7puE7opE7ptM7orM7pvC7ooi7RpbpMl+sKXamb6ea6hW6pW+nWuo2u0m11O91ed9DVuqPupDvrLrqr7qZrdHfdQ/fUvXRv3Uf31f10f12rB+iBepAerIfooXqYHq5H6JF6lB6tx+ixepweryfoiXqSnqyn6Kl6mp6uZ+iZepaerefouXqenq8X6IV6ka7Ti/USvVQv08v1Cr1Sr9Kr9Rq9Vq/T6/UGvVFv0pv1Fr1Vb9Pb9Q69U+/S9Xq33qP36n16vz6gD+pD+rA+oo/qY/q4PqFP6lP6tD6jz+pz+ry+oC/qS/qyvqKv6mv6ur6hb+pb+ra+o+/qe/q+fqAf6kf6sX6in+pn+rl+oV/qV/q1fqPf6nf6vf6gP+pP+rP+or/qb/q7/qF/6l/6t27Qf9xc7j7CR/ooH+1jfKyP8/E+wSf6JJ/sU3yqT/PpPsNn+iyf7XN8rs/z+b7AF/oiX+xLfKkv8+W+wlf6Kl/ta3ytr/P1vsE3+ibf7Ft8q4cPPPHUM8+98NIr3+bbfYfv9F2+2/d47UNvvPXOe9/r+3y/H/CDfsgP+xE/6sf8uJ/wk37KT/sZP+vn/Lxf8Itjrrn6qm7r1q1ssAM2YVM2Y3O2YEu2Ymt2yDZsy3Zsf9MGfuAHfuAHfuAHfuAHfuAHfuAHfuAHfuAP8Af4A/wB/gB/gD/AH+AP8Af4A/wB/gB/gD/AH+An+Al+gp/gJ/gJfoKf4Cf4CX6Cn+An+Al+gp/gp/gpfoqf4qf4KX6Kn+Kn+Cl+ip/ip/gpfoqf4mf4GX6Gn+Fn+Bl+hp/hZ/gZfoaf4Wf4GX6Gn+Hn+Dl+jp/j5/g5fo6f4+f4OX6On+Pn+Dl+jp/jF/gFfoFf4Bf4BX6BX+AX+AV+gV/gF/gFfoFf4Jf4JX6JX+KX+CV+iV/il/glfolf4pf4JX6JX+JX+BV+hV/hV/gVfoVf4Vf4FX6FX+FX+BV+hV/h1/g1fo1f49f4NX6NX+PX+DV+jV/j1/g1fo1f4w/xh/hD/CH+EH+IP8Qf4g/xh/hD/CH+EH+IP8Qf4jf4DX6D3+A3+A1+g9/gN/gNfoPf4Df4DX6D3+C3+C1+i9/it/gtfovf4rf4LX6L3+K3+C1+i9/id/gdfoff4Xf4HX6H3+F3+B1+h9/hd/gdfoff4ff4PX6P3+P3+D1+j9/j9/g9fo/f4/f4PX6P39/kB90Luhd0L+he0L2ge0H3gu4F3Qu6F3Qv6F7QvaB7QfeC7gXdC7oXdC/oXtC9oHtB94LuBd0Luhd0L+he0L2ge0H3gu4F3Qu6F3Qv6F7QvaB7QfeC7gXdC7oXdC/oXtC9oHtB94LuBd0Luhd0L+he0L2ge0H3gu4F3Qu6F3Qv6F7QvaB7QfeC3gW9C3oX9C7oXdC7oHdB74LeBb0Lehf0Luhd0Lugd0Hvgt4FvQt6F/Qu6F3Qu6B3Qe+C3gW9i6L5L8nBqngAAAAAAAH//wACAAEAAAAMAAAAAAAAAAIAAQABAWEAAQAA) format('woff');
        font-weight: normal;
        font-style: normal;
    }

    body {
        background-color: #F8F8F8;
        font-family: "Open Sans", "Helvetica Neue", Helvetica;
        padding: 20px;
        display: flex;
        flex-direction: column;
    }

    canvas {
        border: none;
        padding: 0px;
        margin: 0px;
        transform-origin: 0px 2px;
    }

    nav {
        border: solid 1px #CCC;
        background: #CCF;
    }

    ul {
        list-style-type: none;
        border: none;
        margin: 0px;
        padding: 0px;
    }

    li {
        font-size: x-small;
    }

    li:hover {
        background-color: yellow;
        filter: brightness(200%);
    }

    li .recovered {
        filter: brightness(75%);
    }

    li .isdir {
        filter: brightness(125%);
    }

    h1, h2, h3, h4, h5, h6 {
        font-weight: 300;
    }

    h2 {
        font-size: 30px;
    }

    #gl {
        border: solid 1px #C00;
    }

    canvas {
        image-rendering: -moz-crisp-edges;          /* FF 6.0+                       */
        image-rendering: -webkit-optimize-contrast; /* Safari                        */
        image-rendering: -o-crisp-edges;            /* OS X & Windows Opera (12.02+) */
        image-rendering: pixelated;                 /* Awesome future-browsers       */
        image-rendering: crisp-edges;
        -ms-interpolation-mode: nearest-neighbor;   /* IE                            */
    }

    td {
        border: solid 8px #F8F8F8;
        padding: 16px;
        margin: 16px;
        background: #23A;
        color: #FFF;
        font-weight: 500;
    }

    .sw {
        background: #A32;
    }

    .hw {
        background: #3A2;
    }

    .over {
        border: 2px dashed #F00;
    }

    .info {
        display: flex;
        flex-direction: column;
        min-height: 32px;
        padding: 8px;
        border-bottom: 1px solid #CCC;
        font-size: small;
    }
    
    /*(PVB ADD) NEW ADDED STYLES FOR ROM MANAGEMENT MENU*************/
    .rommap {
        padding: 8px;
        border-bottom: 1px solid #CCC;
        font-size: 12px;
    }
    .rominfoid {
        padding: 5px 5px 5px 5px;
        border: 1px solid green;
        color: green;
        font-size: 11px;
        line-height: 1.1em;
        margin-bottom: 8px;
    }
    .extract {
        overflow: auto;
        font-size: 11px;
        padding: 10px;
        border-bottom: 1px solid #CCC;
    }
    #extractinfo {
        font-size: 12px;
        font-weight: bold;
        padding-left: 12px;
    }
    /*(PVB ADD) STYLE FOR THE DISASSEMBLY EXTRACT BUTTON*************/
    .buttonstyled {
        border-color: #FFF;
        padding: 3px;
        border-radius: 4px;
        /*height: auto;
        text-align: center;
        color: #000;*/
    }
    .buttonstyled:hover {
        background-color: #CCF;
    }
    .buttonstyled:active {
        box-shadow: inset -1px -1px 2px rgba(255, 255, 255, 0.6), inset 1px 1px 2px rgba(0, 0, 0, 0.6);
    }
    .buttonstyled:disabled {
        color: #888;
        background-color: rgba(180, 180, 180, 0.6);
    }
    /* (PVB ADD) STYLE FOR THE ID=FILE DISASSEMBLY & DUMP DISPLAY OPTIONS*/
    pre#disoption {
        border-bottom: solid 1px #CCC;
    }
    .doblock {
        margin-top: -20px;
        display: flex;
        align-items: flex-end;
        justify-content: space-between;
    } 
    .docbgrp {
	    display: flex;
	    align-items: center;
    }
    input[type="checkbox"] {
	    width: 10px;
	    height: 10px;
	    margin-right: 0.5rem;
        cursor: pointer;
    }
    label {
        line-height: 1em;
    } 
    fieldset {
        margin-top: 6px;
        border: solid 1px #CCC;
    }
    .dobgrp {
        display: flex;
        flex-direction: column;
        align-items: flex-end;
    }
    input {
        margin-top: 2px;
        font-size: 12px;
    }
    /*(PVB end of ADD) **********************************************/
    
    .infof {
        min-height: 32px;
        padding: 8px;
        border-bottom: 1px solid #CCC;
        font-size: small;
        overflow: hidden;
    }

    .close-icon {
        display: block;
        box-sizing: border-box;
        width: 12px;
        height: 12px;
        border-width: 2px;
        border-style: solid;
        border-color: gray;
        border-radius: 100%;
        background: -webkit-linear-gradient(-45deg, transparent 0%, transparent 46%, white 46%, white 56%, transparent 56%, transparent 100%), -webkit-linear-gradient(45deg, transparent 0%, transparent 46%, white 46%, white 56%, transparent 56%, transparent 100%);
        background-color: gray;
        transition: all 0.3s ease;
        margin: 4px;
        float: right;
    }

    .close-icon:hover {
        border-color: red;
        background-color: red;
    }

    .radio {
        user-select: none;
        cursor: pointer;
        font-size: 12px;
        height: 16px;
        margin-left: 10px;
        margin-right: 10px;
        margin-top: 4px;
    }

    .radio:last-child {
        margin-right: 0px;
    }

    .radio span {
        margin-right: 1px;
        border: 1px solid #AAC;
        padding-left: 12px;
        padding-right: 12px;
        vertical-align: top;
    }

    .hilite {
        background: #CCF;
    }

    .exts {
        font-weight: 300;
        padding: 4px;
        margin: 4px;
        font-size: small;
        width: 600px;
    }

    .exts b {
        display: inline-block;
        margin-right: 16px;
        width: 140px;
        text-align: right;
    }

    .open {
        display: inline-block;
        font-size: large;
        cursor: pointer;
        width: 200px;
        border: solid 1px #CCC;
        font-weight: 300;
        margin: 20px;
        color: #AAA;
    }

    .open:hover {
        color: #888;
        border: solid 1px #888;
    }

    .open:active {
        color: #FFF;
        border: solid 1px #FFF;
    }

    .showcode {
        cursor: pointer;
        height: 16px;
        padding: 2px 4px;
        margin-left: 12px;
        margin-right: 12px;
        margin-top: 4px;
        border: solid 1px #CCC;
        background-color: #EEE;
    }

    .showcode:hover {
        color: #F00;
        border: solid 1px #F00;
    }

    /*(PVB ADD) NEW ADDED STYLES FOR BANK DUMP/DISASSEMBLY BUTTON****/
    .bankcode {
        cursor: pointer;
        height: 12px;
        padding: 1px 2px;
        margin-left: 4px;
        margin-right: 4px;
        margin-top: 2px;
        border: solid 1px #888;
        background-color: #EEE;
    }
    .bankcode:hover {
        color: #F00;
        border: solid 1px #F00;
    }
    /*(PVB end of ADD) **********************************************/

    .palette {
        margin-left: 8px;
        display: inline-block;
        margin-top: -2px;
    }

    .dropdown {
        position: relative;
        display: inline-block;
    }

    .dropdown-content {
        display: none;
        position: absolute;
        top: 16px;
        background: #CCC;
        min-width: 288px;
        box-shadow: 0px 8px 16px 0px rgba(0, 0, 0, 0.5);
        z-index: 100;
        margin: 0px;
        padding: 0px;
    }

    .dropdown:hover .dropdown-content {
        display: block;
    }

    .acolor {
        display: inline-block;
        min-width: 16px;
        min-height: 16px;
        border: solid 1px #CCC;
        vertical-align: bottom;
    }

    .acolor:hover {
        border: solid 1px #FFF;
    }

    .atari {
        font-family: 'Atari';
        font-size: 16px;
        line-height: 16px;
        background: #153382;
        color: #B5D3FF;
    }

    #atari_text {
        padding: 4px;
    }
    /*(PVB MOD) ADJUSTEMENT ON PRE AND PRE DATA STYLE*/
    pre {
        font-family: 'Noto Sans Mono', monospace;
        padding: 8px;
        font-size: 12px;
        line-height: 14px;
    }

    pre data {
        font-family: 'Atari';
        font-size: 10px;
        font-weight: normal;
        background: #153382;
        color: #B5D3FF;
    }

    .floater {
        position: fixed;
        z-index: 10;
        cursor: pointer;
        user-select: none;
        line-height: 16px;
        letter-spacing: 0px;
        box-shadow: 0px 8px 16px 0px rgba(171, 163, 163, 0.5);
    }

    .floater span:hover {
        filter: brightness(200%);
    }

    .floater span:active {
        background: #B5D3FF;
        color: #153382;
    }

    .disassembly {
        left: 24px;
        top: 384px;
        width: 492px;
        max-height: 384px;
        overflow: scroll;
        background: #EEE;
    }

    .draggable {
        width: 100%;
        padding: 4px 8px;
        background: #CCF;
        border: solid 1px #CCC;
        font-size: small;
        font-weight: bold;
    }
    /*(PVB MOD) height to 148px instead of 84 (4x16 added) for the E, P, S and M option*/
    .tools {
        width: 20px;
        height: 148px;
        left: 0px;
        top: 320px;
        text-align: center;
    }

    .dimmed {
        filter: brightness(75%);
    }

    .keyboard {
        display: none;
        left: 24px;
        top: 320px;
        height: 256px;
        width: 256px;
        z-index: 11;
    }

    .keyboard_invert {
        font-family: "Open Sans", "Helvetica Neue", Helvetica;
        text-align: center;
        vertical-align: center;
        color: #000;
        font-size: x-small;
        background: #F8F8F8;
    }

    .keyboard_invert:hover {
        background: #CCF;
    }
</style>
<!--(PVB PVBest infoo ADD) the script link to get the "HTML to CANVAS" function - if someone had better idea, let me know-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<script>
    var _ajax = function (m, u, c, d) {
        var x = new XMLHttpRequest;
        x.onreadystatechange = function () { x.readyState ^ 4 || c(this) };
        x.open(m, u);
        if (d) {
            x.setRequestHeader('Content-Type', 'application/json');
            d = JSON.stringify(d);
        }
        x.send(d);
    };

    var _q = function (q) { //(PVB COM) q is an id selector like "#toc", ou or class selector like ".disassembly"
        return document.querySelector(q) //(PVB COM) returns the HTML selector, ex "div.floater.disassembly"
    };

    //(PVB ADD) the _g() function
    var _g = function (q) { //(PVB COM) q is an id selector like "toc" in div id = toc
        return document.getElementById(q) //(PVB COM) returns the HTML selector, ex "div.floater.disassembly"
    };
    //(PVB END OF ADD)

    var _h = function (q, html) {
        var e = _q(q);
        if (!e) {
            console.log("_h can't find " + q);
            return null;
        }
        return e.innerHTML = html; //(PVB COM) display the "html" in the <div id= 'e' > HTML element
    };

    var _txt = function (q) {
        return _q(q).innerText;
    };

    function stop() {
        event.preventDefault();
        event.stopPropagation();
    }

    function get(url, cb, d) {
        _ajax(d ? "post" : "get", url, function (r) {
            var o = JSON.parse(r.responseText);
            cb(JSON.parse(r.responseText));
        }, d);
    }

    function save_bytes(name, data) {
        var blob = new Blob([data], { type: "application/data" });
        var link = document.createElement('a');
        link.href = window.URL.createObjectURL(blob);
        link.download = name;
        link.click();
        window.URL.revokeObjectURL(link.href); //(PVB ADD) revoke to clear memory
    }
    //(PVB ADD) Save the editor() DIV id = "atari_text" into an PNG image
    function save_as_png() {
        console.log("save_as_png() =>Try to save the editor() into PNG image...")
        html2canvas(editor()) //call to an external <script> function - if someone has better idea, let me know
            .then((canvas) => {
                var link = document.createElement("a");
                link.href = canvas.toDataURL("image/png");
                link.download = _shown.name + ".png";
                link.click();
            })
            .catch(function (error) {
            console.error('save_as_png() => Error something went wrong!', error);
            });
    }
    //(PVB END OF ADD)

    var _hex = "0123456789ABCDEF";
    function hex(i, len) {
        var s = '';
        if (!len) //(PVB COM) taille par defaut = 2 caracteres
            len = 2;
        if (i >> (len * 4)) len++; //(PVB MOD) // protection if len is one digit not enough: add a digit
        while (len--)
            s += _hex[(i >> (len * 4)) & 0xF];
        return s;
    }

    //(PVB ADD) escAtasciiChar(b) to modify atari char into an UTF-16 normal char, close to the original one, in the Client system font, but no inverted char considered
    function escAtasciiChar(b) {
        var _escUTFChar = [ //ATASCII control char converted into the closest UTF-16 char
            0x2665,0x2523,0x2595,0x251B,0x252B,0x2513,0x2571,0x2572, 0x25E2,0x2597,0x25E3,0x259D,0x2598,0x2594,0x2582,0x2596,
            0x2663,0x250F,0x2501,0x254B,0x2523,0x2584,0x258F,0x2533, 0x253B,0x258C,0x2517,0x0190,0x2191,0x2193,0x2190,0x2192
        ];
        var cUTF16;
        switch (b) {
            case 0x60:
            case 0xE0:
                cUTF16 = 0x2666; break; //diamond char symbol
            case 0x7B:
                cUTF16 = 0x2660; break; //spade char symbol
            case 0x9B:
                cUTF16 = 0x0190; break; //Return (Line feed) (note: $1B = Escape) [ESC char symbol]
            case 0x7D:
            case 0xFD:
                cUTF16 = 0xB6; break; //Clear & Buzzer [upper left corner arrow char symbol]
            case 0x7E:
            case 0xFE:
                cUTF16 = 0x25C0; break; //left arrow: Delete & Backstace
            case 0x7F:
            case 0xFF:
                cUTF16 = 0x25B6; break; //right arrow: Tab & Insert
            case 0x82: cUTF16 = 0x258A; break; // 3/4 right vertival
            case 0x88: cUTF16 = 0x25E4; break; // triangle up left
            case 0x89: cUTF16 = 0x259B; break; // corner left up
            case 0x8A: cUTF16 = 0x25E5; break; // triangle up right
            case 0x8B: cUTF16 = 0x2599; break; // corner left down
            case 0x8C: cUTF16 = 0x259F; break; // corner right down
            case 0x8D: cUTF16 = 0x2586; break; // 3/4 down horizontal
            case 0x8E: cUTF16 = 0x2580; break; // 3/4 up horizontal //approx
            case 0x8F: cUTF16 = 0x259C; break; // corner right up
            case 0x96: cUTF16 = 0x2595; break; // 3/4 right vertical //approx
            case 0x94: cUTF16 = 0x25D8; break; // inverted dot
            case 0x95: cUTF16 = 0x2580; break; // 1/2 up horizontal
            case 0x96: cUTF16 = 0x2595; break; // 3/4 right vertical //approx
            case 0x99: cUTF16 = 0x2590; break; // 1/2 right vertical
            case 0xA0: cUTF16 = 0x2588; break; // inverted space char
            default:
                cUTF16 = b & 0x7F; //cancel inverted Atascii Char for the others, and get UTF-16 code for Atari control char
                if ((b & 0x7F) < 0x20)
                    cUTF16 = _escUTFChar[cUTF16];
                //else normal ASCII (non inverted)
                break;
        }
        return String.fromCharCode(cUTF16);
    }
    //(PVB ADD) escHtmlChar(c) to escape HTML char with the normal font listing
    function escHtmlChar(c) { //(PVB COM) escaping the HTML <> in the string
        switch (c) {
            case "<": return "&lt;"
            case ">": return "&gt;"
            case "&": return "&amp;"
            case "'": return "&apos;"
            case '"': return '&quot;'
        }
        return c;
    }
    //(PVB ADD) escHtmlString(s) to get a clean "escaped" HTML string with normal font listing
    function escHtmlString(s) { //(PVB COM) esc function is not used ??!! //(PVB TODO) = check why
        var n = ''; 
        for (var i = 0; i < s.length; i++)
            n += escHtmlChar(s.charAt(i));
        return n;
    }

    //(PVB MOD) improvement of hex_line() function: display of sector/offset
    //previously //function hex_line(addr, data, i, len, awidth) {
    //added : sector and sector offset display instead of memory pointer
    //modified the variable name 'i' to 'idx' for index
    //when 'awidth' is the sector_size value (128) or (256), thus greater than 15
    function hex_line(addr, data, idx, len, awidth, dsector, doffset) {
        //addr = address of the beginning of the line; data = byte database;
        //idx = index in the byte database; awidth = number of char to display if <=15; or if not, a sector and an offset (dsector, doffset) to display
        var s = []; //(PVB MOD) Add / pointer + hex byte string
        if (awidth > 15) //(PVB MOD) awitdth is greater than 15 => this is a sector size
            s = ["[" + hex(dsector, 4) + ":" + hex(doffset, 2) + "] "];
        else //(PVB MOD) default display
            s = [hex(addr, awidth || 6) + "   "]; //if awidth is zero then it is replaced by 6 digits, which should be enought for a disk dump pointer up to 0xFFFFFF bytes
        //(PVB MOD) variable declaration
        var a1 = ''; //Atari ANTIC internal display String
        var a2 = ''; //Atari ATASCII (= Ascii for Atari) String
        var pcs1 = ''; //Padding left
        var pcs2 = ''; //Padding right

        var left = addr & 15;
        var right = (16 - ((addr + len) & 15)) & 15;
        if (left) {
            pcs1 += `<span style='background:#DDD'>${' '.repeat(left - 1)} </span>`;
            s.push('   '.repeat(left));
        }
        //(PVB MOD) the char dump is for ANTIC and ATASCII char
        while (len--) {
            var j1 = data[idx]; //by default byte data are ATASCII char codes (byte 00 is a heart char)
            var j2 = j1;
            //convert into ANTIC internal display char code
            if ((j1 & 0x7F) < 64) j1 += 32;
            else if ((j1 & 0x7F) < 96) j1 -= 64;
            //j1 is ANTIC code, j2 is ATASCII code
            if (!_bShowWebChar) { //get the Atari font Char
                a1 += String.fromCharCode(j1 + 0xE000); 
                a2 += String.fromCharCode(j2 + 0xE000); 
            }
            else { //get the equivalent converted HTML Monospace Font Char
                a1 += escAtasciiChar(j1);
                a2 += escAtasciiChar(j2); 
            }
            //push the Hex code into the string
            s.push(hex(data[idx++], 2) + " ");
        }
        //for normal HTML Monospace Font Char string, escape HTML char 
        if (_bShowWebChar) {
            a1 = escHtmlString(a1);
            a2 = escHtmlString(a2);
        }
        if (right) {
            pcs2 += `<span style='background:#DDD'>${' '.repeat(right - 1)} </span>`;
            s.push('   '.repeat(right));
        }
        //(PVB MOD) the display of ATASCII and ANTIC internal display char dump
        if (_bShowDispChar & _bShowAtasciiChar) //ATASCII on the left, ANTIC internal display on the right
            return s.join('') + "   <data>" + pcs1 + a2 + pcs2 + "</data>" + "   <data>" + pcs1 + a1 + pcs2 + "</data>";
        if (_bShowDispChar & !_bShowAtasciiChar)    
            return s.join('') + "   <data>" + pcs1 + a1 + pcs2 + "</data>";
        if (!_bShowDispChar & _bShowAtasciiChar)    
            return s.join('') + "   <data>" + pcs1 + a2 + pcs2 + "</data>";
        return s.join('');
    }

    //(PVB MOD) improvement of hex_dump() function: display of sector/offset
    //previously //function hex_dump(a, i, len, awidth) {
    //modified : the variable name 'hexOption' instead of 'awidth'
    //if 'awidth' has a sector_size value (128) or (256), then sector and sector offset are displayed instead of memory pointer
    //if 'awidth' is greater or equal to 0x1000, then the 'awidth' is an address used for real memory pointer display
    function hex_dump(a, i, len, hexOption) {
        //(PVB) a = byte database; i = index from 0 to xxxx = address; len = number of data to compute
        //if hexOption = x then there is x char for the memory pointer, but if hexOption = 0 then there is 6 char (thanks to hex_line() function)
        //if hexOption = 128 or 256 then we display the sectors and not the memory pointer
        //if hexOption >= 0x1000 then we display the memory address of the ROM bank (there is no lower address than 0x1000 for ROM)
        // then hexOption is formated like 0x10BK where BK is the rom bank number 0..$FF
        var hexdump = []; //(PVB) changed name !! from 'hex' to 'hexdump' - because not to confuse with the hex() function 
        var st; //(PVB ADD)
        //(PVB ADD)
        if (hexOption == 128 || hexOption == 256 ) { //sector_size : compute the sector & offset, then display both of them
            var dsector = 0, doffset = 0;
            hexdump.push("; Sector #" + (dsector+1) + " (at file offset $000000)");
            for (var j = 0; j < len; j += 16) { // one line = 16 bytes
                st = Math.min(16, len - j);
                k = dsector;
                if ((i+j) < 384) {
                    dsector = Math.floor((i+j) / 128);
                    doffset = (i+j) - ((dsector) * 128);
                }
                else {
                    dsector = Math.floor(((i+j) - 384)/ hexOption) + 3;
                    doffset = ((i+j)- 384) - ((dsector - 3) * hexOption);
                }
                if (k != dsector)
                    hexdump.push("; Sector #" + (dsector + 1) + " (at $" + hex(j, 6) + ")"); //(PVB COM) add an empty line between sectors
                //hexOption = a Sector Size, then display the sectors 
                hexdump.push(hex_line(j, a, i + j, st, hexOption, dsector + 1, doffset)); 
            }
            hexdump.push(";<i>End of sector dump \><a href='#top'>Back to top</a></i>");
        }
        //(PVB ADD)
        else if (hexOption >= 0x1000) { //the ROM Disassembly
            var bk = hexOption & 0xFF;//extract the bank number 0xff max
            hexOption &= 0xFF00; // clear the lowest byte of the bank number
            for (var j = 0; j < len; j += 16) { // one line = 16 bytes
                //hexOption = a Start Address, then display the real address
                hexdump.push((_bShowROMBank ? ("n" + hex(bk,2) + ":") : "") + hex_line(hexOption + j, a, i + j, Math.min(16, len - j), 4));
            }
        }   
        else {
            //(PVB end of ADD)
            var k = 0;
            for (var j = 0; j < len; j += 16) { // one line = 16 bytes
                //hexOption = a number of char, then display an index from Zero
                hexdump.push(hex_line(j, a, i + j, Math.min(16, len - j), hexOption)); //hexOption = number of char, 6 is considered if hexOption = 0
                if ((k & 0xF) == 0xF) hexdump.push("");
                k++;
            }
        }
        return hexdump.join("\n");
    }

    //===================================================================================================

    var _fcanvas;
    function draw(ctx, s, x, y, fcanvas) {
        fcanvas = fcanvas || _fcanvas;
        for (var i = 0; i < s.length; i++) {
            var n = s.charCodeAt(i);
            ctx.drawImage(fcanvas, n * 8, 0, 8, 8, x * 8, y * 8, 8, 8);
            x++;
        }
    }

    // generate a canvas containing atari font
    function get_font(src, palette, one_bit) {
        // map atascii to a line of font bits
        // https://www.atariarchives.org/mapping/appendix10.php
        function font_bits(c, y) {
            var invert = c & 0x80 ? 0xFF : 0x00;
            c = c & 0x7F;
            if (c >= 32 && c < 96)
                c -= 32;
            else if (c < 32)
                c += 64;
            return src[c * 8 + y] ^ invert;
        }

        var canvas = document.createElement('canvas');
        canvas.width = 256 * 8;
        canvas.height = 8;
        var ctx = canvas.getContext('2d');

        var pix = ctx.getImageData(0, 0, 256 * 8, 8);
        var d = pix.data;
        var f = 0;
        var i = 0;
        var ap = (p) => {
            p = atari_palette_rgb[palette[p]];
            d[i + 0] = (p >> 16) & 0xFF;
            d[i + 1] = (p >> 8) & 0xFF;
            d[i + 2] = p & 0xFF;
            d[i + 3] = 0xFF;
            i += 4;
        }
        if (!palette) {
            palette = [128 + 20, 128 + 30];
            one_bit = true;
        }
        var bg = atari_palette_rgb[128 + 20];
        for (var y = 0; y < 8; y++) {
            for (var c = 0; c < 256; c++) {
                var b = font_bits(c, y);
                if (palette) {
                    if (one_bit) {
                        for (var x = 0; x < 8; x++) {
                            ap((b >> 7) & 1);
                            b <<= 1;
                        }
                    } else {
                        for (var x = 0; x < 4; x++) {
                            ap((b >> 6) & 3);
                            ap((b >> 6) & 3);
                            b <<= 2;
                        }
                    }
                } else {
                    /*
                    for (var x = 0; x < 8; x++) {
                        if (b & 0x80) {
                                d[i+0] = 128;
                                d[i+1] = 162;
                                d[i+2] = 255;
                            } else {
                                d[i+0] = (bg >> 16) & 0xFF;
                                d[i+1] = (bg >> 8) & 0xFF;
                                d[i+2] = (bg >> 0) & 0xFF;
                            }
                            d[i+3] = 0xFF;
                            i += 4;
                            b <<= 1;
                    }
                    */
                }
            }
        }
        ctx.putImageData(pix, 0, 0);
        return canvas;
    }

    //===================================================================================================

    class Octree {
        constructor(bits) {
            this.leaves = 0;
            this.count = 0;
            this.leaf_level = bits || 4;
        }

        insert(node, color, level) {
            var level;
            if (!node) {
                node = {
                    level: level,
                    n: 0,
                    red: 0,
                    green: 0,
                    blue: 0,
                }
                if (level < this.leaf_level)
                    node.child = [];
                else
                    this.leaves++;
            }
            node.n++;
            node.red += (color >> 16) & 0xFF;
            node.green += (color >> 8) & 0xFF;
            node.blue += color & 0xFF;
            if (node.child) {
                var k = this.key(color, level);
                node.child[k] = this.insert(node.child[k], color, level + 1);
            }
            return node;
        }

        key(color, level) {
            var k = 0;
            var m = 0x80 >> level;
            if ((color >> 16) & m) k |= 0x04;
            if ((color >> 8) & m) k |= 0x02;
            if (color & m) k |= 0x01;
            return k
        }

        color(node) {
            var r = node.red / node.n | 0;
            var g = node.green / node.n | 0;
            var b = node.blue / node.n | 0;
            return { n: node.n, color: ((r << 16) | (g << 8) | b) };
        }

        add(color) {
            this.root = this.insert(this.root, color, 0);
            this.count++;
        }

        scan(node, level, list) {
            if (node.level == level) {
                list.push(node);
                return;
            }
            if (node.child)
                node.child.forEach(c => this.scan(c, level, list));
        }

        finalize(count) {
            var pal;
            var level = 0;
            do {
                pal = [];
                this.scan(this.root, level++, pal);   // scan into levels until we get enough colors
            } while (pal.length < count);
            console.log(pal);
            pal.sort((a, b) => b.n - a.n);
            if (pal.length >= count)
                pal.length = count;
            return pal.map(node => this.color(node));
        }
    }

    function octree(pix, count, gray) {
        var d = pix.data;
        var q = new Octree();
        for (var i = 0; i < pix.width * pix.height * 4; i += 4) {
            var r = d[i];
            var g = d[i + 1];
            var b = d[i + 2];
            if (gray)
                r = g = b = (r * 0.29 + g * 0.59 + b * 0.12) | 0;
            q.add((r << 16) | (g << 8) | b, 0);
        }

        var pal = q.finalize(count);
        return pal.map(c => rgb2atari((c.color >> 16) & 0xFF, (c.color >> 8) & 0xFF, c.color & 0xFF));
    }

    //===================================================================================================
    //  Kmeans for palettes

    function median_cut(pix, centroid_count) {
        var sample_count = pix.width * pix.height;
        var d = pix.data;
        var index = new Uint32Array(sample_count);
        for (var i = 0; i < sample_count; i++)
            index[i] = i * 4;
        var slices = [index];

        function cut(s) {
            var rgb = [];
            for (var c = 0; c < 3; c++)
                rgb.push({ c: c, min: 255, max: 0, d: new Uint32Array(256) });
            for (var i = 0; i < s.length; i++) {
                for (var c = 0; c < 3; c++) {
                    var v = d[s[i] + c];
                    rgb[c].d[v]++;
                    rgb[c].min = Math.min(v, rgb[c].min);
                    rgb[c].max = Math.max(v, rgb[c].max);
                }
            }
            rgb.sort((a, b) => (b.max - b.min) - (a.max - a.min));
            var split = rgb[0];
            var c = split.c;
            var cut = (split.max + split.min) >> 1;
            console.log("Splitting " + ["red", "green", "blue"][c] + " at " + cut);
            console.log(rgb);

            var left = [];
            var right = [];
            for (var i = 0; i < s.length; i++) {
                if (d[s[i] + c] < cut)
                    left.push(s[i]);
                else
                    right.push(s[i]);
            }
            return [left, right];
        }

        while (slices.length < centroid_count) {
            slices.sort((a, b) => b.length - a.length);
            var split = cut(slices.shift());
            slices = slices.concat(split);
        }
        console.log(slices);
        var pal = [];
        slices.forEach(s => {
            var r = 0;
            var g = 0;
            var b = 0;
            s.forEach(i => {
                r += d[i];
                g += d[i + 1];
                b += d[i + 2];
            });
            pal.push(rgb2atari(r / s.length, g / s.length, b / s.length));
        });
        return pal;
    }

    //===================================================================================================
    //  Kmeans for palettes

    function kmeans(pix, centroid_count, gray) {
        console.log("kmeans " + centroid_count + (gray ? "(grayscale)" : ""));
        var sample_count = pix.width * pix.height;
        var samples = [];
        for (var i = 0; i < sample_count; i++)
            samples.push(rgb2yiq(pix.data[i * 4 + 0], pix.data[i * 4 + 1], pix.data[i * 4 + 2]));

        // kmeans++ centroid init
        _lfsr = 0xACE1;
        var rands = () => samples[lfsr() % sample_count];
        var centroids = [{ color: rands(), avg: { y: 0, i: 0, q: 0 }, err: 0, count: 0 }];
        while (centroids.length < centroid_count) {
            var maxe = 0;
            var new_centroid;
            for (var i = 0; i < 100; i++) {
                var s = rands();
                centroids.forEach(c => {
                    var e = yiq_distance(s, c.color);
                    if (e > maxe) {
                        maxe = e;
                        new_centroid = s;
                    }
                });
            }
            centroids.push({ color: new_centroid, avg: { y: 0, i: 0, q: 0 }, err: 0, count: 0 });
        }

        // match samples to centroids
        var last = 0;
        for (var pass = 0; pass < 16; pass++) {

            // match all the samples
            var total_err = 0;
            for (var i = 0; i < sample_count; i++) {
                var mine = 0x7FFFFFF;
                var index = -1;
                var color = samples[i];
                for (var j = 0; j < centroid_count; j++) {
                    var e = yiq_distance(color, centroids[j].color);
                    if (e < mine) {
                        mine = e;
                        index = j;
                    }
                }
                var c = centroids[index];
                c.avg.y += color.y;
                c.avg.i += color.i;
                c.avg.q += color.q;
                c.count++;
                c.err += mine;     // accumulate error
                total_err += mine;
            }

            // recalculate centroid color
            var errs = [];
            for (var i = 0; i < centroid_count; i++) {
                var c = centroids[i];
                if (gray)
                    c.avg.i = c.avg.q = 0;
                if (c.count)
                    c.color = { y: c.avg.y / c.count, i: c.avg.i / c.count, q: c.avg.q / c.count };
                errs.push({ index: i, err: c.err });
            }

            errs.sort((a, b) => b.err - a.err);
            console.log(errs);
            console.log(centroids);

            // split centroids if required
            for (var i = 0; i < centroid_count; i++) {
                if (centroids[i].count == 0) {                              // centroid is not being used
                    var c0 = centroids[errs[0].index].color;
                    var c1 = centroids[errs[1].index].color;                // make new centroid at average of two biggest errors
                    centroids[i].color = { y: (c0.y + c1.y) / 2, i: (c0.i + c1.i) / 2, q: (c0.q + c1.q) / 2 };
                }
                // reset centroids
                centroids[i].count = centroids[i].err = 0;
                centroids[i].avg = { y: 0, i: 0, q: 0 };
            }

            console.log("pass: " + pass + ":" + total_err);
            if (last && total_err >= last)
                break;
            last = total_err;
        }

        var pal = [];
        for (var i = 0; i < centroid_count; i++) {
            var c = centroids[i].color;
            pal.push(yiq2atari(c.y, c.i, c.q));
        }
        console.log(pal);
        return pal;
    }

    // 888 rgb to atari
    function to_atari(rgb) {
        var mine = 0x7FFFFFF;
        var mini = -1;
        for (var i = 0; i < 256; i++) {
            var a = atari_palette_rgb[i];
            var r = ((rgb >> 16) & 0xFF) - ((a >> 16) & 0xFF);
            var g = ((rgb >> 8) & 0xFF) - ((a >> 8) & 0xFF);
            var b = (rgb & 0xFF) - (a & 0xFF);
            var e = r * r + g * g + b * b;
            if (e < mine) {
                mine = e;
                mini = i;
            }
        }
        return mini;
    }

    //===================================================================================================
    // Images

    var atari_palette_rgb = [
        0x00000000, 0x000F0F0F, 0x001B1B1B, 0x00272727, 0x00333333, 0x00414141, 0x004F4F4F, 0x005E5E5E,
        0x00686868, 0x00787878, 0x00898989, 0x009A9A9A, 0x00ABABAB, 0x00BFBFBF, 0x00D3D3D3, 0x00EAEAEA,
        0x00001600, 0x000F2100, 0x001A2D00, 0x00273900, 0x00334500, 0x00405300, 0x004F6100, 0x005D7000,
        0x00687A00, 0x00778A17, 0x00899B29, 0x009AAC3B, 0x00ABBD4C, 0x00BED160, 0x00D2E574, 0x00E9FC8B,
        0x001C0000, 0x00271300, 0x00331F00, 0x003F2B00, 0x004B3700, 0x00594500, 0x00675300, 0x00756100,
        0x00806C12, 0x008F7C22, 0x00A18D34, 0x00B29E45, 0x00C3AF56, 0x00D6C36A, 0x00EAD77E, 0x00FFEE96,
        0x002F0000, 0x003A0000, 0x00460F00, 0x00521C00, 0x005E2800, 0x006C3600, 0x007A4416, 0x00885224,
        0x00925D2F, 0x00A26D3F, 0x00B37E50, 0x00C48F62, 0x00D6A073, 0x00E9B487, 0x00FDC89B, 0x00FFDFB2,
        0x00390000, 0x00440000, 0x0050000A, 0x005C0F17, 0x00681B23, 0x00752931, 0x0084373F, 0x0092464E,
        0x009C5058, 0x00AC6068, 0x00BD7179, 0x00CE838A, 0x00DF949C, 0x00F2A7AF, 0x00FFBBC3, 0x00FFD2DA,
        0x00370020, 0x0043002C, 0x004E0037, 0x005A0044, 0x00661350, 0x0074215D, 0x0082306C, 0x00903E7A,
        0x009B4984, 0x00AA5994, 0x00BC6AA5, 0x00CD7BB6, 0x00DE8CC7, 0x00F1A0DB, 0x00FFB4EF, 0x00FFCBFF,
        0x002B0047, 0x00360052, 0x0042005E, 0x004E006A, 0x005A1276, 0x00672083, 0x00762F92, 0x00843DA0,
        0x008E48AA, 0x009E58BA, 0x00AF69CB, 0x00C07ADC, 0x00D18CED, 0x00E59FFF, 0x00F9B3FF, 0x00FFCAFF,
        0x0016005F, 0x0021006A, 0x002D0076, 0x00390C82, 0x0045198D, 0x0053279B, 0x006135A9, 0x006F44B7,
        0x007A4EC2, 0x008A5ED1, 0x009B6FE2, 0x00AC81F3, 0x00BD92FF, 0x00D0A5FF, 0x00E4B9FF, 0x00FBD0FF,
        0x00000063, 0x0000006F, 0x00140C7A, 0x00201886, 0x002C2592, 0x003A329F, 0x004841AE, 0x00574FBC,
        0x00615AC6, 0x00716AD6, 0x00827BE7, 0x00948CF8, 0x00A59DFF, 0x00B8B1FF, 0x00CCC5FF, 0x00E3DCFF,
        0x00000054, 0x00000F5F, 0x00001B6A, 0x00002776, 0x00153382, 0x00234190, 0x0031509E, 0x00405EAC,
        0x004A68B6, 0x005A78C6, 0x006B89D7, 0x007D9BE8, 0x008EACF9, 0x00A1BFFF, 0x00B5D3FF, 0x00CCEAFF,
        0x00001332, 0x00001E3E, 0x00002A49, 0x00003655, 0x00004261, 0x0012506F, 0x00205E7D, 0x002F6D8B,
        0x00397796, 0x004987A6, 0x005B98B7, 0x006CA9C8, 0x007DBAD9, 0x0091CEEC, 0x00A5E2FF, 0x00BCF9FF,
        0x00001F00, 0x00002A12, 0x0000351E, 0x0000422A, 0x00004E36, 0x000B5B44, 0x00196A53, 0x00287861,
        0x0033826B, 0x0043927B, 0x0054A38C, 0x0065B49E, 0x0077C6AF, 0x008AD9C2, 0x009EEDD6, 0x00B5FFED,
        0x00002400, 0x00003000, 0x00003B00, 0x00004700, 0x0000530A, 0x00106118, 0x001E6F27, 0x002D7E35,
        0x00378840, 0x00479850, 0x0059A961, 0x006ABA72, 0x007BCB84, 0x008FDE97, 0x00A3F2AB, 0x00BAFFC2,
        0x00002300, 0x00002F00, 0x00003A00, 0x00004600, 0x00115200, 0x001F6000, 0x002E6E00, 0x003C7C12,
        0x0047871C, 0x0057972D, 0x0068A83E, 0x0079B94F, 0x008ACA61, 0x009EDD74, 0x00B2F189, 0x00C9FFA0,
        0x00001B00, 0x00002700, 0x000F3200, 0x001C3E00, 0x00284A00, 0x00365800, 0x00446600, 0x00527500,
        0x005D7F00, 0x006D8F19, 0x007EA02B, 0x008FB13D, 0x00A0C24E, 0x00B4D662, 0x00C8EA76, 0x00DFFF8D,
        0x00110E00, 0x001D1A00, 0x00292500, 0x00353100, 0x00413D00, 0x004F4B00, 0x005D5A00, 0x006B6800,
        0x0076720B, 0x0085821B, 0x0097932D, 0x00A8A43E, 0x00B9B650, 0x00CCC963, 0x00E0DD77, 0x00F7F48F,
    ];

    function rgb2yiq(r, g, b) {
        return {
            y: r * 0.299 + g * 0.587 + b * 0.114,
            i: r * 0.596 - g * 0.275 - b * 0.321,
            q: r * 0.212 - g * 0.523 + b * 0.311
        }
    }

    function rgb2atari(r, g, b) {
        var yiq = rgb2yiq(r, g, b);
        var angle = Math.atan2(yiq.i, yiq.q);
        var saturation = yiq.i * yiq.i + yiq.q * yiq.q;
        var offset = (180 - 26.8) * Math.PI / 180.0;
        var scale = 360 / 26.8;
        var cr = (offset - angle) * scale / (2 * Math.PI) | 0;
        cr %= 15;
        if (saturation < 1)
            cr = 0;
        else
            cr++;
        return (cr << 4) | (yiq.y / 16 | 0);
    }

    function atari2yiq(a) {
        var cr = a >> 4;
        var i = 0;
        var q = 0;
        if (cr) {
            var color_diff = 2 * Math.PI * 26.8 / 360;
            var angle = Math.PI * 303 / 180 + (cr - 1) * color_diff;
            i = Math.cos(angle) * 63;
            q = Math.sin(angle) * 63;
        }
        return { y: (a & 0xF) * 16, i: i, q: q };
    }

    function yiq2atari(y, i, q) {
        var angle = Math.atan2(i, q);
        var saturation = i * i + q * q;
        var offset = (180 - 26.8) * Math.PI / 180.0 - angle;
        if (offset < 0)
            offset += 2 * Math.PI;
        var scale = 360 / 26.8;
        var cr = offset * scale / (2 * Math.PI);
        cr = (cr + 0.5) | 0;
        if (saturation < 256)
            cr = 0;
        else
            cr = (cr + 1) & 0xF;
        cr = (cr << 4) | ((y / 16) | 0);
        console.log("y:" + y + " i:" + i + " q:" + q + " -> " + hex(cr) + " sat:" + saturation);
        return cr;
    }

    function yiq_distance(a, b) {
        var dy = a.y - b.y;
        var di = a.i - b.i;
        var dq = a.q - b.q;
        return dy * dy + di * di + dq * dq;
    }

    // 
    var _lfsr = 0xACE1;
    function lfsr() {
        _lfsr ^= _lfsr >> 7;
        _lfsr ^= _lfsr << 9;
        _lfsr ^= _lfsr >> 13;
        return _lfsr;
    }

    // mode 0 = Atkinson Dither
    // mode 1 = Floyd Steinberg
    // mode 2 = noise
    // mode 3 = ordered
    // mode 4 = No diffusion

    var _ordered8x8 = new Uint8Array([
        0, 32, 8, 40, 2, 34, 10, 42,
        48, 16, 56, 24, 50, 18, 58, 26,
        12, 44, 4, 36, 14, 46, 6, 38,
        60, 28, 52, 20, 62, 30, 54, 22,
        3, 35, 11, 43, 1, 33, 9, 41,
        51, 19, 59, 27, 49, 17, 57, 25,
        15, 47, 7, 39, 13, 45, 5, 37,
        63, 31, 55, 23, 61, 29, 53, 21
    ]);

    var _ordered16x16 = new Uint8Array([
        0, 192, 48, 240, 12, 204, 60, 252, 3, 195, 51, 243, 15, 207, 63, 255,
        128, 64, 176, 112, 140, 76, 188, 124, 131, 67, 179, 115, 143, 79, 191, 127,
        32, 224, 16, 208, 44, 236, 28, 220, 35, 227, 19, 211, 47, 239, 31, 223,
        160, 96, 144, 80, 172, 108, 156, 92, 163, 99, 147, 83, 175, 111, 159, 95,
        8, 200, 56, 248, 4, 196, 52, 244, 11, 203, 59, 251, 7, 199, 55, 247,
        136, 72, 184, 120, 132, 68, 180, 116, 139, 75, 187, 123, 135, 71, 183, 119,
        40, 232, 24, 216, 36, 228, 20, 212, 43, 235, 27, 219, 39, 231, 23, 215,
        168, 104, 152, 88, 164, 100, 148, 84, 171, 107, 155, 91, 167, 103, 151, 87,
        2, 194, 50, 242, 14, 206, 62, 254, 1, 193, 49, 241, 13, 205, 61, 253,
        130, 66, 178, 114, 142, 78, 190, 126, 129, 65, 177, 113, 141, 77, 189, 125,
        34, 226, 18, 210, 46, 238, 30, 222, 33, 225, 17, 209, 45, 237, 29, 221,
        162, 98, 146, 82, 174, 110, 158, 94, 161, 97, 145, 81, 173, 109, 157, 93,
        10, 202, 58, 250, 6, 198, 54, 246, 9, 201, 57, 249, 5, 197, 53, 245,
        138, 74, 186, 122, 134, 70, 182, 118, 137, 73, 185, 121, 133, 69, 181, 117,
        42, 234, 26, 218, 38, 230, 22, 214, 41, 233, 25, 217, 37, 229, 21, 213,
        170, 106, 154, 90, 166, 102, 150, 86, 169, 105, 153, 89, 165, 101, 149, 85
    ]);

    function dither_image(pix, pal, mode) {
        mode = mode || 0;
        var d = pix.data;
        var buf = new Uint8Array(3);
        var errs = new Int16Array(3);
        var dst = new Uint8Array(pix.width * pix.height);
        var distance = _radios["distance"].value;
        var dscale = pal.length == 2 ? 0.75 : 0.25;

        function get_index(src, p) {
            var mind = -1;
            var merr = 0xFFFFFF;

            if (distance == 0)  // RGB distnance measure
            {
                var r = src[p + 0];
                var g = src[p + 1];
                var b = src[p + 2];
                var e;
                for (var i = 0; i < pal.length; i++) {
                    var err = 0;
                    var c = atari_palette_rgb[pal[i]];
                    e = r - ((c >> 16) & 0xFF);
                    err += e * e;
                    e = g - ((c >> 8) & 0xFF);
                    err += e * e;
                    e = b - (c & 0xFF);
                    err += e * e;
                    if (err < merr) {
                        merr = err;
                        mind = i;
                    }
                }
            } else {
                var pyiq = rgb2yiq(src[p + 0], src[p + 1], src[p + 2]);  // yiq + y only
                var e;
                for (var i = 0; i < pal.length; i++) {
                    var err = 0;
                    var yiq = atari2yiq(pal[i]);
                    e = yiq.y - pyiq.y;
                    err += e * e * 2;
                    if (distance == 1) {        // include chroma
                        e = yiq.i - pyiq.i;
                        err += e * e;
                        e = yiq.q - pyiq.q;
                        err += e * e;
                    }
                    if (err < merr) {
                        merr = err;
                        mind = i;
                    }
                }
            }

            var c = atari_palette_rgb[pal[mind]];
            errs[0] = (src[p + 0] - ((c >> 16) & 0xFF));   // save error in RGB
            errs[1] = (src[p + 1] - ((c >> 8) & 0xFF));
            errs[2] = (src[p + 2] - ((c >> 0) & 0xFF));
            return pal[mind];    // closest index
        }

        function pin(n) {
            if (n < 0) return 0;
            if (n > 255) return 255;
            return n;
        }

        function rnd() {
            return ((lfsr() & 0xFF) - 128) * dscale;
        }

        function noisy(i) {
            buf[0] = pin(d[i + 0] + rnd());
            buf[1] = pin(d[i + 1] + rnd());
            buf[2] = pin(d[i + 2] + rnd());
        }

        function ordered(i, x, y) {
            var n = ((x & 0xF) << 4) | (y & 0xF);
            n = (_ordered16x16[n] - 128) * dscale;
            buf[0] = pin(d[i + 0] + n);
            buf[1] = pin(d[i + 1] + n);
            buf[2] = pin(d[i + 2] + n);
        }

        function add_err(x, y, scale) {
            scale = scale || 1 / 6;   // Atkinson
            if (x < 0 || x >= pix.width || y < 0 || y >= pix.height)
                return;
            var i = (x + y * pix.width) * 4;
            d[i + 0] = pin(d[i + 0] + errs[0] * scale);
            d[i + 1] = pin(d[i + 1] + errs[1] * scale);
            d[i + 2] = pin(d[i + 2] + errs[2] * scale);
        }

        var i = 0;
        var row = 0;
        for (var y = 0; y < pix.height; y++) {
            for (var x = 0; x < pix.width; x++) {
                switch (mode) {
                    case 0:
                        dst[i++] = get_index(d, row + x * 4);    // Atkinson
                        add_err(x + 1, y + 0);
                        add_err(x + 2, y + 0);
                        add_err(x - 1, y + 1);
                        add_err(x + 0, y + 1);
                        add_err(x + 1, y + 1);
                        add_err(x + 0, y + 2);
                        break;

                    case 1:
                        dst[i++] = get_index(d, row + x * 4);    // Floyd Steinberg
                        add_err(x + 1, y + 0, 7 / 16);
                        add_err(x - 1, y + 1, 3 / 16);
                        add_err(x + 0, y + 1, 5 / 16);
                        add_err(x + 1, y + 1, 1 / 16);
                        break;

                    case 2:
                        noisy(row + x * 4);
                        dst[i++] = get_index(buf, 0);
                        break;

                    case 3: // ordered
                        ordered(row + x * 4, x, y);
                        dst[i++] = get_index(buf, 0);
                        break;

                    case 4: // none
                        dst[i++] = get_index(d, row + x * 4);
                        break;
                }
            }
            row += pix.width * 4;
        }
        return dst;
    }

    function pack_img(indexes, pal, ext) {
        var dst = 0;
        var bpp = 2;
        switch (ext) {
            case 'gr8':
                bpp = 1;
                break;
            case 'gr9':
            case 'g10':
                bpp = 4;
                break;
        }
        var ppb = 8 / bpp;
        var pal_len = pal ? pal.length : 0;
        var d = new Uint8Array(indexes.length / ppb + pal_len);

        for (var i = 0; i < indexes.length;) {
            var b = 0;
            for (var j = 0; j < ppb; j++) {
                b <<= bpp;
                if (pal_len)
                    b |= pal.indexOf(indexes[i++]);
                else
                    b |= indexes[i++];
            }
            d[dst++] = b;
        }
        for (var i = 0; i < pal_len; i++)
            d[dst++] = pal[i];
        return d;
    }

    function raw_rgb(pix) {
        var n = pix.width * pix.height;
        var d = new Uint8Array(n * 3);
        if (1) {
            var pal = [];
            for (var i = 0; i < 256; i++)
                pal.push(i);
            var indexed = dither_image(pix, pal, 1);
            for (var i = 0; i < n; i++) {
                var c = atari_palette_rgb[indexed[i]];  // 
                d[i * 3 + 0] = (c >> 16) & 0xFF;
                d[i * 3 + 1] = (c >> 8) & 0xFF;
                d[i * 3 + 2] = c & 0xFF;
            }
        } else {
            for (var i = 0; i < n; i++) {
                d[i * 3 + 0] = pix.data[i * 4 + 0];
                d[i * 3 + 1] = pix.data[i * 4 + 1];
                d[i * 3 + 2] = pix.data[i * 4 + 2];
            }
        }
        return d;
    }

    // raw rgb
    function show_rgb(canvas, f) {
        canvas.width = f.data.length == (320 * 192 * 3) ? 320 : 160;
        canvas.height = 192;
        var ctx = canvas.getContext('2d');
        var pix = ctx.getImageData(0, 0, canvas.width, canvas.height);
        var d = pix.data;
        var s = f.data;
        var n = canvas.width * canvas.height;
        var p = {};
        for (var i = 0; i < n; i++) {
            var r = d[i * 4 + 0] = s[i * 3 + 0];
            var g = d[i * 4 + 1] = s[i * 3 + 1];
            var b = d[i * 4 + 2] = s[i * 3 + 2];
            d[i * 4 + 3] = 0xFF;
            p[(r << 16) | (g << 8) | b] = 1;
        }
        var pal = [];
        Object.keys(p).forEach(c => pal.push(rgb2atari((c >> 16) | 0xFF, (c >> 8) & 0xFF, c & 0xFF)));
        ctx.putImageData(pix, 0, 0);
        return { pal: pal, aspect: [320 / canvas.width * 2, 192 / canvas.height * 2] };
    }

    var _mono_cr = 0;
    function convert_image(canvas, f, pal, reload) {
        //if (f.name.indexOf(".rgb") != -1)
            //return show_rgb(canvas,f);

        var dither = _radios["dither"].value;
        var scheme = _radios["scheme"].value;

        var width = 320;
        var height = 192;

        var img = f.imgTag;
        var src_width = img.width;
        var src_height = img.height;
        var dst_width, dst_height;
        var ratio = img.width / img.height;
        if (ratio > width / height) {
            dst_width = width;
            dst_height = width / ratio;    // wide
        } else {
            dst_height = height;
            dst_width = height * ratio;    // tall
        }

        // 80,160 or 320 wide
        var pal_size = 0;
        switch (f.ext) {
            case "gr7":
                width /= 2;
                if (src_width == 160 && src_height == 192) {
                    // already native size
                } else {
                    dst_width /= 2;
                }
                pal_size = 4;
                break;
            case "gr8":
                pal_size = 2;
                break;
            case "gr9":
                pal = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];
            case "g10":
                width /= 4;
                if (src_width == 80 && src_height == 192) {
                    // already native size
                } else {
                    dst_width /= 4;
                }
                pal_size = f.ext == 'g10' ? 9 : 0;
                break;
        }

        canvas.width = width;
        canvas.height = height;
        var ctx = canvas.getContext('2d');
        ctx.fillRect(0, 0, width, height);
        ctx.drawImage(f.imgTag, 0, 0, img.width, src_height, (width - dst_width) / 2, (height - dst_height) / 2, dst_width, dst_height);

        var pix = ctx.getImageData(0, 0, width, height);
        //f.rgb = raw_rgb(pix);

        var mono = -1;
        if (reload && pal_size) {
            function monochrome(c) {
                for (var i = 0; i < pal_size; i++)  // make a grey palette, will apply chroma later
                    pal[i] = (i * 15 / (pal_size - 1)) | (_mono_cr << 4);
                mono = c;
            }
            switch (scheme) {
                case 0:
                    monochrome(0x00);   // grey
                    break;
                case 1:     // red-green
                    switch (pal_size) {
                        case 2: pal = [0x45, 0xE9]; break;
                        case 4: pal = [0x71, 0x45, 0xE9, 0x0D]; break; // Technicolor 100
                        case 9: pal = [0x71, 0x45, 0xE9, 0x47, 0xE7, 0x07, 0x49, 0xE5, 0x0D]; break; // Technicolor 100
                            break;
                    }
                    break;
                case 2:      // random
                    for (var i = 0; i < pal.length; i++)
                        pal[i] = lfsr() & 0xFF;
                    break;

                case 3: // kmeans
                    pal = kmeans(pix, pal_size);
                    break;

                case 4: // octree
                    pal = octree(pix, pal_size);
                    break;

                case 5:
                    pal = median_cut(pix, pal_size);
                    break;
            }
        }

        // dither to atari palette
        var indexed = dither_image(pix, pal, dither);

        // apply mono color if any
        if (mono != -1) {
            for (var i = 0; i < pal.length; i++)
                pal[i] |= mono;
            for (var i = 0; i < indexed.length; i++)
                indexed[i] |= mono;
        }

        // pack into the appropriate format
        f.packed_img = pack_img(indexed, pal_size ? pal : null, f.ext);

        // turn it back into RGB to display
        var rgb = Uint32Array.from(indexed).map(i => atari_palette_rgb[i]);
        rgb2canvas(canvas, rgb, width, height, 1);
        return { pal: pal, aspect: [320 / canvas.width * 2, 192 / canvas.height * 2] };
    }

    // atari index color to canvas
    // may stretch horizontally to maintain aspect ratio
    function rgb2canvas(canvas, atari, width, height, aspect, brightness) {
        brightness = brightness || 1;
        canvas.width = width * aspect;
        canvas.height = height;
        var ctx = canvas.getContext('2d');
        var pix = ctx.getImageData(0, 0, width * aspect, height);
        var d = pix.data;
        var src = 0;
        var i = 0;
        var pin = (p) => Math.min(0xFF, (p & 0xFF) * brightness);
        for (var y = 0; y < height; y++) {
            for (var x = 0; x < width; x++) {
                var c = atari[src++];
                for (var j = 0; j < aspect; j++) {
                    d[i + 0] = pin(c >> 16);
                    d[i + 1] = pin(c >> 8);
                    d[i + 2] = pin(c);
                    d[i + 3] = 0xFF;
                    i += 4;
                }
            }
        }
        ctx.putImageData(pix, 0, 0);
    }

    // convert a koala into a mic
    function koala(src) {
        var dst = new Uint8Array(7684);
        var dst_len = 7680;
        var i = src[4] + 1;
        var j = 0;
        var end = src.length;
        var type = src[7];

        if (type == 0) {
            while (i < end)
                dst[j++] = src[i++];  // no compression
        } else {
            while (i < end) {
                var b = src[i++];
                var len = b & 0x7F;
                if (len == 0) {
                    len = src[i++] << 8;
                    len |= src[i++];
                }
                b = (b & 0x80) ? -1 : src[i++];

                do {
                    dst[j] = b < 0 ? src[i++] : b;
                    if (j == (dst_len - 1))
                        break;
                    if (type == 2)
                        j++;
                    else {
                        j += 80;
                        if (j >= dst_len)
                            j -= (j < dst_len + 40) ? dst_len - 40 : dst_len + 39;
                    }
                } while (--len > 0);
            }
        }

        dst[7680] = src[17];
        dst[7681] = src[13];
        dst[7682] = src[14];
        dst[7683] = src[15];
        return dst;
    }

    // unpack from Piotr Fusik and Adrian Matoga

    function unpack_rip(data, data_len, unpacked_data, unpacked_len) {
        function create_fano_tree(src, offset, n, tree) {
            var i;
            var pos = 0;
            var positions = new Int32Array(16);
            for (i = 0; i < 16; i++)
                tree.count[i] = 0;
            for (i = 0; i < n; i++) {
                var bits = src[(i >> 1) + offset];
                bits = (i & 1) == 0 ? bits >> 4 : bits & 0xf;
                tree.count[bits]++;
            }
            for (i = 0; i < 16; i++) {
                positions[i] = pos;
                pos += tree.count[i];
            }
            for (i = 0; i < n; i++) {
                var bits = src[(i >> 1) + offset];
                bits = (i & 1) == 0 ? bits >> 4 : bits & 0xf;
                tree.values[positions[bits]++] = i & 0xFF;
            }
        }

        function get_bit(s) {
            var bits = s.bits;
            if (bits == 0x80) {
                if (s.offset >= s.length)
                    return -1;
                bits = s.bytes[s.offset++] * 2 + 1;
            }
            else
                bits <<= 1;
            s.bits = bits & 0xFF;
            return bits >> 8;
        }

        function get_code(s, tree) {
            var p = tree.count[0];
            var i = 0;
            var bits;
            for (bits = 1; bits < 16; bits++) {
                var n = tree.count[bits];
                var bit = get_bit(s);
                if (bit == -1)
                    return -1;
                i = i * 2 + bit;
                if (i < n)
                    return tree.values[p + i];
                p += n;
                i -= n;
            }
            return -1;
        }

        var length_tree = { count: new Int32Array(16), values: new Uint8Array(256) };
        var distance_tree = { count: new Int32Array(16), values: new Uint8Array(256) };
        var literal_tree = { count: new Int32Array(16), values: new Uint8Array(256) };
        var stream = { bits: 0x80, bytes: data, length: data_len, offset: 16 + 288 };
        var unpacked_offset;

        /* "PCK" header (16 bytes) */
        if (data_len < 304 || data[0] != 80 || data[1] != 67 || data[2] != 75)  // PCK
            return 0;

        /* 288 bytes Shannon-Fano bit lengths */
        create_fano_tree(data, 16, 64, length_tree);
        create_fano_tree(data, 16 + 32, 256, distance_tree);
        create_fano_tree(data, 16 + 32 + 128, 256, literal_tree);

        /* LZ77 */
        for (unpacked_offset = 0; unpacked_offset < unpacked_len;) {
            switch (get_bit(stream)) {
                case -1:
                    console.log(`rip truncation: got ${unpacked_offset} of ${unpacked_len}`);
                    return 0;
                case 0:
                    unpacked_data[unpacked_offset++] = get_code(stream, literal_tree);
                    break;
                case 1:
                    {
                        var distance = get_code(stream, distance_tree) + 2;
                        var len;
                        if (distance > unpacked_offset)
                            return 0;
                        len = get_code(stream, length_tree) + 2;
                        do {
                            unpacked_data[unpacked_offset] = unpacked_data[unpacked_offset - distance];
                            unpacked_offset++;
                        } while (--len > 0);
                        break;
                    }
            }
        }
        return 1;
    }

    function rip(d) {
        var mode = d[7];
        var hdr_len = d[11] + (d[12] << 8);
        var height = d[15];
        var txt_len = d[17];
        var pal_len = d[20 + txt_len];
        var dst;
        var txt = '';

        for (var i = 0; i < txt_len; i++)
            txt += String.fromCharCode(d[24 + i]);
        console.log(`rip mode:${mode}, rowbytes:${d[13]}, height:${d[15]} txt:${txt}`);

        if (d[9] == 0) {
            dst = d.slice(hdr_len, d.length);
        } else if (d[9] == 1) {
            var n = d[13];
            if (mode == 0x30)
                n += 4;  // 8 byte palette every 2nd line at end of image(s)
            n *= height;
            dst = new Uint8Array(n);
            var src = d.slice(hdr_len, d.length);
            if (!unpack_rip(src, src.length, dst, n))
                console.log("bad unpack_rip?");
        } else
            return null;

        // Copy palette
        var pal = new Uint8Array(pal_len);
        for (var i = 0; i < pal_len; i++)
            pal[i] = d[24 + txt_len + i];

        // separate mutlirip palette
        var multihip_pal = null;
        if (mode == 0x30) {
            var n = d[13] * height;
            multihip_pal = dst.slice(n, dst.length);
            dst = dst.slice(0, n);
        }
        // have the unpacked frame
        return {
            pal: pal,
            multihip_pal: multihip_pal,
            data: dst,
            ext: "rip_hip",
            mode: mode
        }
    }

    var _palette = [0, 5, 10, 15];
    var _reload_palette = 0; //(PVB MOD) force to 0 ///WIP// is correction OK ?
    var _palettable = ["gr7", "gr8", "g10", "mic", "mcp", "inp", "cin", "pic", "scr"]; //(PVB COM) list of palettable image type
    function is_palettable(ext) {
        return _palettable.indexOf(ext) != -1;
    }

    function render_image(canvas, f) {
        var def_palette = [0, 5, 10, 15];
        switch (f.ext) {
            case "gr8": def_palette = [0, 15]; break;
            case "g10": def_palette = [0, 2, 4, 6, 8, 10, 12, 14, 15]; break;
        }
        var pal0 = _reload_palette ? def_palette.slice() : _palette.slice();
        var pal1 = _reload_palette ? def_palette.slice() : _palette.slice();
        var hip = [0, 0, 2, 4, 6, 8, 10, 12, 14, 0x20, 0x40, 0x60, 0x80, 0xA0, 0xC0, 0xE0];
        var multihip_pal = null;

        // We are rendering an image
        //  if (f.img || (f.name.indexOf(".rgb") != -1)) {
        if (f.imgTag) {
            var r = convert_image(canvas, f, pal0, _reload_palette);
            if (_reload_palette) {
                _palette = r.pal.slice();
                redraw_palette();
            }
            return r.aspect;
        }

        var data = f.data;
        var ext = f.ext;
        var height = 192;
        var width = 160;
        var offset = 40;
        var offset2 = 40;
        var gr = 7;
        var src = 0;

        // Turn PIC into MIC
        if (ext == "pic") {
            data = koala(data);
            ext = "mic";
        }

        // Turn RIP into something
        if (ext == "rip") {
            var r = rip(data);
            data = r.data;
            ext = r.ext;
            hip = r.pal;

            switch (r.mode) {
                case 14: ext = "rip_mode_14"; break;
                case 16: ext = "rip_mode_16"; break;
                case 30:
                    ext = "inp";
                    for (var i = 0; i < 4; i++)
                        pal0[i] = pal1[i] = hip[4 + ((i - 1) & 3)];
                    break;
                case 48:
                    ext = "rip_multirip";
                    multihip_pal = r.multihip_pal;
                    break;
            }
        }

        function set_pal(p, offset, len) {
            if (_reload_palette) {
                pal0.length = len;
                pal1.length = len;
                for (var i = 0; i < len; i++)
                    pal0[i] = pal1[i] = p[offset++];
                _palette = pal0.slice();
                redraw_palette();
            }
        }

        function avg(p0, p1) {
            return ((atari_palette_rgb[p0] & 0x00FEFEFE) + (atari_palette_rgb[p1] & 0x00FEFEFE)) >> 1;
        }

        // Atari Graphics Works?
        if (ext == "scr" && data.length == 16000) {
            data = data.slice(0, 7684);
            ext = "gr7";
        }

        switch (data.length) {
            case 3844:
            case 7684:
            case 9604:
            case 16004: // Interpainter
                set_pal(data, data.length - 4, 4);
                break;

            case 7682:
                set_pal(data, data.length - 2, 2);
                break;

            case 7689:
                set_pal(data, data.length - 9, 9);
                break;
        }

        switch (ext) {
            case "mic": //mic & pic (above converted to mic)
            case "gr7":
                height = 96;
                if (data.length >= 7680)
                    height = 192;
                break;

            case "gr8":
                width = 320;
                gr = 8;
                if (data.length == 7680)
                    set_pal([0, 0xF], 0, 2);
                break;

            case "gr9":
                width = 80;
                gr = 9;
                break;

            case "g10":
                width = 80;
                gr = 10;
                break;

            case "ilc":
            case "pzm":
                width = 80;
                offset = 40 * 192;
                gr = 33;
                break;

            case "plm":
            case "apc":
                width = 80;
                height = 96;
                gr = 32;
                break;

            case "mcp":
                height = data.length == 16008 ? 200 : 100;
                for (var i = 0; i < 4; i++) {
                    pal0[i] = data[height * 80 + ((i - 1) & 3)];
                    pal1[i] = data[height * 80 + 4 + ((i - 1) & 3)];
                }
                offset = height * 40;
                gr = 39;
                break;

            case "inp":
                height = 200;
                offset = height * 40;
                gr = 37;
                break;

            // switch between Graphics 11 and Graphics 15
            // https://en.wikipedia-on-ipfs.org/wiki/Atari_8-bit_family_software-driven_graphics_modes.html
            case "cin":
                offset = 80 * height / 2;
                gr = 34;
                break;

            case "raw":
                src += 4;       // skip header 'XLPB'
                for (var i = 0; i < 4; i++) {
                    pal0[i] = data[0x3C04 + ((i - 1) & 3)];
                    pal1[i] = data[0x3C08 + ((i - 1) & 3)];
                }
                height = 192;
                gr = 37;
                break;

            case "ist":
                height = 200;
                src = 16;
                offset = 0x2000;
                gr = 35;
                break;

            case "hip":
                // 10 and 9 greyscale
                gr = 36;
                var hdr = le16(data, 0); // FFFF
                if (hdr == 0xFFFF && data.length != 16009) {    // Has header: Frames have explicit length
                    var len0 = le16(data, 4) - le16(data, 2) + 1;
                    var len1 = le16(data, 4 + len0 + 6) - le16(data, 2 + len0 + 6) + 1;
                    src += 6;
                    offset = len0 + 6;
                    height = len0 / 40;
                } else {
                    height = data.length / 80 | 0;
                    src = height * 40;
                    offset = -height * 40;
                    var p = height * 80;
                    if ((p + 9) == data.length) {   // has a palette?
                        for (var i = 0; i < 9; i++)
                            hip[i] = data[p++];
                    }
                }
                break;

            case "tip":
                width = data[5];
                height = data[6];
                var frame_len = data[7] | (data[8] << 8);
                // 3 frames: gr9 luma, gr10 luma, gr11 chroma
                src += 9;                   // gr9 luma
                offset = frame_len;         // gr10 luma
                offset2 = frame_len * 2;      // chroma
                gr = 38;
                break;

            case "rip_hip":
            case "rip_multirip":
                height = data.length / 80;
                offset = height * 40;
                gr = 36;
                break;

            case "rip_mode_14":
                height = 192;
                for (var i = 0; i < 4; i++) {
                    pal0[i] = pal1[i] = hip[4 + (i == 0 ? 4 : i - 1)] & 0xFE;
                    set_pal(pal0, 0, 4);
                }
                gr = 7;
                break;

            case "rip_mode_16":
                for (var i = 0; i < 4; i++) {
                    pal0[i] = hip[4 + i]; // TODO: why are they all dark?
                    pal1[i] = hip[0 + i] & 0xFE;
                }
                height = data.length / 80;
                offset = data.length / 2;
                gr = 37;    //
                break;
        }

        var buf = new Uint32Array(width * height);
        var dst = 0;
        var lastp = 0;
        var ap = atari_palette_rgb;
        for (var y = 0; y < height; y++) {
            var pal = (y & 1) ? pal1 : pal0;

            if (gr == 35) { // ist palette
                pal0[0] = pal1[0] = data[0x4000 + y];
                pal0[1] = pal1[1] = data[0x40C8 + y];
                pal0[2] = pal1[2] = data[0x4190 + y];
                pal0[3] = pal1[3] = data[0x4258 + y];
            }

            if (multihip_pal) {
                for (var i = 0; i < 16; i++) {
                    var gr10_to_reg = [0, 1, 2, 3, 4, 5, 6, 7, 8, 8, 8, 8, 4, 5, 6, 7];
                    hip[i] = i == 0 ? 0 : multihip_pal[gr10_to_reg[i] + ((y >> 1) << 3) - 1] & 0xFE;
                }
            }

            for (var x = 0; x < width;) {
                var b = data[src];
                switch (gr) {
                    case 7:
                        for (var j = 0; j < 4; j++) {
                            var bb = (b >> 6) & 3;
                            buf[dst++] = ap[pal[bb]];
                            b <<= 2;
                        }
                        x += 4;
                        break;

                    case 8:
                        for (var j = 0; j < 8; j++) {
                            var bb = (b >> 7) & 1;
                            buf[dst++] = ap[pal[bb]];
                            b <<= 1;
                        }
                        x += 8;
                        break;

                    case 9:
                        buf[dst++] = ap[b >> 4];        // 9=16 greys,10=index,11=chroma
                        buf[dst++] = ap[b & 0x0F];
                        x += 2;
                        break;

                    case 10:
                        buf[dst++] = ap[pal[b >> 4]];
                        buf[dst++] = ap[pal[b & 0x0F]];
                        x += 2;
                        break;

                    case 32:
                        var luma = data[src + offset];
                        buf[dst++] = ap[((luma >> 4) & 0x0F) | (b & 0xF0)];
                        buf[dst++] = ap[(luma & 0xF) | ((b & 0xF) << 4)];
                        x += 2;
                        break;

                    case 33:
                        var hue = data[src + offset];
                        buf[dst++] = ap[((b >> 4) & 0x0F) | (hue & 0xF0)];
                        buf[dst++] = ap[(b & 0xF) | ((hue & 0xF) << 4)];
                        x += 2;
                        break;

                    case 34: // Champions
                        var hue = data[src + offset];
                        buf[dst++] = ap[pal[b >> 6] | (hue & 0xF0)];
                        buf[dst++] = ap[pal[(b >> 4) & 3] | (hue & 0xF0)];
                        buf[dst++] = ap[pal[(b >> 2) & 3] | ((hue & 0xF) << 4)];
                        buf[dst++] = ap[pal[b & 3] | ((hue & 0xF) << 4)];
                        x += 4;
                        break;

                    case 36:  // hip
                        //  00001111
                        //  LL222233
                        var p2 = hip[b >> 4];         // gr10
                        var p3 = hip[b & 0xF];
                        b = data[src + offset];
                        var p0 = b >> 4;                // gr9
                        var p1 = b & 0xF;

                        buf[dst++] = avg(p0, lastp);
                        buf[dst++] = avg(p0, p2);
                        buf[dst++] = avg(p1, p2);
                        buf[dst++] = avg(p1, p3);
                        lastp = p3;
                        x += 4;
                        break;// hip

                    case 35: // ist
                    case 37: // rip_mode_16/inp
                        var b2 = data[src + offset];
                        var pal_0 = (y & 1) ? pal1 : pal0;
                        var pal_1 = (y & 1) ? pal0 : pal1;
                        for (var j = 0; j < 4; j++) {
                            var p0 = pal_1[(b2 >> 6) & 3];
                            var p1 = pal_0[(b >> 6) & 3];
                            buf[dst++] = avg(p0, p1);
                            b <<= 2;
                            b2 <<= 2;
                        }
                        x += 4;
                        break;

                    case 39: // mcp
                        var b2 = data[src + offset];
                        for (var j = 0; j < 4; j++) {
                            var p0 = pal0[(b >> 6) & 3];
                            var p1 = pal1[(b2 >> 6) & 3];
                            buf[dst++] = avg(p0, p1);
                            b <<= 2;
                            b2 <<= 2;
                        }
                        x += 4;
                        break;

                    case 38: // tip!
                        var luma = data[src];
                        var luma10 = data[src + offset];
                        var chroma = data[src + offset2];          // chroma

                        var l0 = ((luma >> 4) + lastp) >> 1;
                        var l1 = ((luma >> 4) + hip[luma10 >> 4]) >> 1;
                        var l2 = ((luma & 0xF) + hip[luma10 >> 4]) >> 1;
                        lastp = hip[luma10 & 0xF];
                        var l3 = ((luma & 0xF) + lastp) >> 1;

                        var c0 = chroma & 0xF0;
                        var c1 = (chroma << 4) & 0xF0;

                        buf[dst++] = ap[c0 | l0];
                        buf[dst++] = ap[c0 | l1];
                        buf[dst++] = ap[c1 | l2];        // 9=16 greys,10=index,11=chroma
                        buf[dst++] = ap[c1 | l3];
                        x += 4;
                        break;
                }
                src++;
            }
            if (gr == 32 && offset == 40)
                src += 40;
        }

        var brightness = 1;
        switch (ext) {
            case "rip_mode_16": brightness = 3; break;    // rip_mode_16,raw is dark, boost it please
            case "raw":
            case "mcp":
                brightness = 2;
                break;
        }
        rgb2canvas(canvas, buf, width, height, 320 / width, brightness);
        return [320 / canvas.width * 2, 192 / canvas.height * 2];
    }

    //===================================================================================================
    // UI
    //===================================================================================================

    // make an atari line of text to look like dir

    function set_class(el, cname, on) { //(PVB COM) Add or remove a Class Property
    //(PVB COM) "el" is a class like "nav#toc"; cname is a class property like "over"
    // or for floater : "span#A" is a class; "dimmed" is a class property
    // when "on" is true, then class property is added, removed otherwise
        if (on)
            el.classList.add(cname);
        else
            el.classList.remove(cname);
    }

    function draw_line(id, txt, recovered, is_dir) {
        var c = _q(id);
        c.width = txt.length * 8;
        c.height = 8;
        var ctx = c.getContext('2d');
        draw(ctx, txt, 0, 0);
        resize_parent(c, 2);
        set_class(c, "recovered", recovered);
        set_class(c, "isdir", is_dir);
    }

    // Simple radio and check buttons
    var _radios = {};
    var _checks = {};
    function radio_init(name, values, value) {
        var cur = _radios[name] ? _radios[name].value : 0;
        value = value || cur;
        var s = '';
        for (var i = 0; i < values.length; i++)
            s += `<span onclick="radio_click('${name}',${i})" ${i == value ? "class='hilite'" : ""}>${values[i]}</span>`;
        _radios[name] = { values: values, value: value };
        return s;
    }

    function radio_click(name, n) {
        var v = _radios[name];
        if (n != -1 && n != v.value) {
            v.value = n;
            radio_changed(name, n);
        }
    }

    //function radio_changed(name, v) { //(PVB MOD) 'v' is not used
    function radio_changed(name) {
        switch (name) {
            case "atarichlist": //(PVB ADD) the radio button for selecting the font display
                _bShowWebChar = _radios["atarichlist"].value == 1;
                _bShowAtariFont = _radios["atarichlist"].value == 2;
            case "layout":
            case "dither":
            case "scheme":
            case "distance":
                refresh();
                break;
        }
    }

    function check_init(name, dname) {
        _checks[name] = _checks[name] | 0; //(PVB MOD) '||' previously
        var cur = _checks[name] ? _checks[name] : 0;
        return `<span id="${name}" onclick="check_click('${name}')" ${cur ? "class='hilite'" : ""}>${dname}</span>`; //(PVB ADD) add the name id
    }

    //function check_click(name, n) { //(PVB MOD) 'n' is not used
    function check_click(name) {
        _checks[name] ^= 1;
        check_changed(name, _checks[name]);
    }

    //function check_changed(name, v) { //(PVB MOD) 'v' is not used
    function check_changed(name, v) {
        switch (name) {
            case "indent":
            case "multicolor":
                refresh();
                break;
            //(PVB ADD) the radio check buttons for selecting the display options
            case "cShowA5200Eq":
                _bShowA5200Equates = _checks["cShowA5200Eq"]; //whatever was the value of _shown.a5200eq, we change the equate
                refresh();
                break;
            default: //we assume here that one clicks on a 'display option check' button, so we update the global _bShow flags
                _bShowDisLinks = _checks["cShowDisLinks"];
                _bShowAtasciiChar = _checks["cShowAtasciiChar"];
                _bShowDispChar = _checks["cShowDispChar"];
                _bShowDisFlags = _checks["cShowDisFlags"];
                _bShowDisBRK = _checks["cShowDisBRK"];
                _bShowROMBank = _checks["cShowROMBank"];
                refresh();
        }
    }

    function resize_parent(e, sx, sy) {
        sy = sy || sx;
        e.style.transform = `scale(${sx},${sy})`;
        e.parentNode.style.width = e.width * sx + "px";
        e.parentNode.style.height = e.height * sy + "px";
    }

    // U+200B ZERO-WIDTH SPACE after ':',',''
    function atari2ascii(lst, insert_breaks) { //called by show_ataritext() to convert atari char byte into relevant Atari ascii char for the editor()
        var r = [];
        var wbr = insert_breaks ? String.fromCharCode(0x200B) : null; // insert_breaks = insert ZERO-WIDTH SPACE for indentation
        lst.forEach(src => {
            var dst = '';
            for (var i = 0; i < src.length; i++) {
                var c = src.charCodeAt(i);
                switch (c) {
                    case 0x7B: // { in ascii, spade in atari
                    case 0x7D: // } in ascii, upleft in atari
                    case 0x7E: // ~ in ascii, left triangle in atari
                    case 0x7F: // right triangle in atari
                        c += 0xE000; //(PVB COM) U+E0xx is the specific Atari Chartset in the css embedded font style
                        break;
                    case 0x20: //(PVB ADD) 0x20 space char
                        //c = 0x00A0; // the 0x20 space char is set to "&nbsp;" (0xA0) which has correct witdth
                        c +=  0xE000; //or use de 0x20 from the ATARI Charset for correct space width display ?
                        break;
                    default:
                        if (c < 0x20 || c > 0x7E)   // keep printing chars whole 
                            c += 0xE000;
                }
                c = String.fromCharCode(c);
                dst += c;
                //(PVB COM) add the ZERO-WIDTH SPACE after punctuation mark
                if (wbr && (c == ':' || c == ',' || c == ';')) //(PVB ADD) the ";" semi-colon
                    dst += wbr;
            }
            r.push(dst);
        })
        return r;
    }
    //(PVB ADD) the ascii2print(lst) function to get the atari displayed text from the editor() and convert it to standard UTF-8 text file on OS Client (used by save() function)
    function ascii2print(lst) {
        var s = []; //main string
        lst.forEach(src => {
            for (var i = 0; i < src.length; i++) {
                var c = src.charCodeAt(i); //get the UTF-16 value for the char
                if (c == 0x200B) //keep the ZERO-WIDTH SPACE set by the indent button
                    c = String.fromCharCode(c);
                //else if (c == 0xA0) c = ' '; //if 0xA0 &nbsp is the large non-breaking space in the editor, convert it into a standard space
                //or do nothing in case of use of 0xE020 instead of "0xA0" &nbsp
                else //other char
                    c = escAtasciiChar(c & 0xFF); //cancel the +E0xx Atari font code value for a standard ascii char
                s.push(c); //push the char in main string
            }
            s.push('\n'); //add a line feed UTF char for each "lst" line
        });
        return s.join(''); //create and return a big UTF string of all the text
    }
    //(PVB MOD) the ascii2atari(lst) function to get the atari displayed text from the editor and convert it to a buffer of Atari bytes
    function ascii2atari(lst) { //used by function get_ataritext() to convert lst text (from editor()) into atari ascii ATASCII char code
        var d = []; //data buffer, for the Save as Atari LST file
        lst.forEach(src => { //"lst" is an array of strings (one string for each lines)
            for (var i = 0; i < src.length; i++) {
                c = src.charCodeAt(i); ////get the UTF-16 value for the char. Atari chars are at UTF+E000 to UTF+E0FF special page.
                if (c == 0x2009 || c == 0x00A0) c = 0x20; //editor() may use Thin Space (0x2009) and No-Break Space (NBSP) (0x00A0) so convert them to normal space (0x0020)
                if (c != 0x200B) //if ZERO WIDTH SPACE added in the editor() by the indent button, do nothing (don't add it in the data buffer)
                    d.push(c & 0xFF); //else push the Atari ascii code byte in the buffer (= remove 0xE0xx of UTF char code)
            }
            d.push(0x9B); //add the End-of-Line (RETURN)(EOL) 0x9B atari char for each "lst" line
        });
        return new Uint8Array(d); //return an array of bytes from all the text
    }

    function editor() {
        return _q("#atari_text");
    }

    function get_ataritext() { //used to get text from editor(), for saving purpose, in function save(as_lst)
        return ascii2atari(editor().innerText.split("\n"));
    }

    var _gs = window.getSelection || document.getSelection;
    function get_selection() {
        return _gs().toString();
    }

    function invert_selection() {
        keyboard(get_selection(), true);
    }

    //(PVB COM) disassemble_selection() is used only to disassemble the Atari text selection in the displayed Atari text area
    //(PVB TODO) improve this feature with several line selection in Hexdump()
    function disassemble_selection() { 
        var txt = get_selection();
        if (!txt || !txt.length) //(PVB COM) No text is selected so exit
            return;

        var asm = [];
        for (var i = 0; i < txt.length; i++)
            asm.push(txt.charCodeAt(i) & 0xFF); //(PVB COM) Convert Atari selected text to byte numbers
        var dis = _q(".disassembly"); //new window with "disassembly" class
        draggable(dis, _shown.name + " disassembly"); //_shown.name = file name (DOS or disk) displayed
        _h("#disassembly", xex_dump("asm", asm, 0, asm.length, "SEL")); //(PVB ADD) "SEL" for 'disassemble selection'

        var r = _gs().getRangeAt(0).getBoundingClientRect(); //(PVB COM) "r" is a DOMRect
        var dx = (dis.width - r.width) / 2;
        dis.style.left = ((dx | 0) + r.left) + "px";
        dis.style.top = r.bottom + 4 + "px";
        dis.hidden = false; //show the window
        editor().focus();
    }

    function selection_change() { //(PVB COM) Function used to monitor where is the mouse pointer and if text is selected
        var el = document.activeElement;
        if (el.id == "atari_text") {
            var txt = get_selection();
            var sel = txt && txt.length;
            //(PVB COM) if we have a text selection, then activate tool "I" for inverting text; and "D" for disassembling text  
            set_tool("I", sel);  // we have a selection
            set_tool("D", sel);
        }
    }

    function keyboard(txt, invert) {
        var e = editor();
        if (!e)
            return;

        if (!txt) {
            e.focus();
            return;
        }

        // same in ATASCII as ASCII
        // will cause unescaping of <>& etc
        function common_chars(s) {
            var dst = '';
            for (var i = 0; i < s.length; i++) {
                var c = s.charCodeAt(i);
                if ((c & 0xFF) > 0x20 && ((c & 0xFF) < 0x7B)) //PVB TODO WIP 0x20 is not a normal char !
                    c &= 0xFF;
                dst += String.fromCharCode(c);
            }
            return dst;
        }

        if (invert) {
            txt = get_selection();
            var s = '';
            for (var i = 0; i < txt.length; i++) {
                var c = txt.charCodeAt(i);
                c = ((c < 0x20) || (c == 0x200B)) ? c : (c ^ 0x80) | 0xE000;
                s += String.fromCharCode(c);
            }
            txt = s;
        }
        txt = common_chars(txt);

        var range = _gs().getRangeAt(0);
        if (invert)
            range.deleteContents();
        else
            range.collapse();

        // insert
        if (txt.indexOf('\n') != -1) {  // need to deal with newlines and insert the as breaks
            var lst = txt.split('\n');
            var n = [];
            for (var i = 0; i < lst.length; i++) {
                n.push(document.createTextNode(lst[i]));
                if (i != lst.length - 1)
                    n.push(document.createElement("br"));
            }
            var i = n.length;
            while (i--)
                range.insertNode(n[i]);
            range.setEndAfter(n[n.length - 1]);
        } else
            range.insertNode(document.createTextNode(txt));
        e.focus();
    }

    function show_ataritext(f, lst) {
        //called by show_txt() with argument (f, t) after buffer conversion by "t = ataritext(f.data, 0, f.data.length)""
        //called by show_bas(f) with argument (f, t ? t.listing : parse_failed(f)) after buffer conversion by "t = ataribasic(f.data, 0, f.data.length)""
        //called by show_m65(f) with argument (f, asm ? asm : parse_failed(f)) after buffer conversion by "asm = mac65(f.data, 0, f.data.length)"
        //"lst" is an array of strings (one string for each lines)
        render_file(f);
        var layout = _radios["layout"].value; //(PVB COM) 0 = 38, 1 = 40, 2 = 80, 3 = Wide
        var idnt = (f.ext == "bas") ? _checks['indent'] : 0; //(PVB ADD) idnt is taken from the button, only if basic
        var cols = layout < 2 ? 40 : 80;
        if (layout == 3)
            lst.forEach(s => cols = Math.max(cols, s.length));      
        lst = atari2ascii(lst, idnt); //(PVB MOD) previously//lst = atari2ascii(lst, f.ext == "bas")//idnt is now taken from the button
        var ta = editor(); //the editor blue window with atari text, HTML id="#atari_text"
        if (layout == 0) {
            ta.style.paddingLeft = '32px';
            cols -= 2;
        }
        else
            ta.style.paddingLeft = '0px';
        if (layout == 3)
            ta.style.fontSize = ta.style.lineHeight = '8px';
        else {
            ta.style.fontSize = ta.style.lineHeight = '16px';
            ta.style.minWidth = ta.style.maxWidth = (cols * 16) + "px";
        }
        ta.innerText = lst.join('\n');
    }

    // old fashioned font
    function show_font(f, lst, font, palette) {
        render_file(f);

        var fcanvas;
        if (font)
            fcanvas = get_font(font, palette);

        var layout = _radios["layout"].value;
        var cols = layout < 2 ? 40 : 80;
        var margin = layout == 0 ? 2 : 0;
        var wrap = [];

        if (layout == 3) {  // Don't wrap at all
            lst.forEach(line => cols = Math.max(line.length, cols));
            cols += 2 * margin;
            wrap = lst;
        } else {
            var wrap = [];
            lst.forEach(s => {
                while (s.length > (cols - margin)) {
                    wrap.push(s.substr(0, (cols - margin)));
                    s = s.substr((cols - margin));
                }
                wrap.push(s);
            });
        }

        var c = _q("#show");
        c.width = cols * 8;
        c.height = wrap.length * 8 + 16;
        var ctx = c.getContext('2d');
        ctx.webkitImageSmoothingEnabled = false;
        var bg = atari_palette_rgb[palette ? palette[0] : 128 + 20];
        ctx.fillStyle = '#' + hex(bg, 6); // "rgba(17,59,128,1)";
        ctx.fillRect(0, 0, c.width, c.height);
        for (var y = 0; y < wrap.length; y++)
            draw(ctx, wrap[y], margin, y + 1, fcanvas);
        resize_parent(c, layout == 3 ? 1 : 2);
    }

    var _font = [ //as stored in ROM memory of 800/XL/XE ROM like in $E000-E3FF 
        // atari 128 rom font 
        // 32..95
        // 0..31
        // 96..128
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x00,
        0x00, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x66, 0xff, 0x66, 0x66, 0xff, 0x66, 0x00,
        0x18, 0x3e, 0x60, 0x3c, 0x06, 0x7c, 0x18, 0x00,
        0x00, 0x66, 0x6c, 0x18, 0x30, 0x66, 0x46, 0x00,
        0x1c, 0x36, 0x1c, 0x38, 0x6f, 0x66, 0x3b, 0x00,
        0x00, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x0e, 0x1c, 0x18, 0x18, 0x1c, 0x0e, 0x00,
        0x00, 0x70, 0x38, 0x18, 0x18, 0x38, 0x70, 0x00,
        0x00, 0x66, 0x3c, 0xff, 0x3c, 0x66, 0x00, 0x00,
        0x00, 0x18, 0x18, 0x7e, 0x18, 0x18, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30,
        0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00,
        0x00, 0x06, 0x0c, 0x18, 0x30, 0x60, 0x40, 0x00,
        0x00, 0x3c, 0x66, 0x6e, 0x76, 0x66, 0x3c, 0x00,
        0x00, 0x18, 0x38, 0x18, 0x18, 0x18, 0x7e, 0x00,
        0x00, 0x3c, 0x66, 0x0c, 0x18, 0x30, 0x7e, 0x00,
        0x00, 0x7e, 0x0c, 0x18, 0x0c, 0x66, 0x3c, 0x00,
        0x00, 0x0c, 0x1c, 0x3c, 0x6c, 0x7e, 0x0c, 0x00,
        0x00, 0x7e, 0x60, 0x7c, 0x06, 0x66, 0x3c, 0x00,
        0x00, 0x3c, 0x60, 0x7c, 0x66, 0x66, 0x3c, 0x00,
        0x00, 0x7e, 0x06, 0x0c, 0x18, 0x30, 0x30, 0x00,
        0x00, 0x3c, 0x66, 0x3c, 0x66, 0x66, 0x3c, 0x00,
        0x00, 0x3c, 0x66, 0x3e, 0x06, 0x0c, 0x38, 0x00,
        0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00,
        0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x30,
        0x06, 0x0c, 0x18, 0x30, 0x18, 0x0c, 0x06, 0x00,
        0x00, 0x00, 0x7e, 0x00, 0x00, 0x7e, 0x00, 0x00,
        0x60, 0x30, 0x18, 0x0c, 0x18, 0x30, 0x60, 0x00,
        0x00, 0x3c, 0x66, 0x0c, 0x18, 0x00, 0x18, 0x00,
        0x00, 0x3c, 0x66, 0x6e, 0x6e, 0x60, 0x3e, 0x00,
        0x00, 0x18, 0x3c, 0x66, 0x66, 0x7e, 0x66, 0x00,
        0x00, 0x7c, 0x66, 0x7c, 0x66, 0x66, 0x7c, 0x00,
        0x00, 0x3c, 0x66, 0x60, 0x60, 0x66, 0x3c, 0x00,
        0x00, 0x78, 0x6c, 0x66, 0x66, 0x6c, 0x78, 0x00,
        0x00, 0x7e, 0x60, 0x7c, 0x60, 0x60, 0x7e, 0x00,
        0x00, 0x7e, 0x60, 0x7c, 0x60, 0x60, 0x60, 0x00,
        0x00, 0x3e, 0x60, 0x60, 0x6e, 0x66, 0x3e, 0x00,
        0x00, 0x66, 0x66, 0x7e, 0x66, 0x66, 0x66, 0x00,
        0x00, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x7e, 0x00,
        0x00, 0x06, 0x06, 0x06, 0x06, 0x66, 0x3c, 0x00,
        0x00, 0x66, 0x6c, 0x78, 0x78, 0x6c, 0x66, 0x00,
        0x00, 0x60, 0x60, 0x60, 0x60, 0x60, 0x7e, 0x00,
        0x00, 0x63, 0x77, 0x7f, 0x6b, 0x63, 0x63, 0x00,
        0x00, 0x66, 0x76, 0x7e, 0x7e, 0x6e, 0x66, 0x00,
        0x00, 0x3c, 0x66, 0x66, 0x66, 0x66, 0x3c, 0x00,
        0x00, 0x7c, 0x66, 0x66, 0x7c, 0x60, 0x60, 0x00,
        0x00, 0x3c, 0x66, 0x66, 0x66, 0x6c, 0x36, 0x00,
        0x00, 0x7c, 0x66, 0x66, 0x7c, 0x6c, 0x66, 0x00,
        0x00, 0x3c, 0x60, 0x3c, 0x06, 0x06, 0x3c, 0x00,
        0x00, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00,
        0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7e, 0x00,
        0x00, 0x66, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x00,
        0x00, 0x63, 0x63, 0x6b, 0x7f, 0x77, 0x63, 0x00,
        0x00, 0x66, 0x66, 0x3c, 0x3c, 0x66, 0x66, 0x00,
        0x00, 0x66, 0x66, 0x3c, 0x18, 0x18, 0x18, 0x00,
        0x00, 0x7e, 0x0c, 0x18, 0x30, 0x60, 0x7e, 0x00,
        0x00, 0x1e, 0x18, 0x18, 0x18, 0x18, 0x1e, 0x00,
        0x00, 0x40, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x00,
        0x00, 0x78, 0x18, 0x18, 0x18, 0x18, 0x78, 0x00,
        0x00, 0x08, 0x1c, 0x36, 0x63, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00,
        0x00, 0x36, 0x7f, 0x7f, 0x3e, 0x1c, 0x08, 0x00,
        0x18, 0x18, 0x18, 0x1f, 0x1f, 0x18, 0x18, 0x18,
        0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
        0x18, 0x18, 0x18, 0xf8, 0xf8, 0x00, 0x00, 0x00,
        0x18, 0x18, 0x18, 0xf8, 0xf8, 0x18, 0x18, 0x18,
        0x00, 0x00, 0x00, 0xf8, 0xf8, 0x18, 0x18, 0x18,
        0x03, 0x07, 0x0e, 0x1c, 0x38, 0x70, 0xe0, 0xc0,
        0xc0, 0xe0, 0x70, 0x38, 0x1c, 0x0e, 0x07, 0x03,
        0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f, 0xff,
        0x00, 0x00, 0x00, 0x00, 0x0f, 0x0f, 0x0f, 0x0f,
        0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe, 0xff,
        0x0f, 0x0f, 0x0f, 0x0f, 0x00, 0x00, 0x00, 0x00,
        0xf0, 0xf0, 0xf0, 0xf0, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0xf0, 0xf0, 0xf0, 0xf0,
        0x00, 0x1c, 0x1c, 0x77, 0x77, 0x08, 0x1c, 0x00,
        0x00, 0x00, 0x00, 0x1f, 0x1f, 0x18, 0x18, 0x18,
        0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00,
        0x18, 0x18, 0x18, 0xff, 0xff, 0x18, 0x18, 0x18,
        0x00, 0x00, 0x3c, 0x7e, 0x7e, 0x7e, 0x3c, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
        0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0,
        0x00, 0x00, 0x00, 0xff, 0xff, 0x18, 0x18, 0x18,
        0x18, 0x18, 0x18, 0xff, 0xff, 0x00, 0x00, 0x00,
        0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0,
        0x18, 0x18, 0x18, 0x1f, 0x1f, 0x00, 0x00, 0x00,
        0x78, 0x60, 0x78, 0x60, 0x7e, 0x18, 0x1e, 0x00,
        0x00, 0x18, 0x3c, 0x7e, 0x18, 0x18, 0x18, 0x00,
        0x00, 0x18, 0x18, 0x18, 0x7e, 0x3c, 0x18, 0x00,
        0x00, 0x18, 0x30, 0x7e, 0x30, 0x18, 0x00, 0x00,
        0x00, 0x18, 0x0c, 0x7e, 0x0c, 0x18, 0x00, 0x00,
        0x00, 0x18, 0x3c, 0x7e, 0x7e, 0x3c, 0x18, 0x00,
        0x00, 0x00, 0x3c, 0x06, 0x3e, 0x66, 0x3e, 0x00,
        0x00, 0x60, 0x60, 0x7c, 0x66, 0x66, 0x7c, 0x00,
        0x00, 0x00, 0x3c, 0x60, 0x60, 0x60, 0x3c, 0x00,
        0x00, 0x06, 0x06, 0x3e, 0x66, 0x66, 0x3e, 0x00,
        0x00, 0x00, 0x3c, 0x66, 0x7e, 0x60, 0x3c, 0x00,
        0x00, 0x0e, 0x18, 0x3e, 0x18, 0x18, 0x18, 0x00,
        0x00, 0x00, 0x3e, 0x66, 0x66, 0x3e, 0x06, 0x7c,
        0x00, 0x60, 0x60, 0x7c, 0x66, 0x66, 0x66, 0x00,
        0x00, 0x18, 0x00, 0x38, 0x18, 0x18, 0x3c, 0x00,
        0x00, 0x06, 0x00, 0x06, 0x06, 0x06, 0x06, 0x3c,
        0x00, 0x60, 0x60, 0x6c, 0x78, 0x6c, 0x66, 0x00,
        0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00,
        0x00, 0x00, 0x66, 0x7f, 0x7f, 0x6b, 0x63, 0x00,
        0x00, 0x00, 0x7c, 0x66, 0x66, 0x66, 0x66, 0x00,
        0x00, 0x00, 0x3c, 0x66, 0x66, 0x66, 0x3c, 0x00,
        0x00, 0x00, 0x7c, 0x66, 0x66, 0x7c, 0x60, 0x60,
        0x00, 0x00, 0x3e, 0x66, 0x66, 0x3e, 0x06, 0x06,
        0x00, 0x00, 0x7c, 0x66, 0x60, 0x60, 0x60, 0x00,
        0x00, 0x00, 0x3e, 0x60, 0x3c, 0x06, 0x7c, 0x00,
        0x00, 0x18, 0x7e, 0x18, 0x18, 0x18, 0x0e, 0x00,
        0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3e, 0x00,
        0x00, 0x00, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x00,
        0x00, 0x00, 0x63, 0x6b, 0x7f, 0x3e, 0x36, 0x00,
        0x00, 0x00, 0x66, 0x3c, 0x18, 0x3c, 0x66, 0x00,
        0x00, 0x00, 0x66, 0x66, 0x66, 0x3e, 0x0c, 0x78,
        0x00, 0x00, 0x7e, 0x0c, 0x18, 0x30, 0x7e, 0x00,
        0x00, 0x18, 0x3c, 0x7e, 0x7e, 0x18, 0x3c, 0x00,
        0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
        0x00, 0x7e, 0x78, 0x7c, 0x6e, 0x66, 0x06, 0x00,
        0x08, 0x18, 0x38, 0x78, 0x38, 0x18, 0x08, 0x00,
        0x10, 0x18, 0x1c, 0x1e, 0x1c, 0x18, 0x10, 0x00,
    ];

    function makefont() {  //(PVB COM) //TODO// function empty and not used... should be a futur to do stuff

    }


    //===================================================================================================
    //  Drag and drop

    function drop_init(el, onfile, all_done) {
        
        function over(b) {
            set_class(_q("#toc"), "over", b); //(PVB COM) used to add "over" to the "nav#toc" class
        }

        function handleFiles(files) {

            function readAsArrayBuffer(file) {
                return new Promise((resolve, reject) => {
                    const fr = new FileReader();
                    fr.onerror = reject;
                    fr.onload = function (evt) {
                        onfile(file, evt.target.result);
                        resolve(fr.result);
                    }
                    fr.readAsArrayBuffer(file);
                });
            }

            // Load all the files, callback when done
            Promise.all(Array.prototype.map.call(files, readAsArrayBuffer))
                .then(urls => {
                    all_done();
                })
                .catch(error => {
                    console.log(error);
                });
        }

        function handleFileSelect(evt) {
            evt.stopPropagation();
            evt.preventDefault();
            over(0);
            handleFiles(evt.dataTransfer.files);

            // check for dragged urls of images
            var items = evt.dataTransfer.items;
            for (var i = 0; i < items.length; i++) {
                if (items[i].kind == 'string' && items[i].type == 'text/uri-list') {
                    items[i].getAsString(s => console.log(s));  // cross origin will make this useless
                }
            }
        }

        function handleDragOver(evt) {
            evt.stopPropagation();
            evt.preventDefault();
            evt.dataTransfer.dropEffect = 'copy'; // Explicitly show this is a copy.
        }
        //(PVB COM) drop_ini starts here
        el.addEventListener('dragover', handleDragOver, false);
        el.addEventListener('drop', handleFileSelect, false);
        el.addEventListener('dragenter', e => over(1), false); //(PVB) 'e' is a DragEvent
        el.addEventListener('dragleave', e => over(0), false); //(PVB) 'e' is a DragEvent

        _q("#fe").addEventListener("change", e => handleFiles(_q("#fe").files), false);

    }

    //===================================================================================================
    // http://www.atarimax.com/jindroush.atari.org/afmtbas.html
    // Disassemble m65

    var _mac65_table1 = [
        "ERROR -", ".IF", ".ELSE", ".ENDIF", ".MACRO", ".ENDM", ".TITLE", "",
        ".PAGE", ".WORD", ".ERROR", ".BYTE", ".SBYTE", ".DBYTE", ".END", ".OPT",
        ".TAB", ".INCLUDE", ".DS", ".ORG", ".EQU", "BRA", "TRB", "TSB",
        ".FLOAT", ".CBYTE", ";", ".LOCAL", ".SET", "*=", "=", ".=",
        "JSR", "JMP", "DEC", "INC", "LDX", "LDY", "STX", "STY",
        "CPX", "CPY", "BIT", "BRK", "CLC", "CLD", "CLI", "CLV",
        "DEX", "DEY", "INX", "INY", "NOP", "PHA", "PHP", "PLA",
        "PLP", "RTI", "RTS", "SEC", "SED", "SEI", "TAX", "TAY",
        "TSX", "TXA", "TXS", "TYA", "BCC", "BCS", "BEQ", "BMI",
        "BNE", "BPL", "BVC", "BVS", "ORA", "AND", "EOR", "ADC",
        "STA", "LDA", "CMP", "SBC", "ASL", "ROL", "LSR", "ROR",
        "", "STZ", "DEA", "INA", "PHX", "PHY", "PLX", "PLY",
    ];

    var _mac65_table2 = [
        null, null, null, null, null, "", "", "",
        "", null, "", "%$", "%", "*", null, null,
        null, null, "+", "-", "*", "/", "&", null,
        "=", "<=", ">=", "<>", ">", "<", "-", "[",
        "]", null, null, null, "!", "^", null, "\\",
        null, null, null, null, null, null, null, ".REF",
        ".DEF", ".NOT", ".AND", ".OR", "<", ">", ",X)", "),Y",
        ",Y", ",X", ")", "", null, ",", "#", "A",
        "(", '"', null, null, null, "NO", "OBJ", "ERR",
        "EJECT", "LIST", "XREF", "MLIST", "CLIST", "NUM", null, null,
    ];

    function mac65(a, i, len) {
        if (le16(a, i) != 0xFEFE)
            return null;
        if (le16(a, i + 2) != (len - 4))
            return null;
        var end = i + len;
        i += 4;

        var indent = 5;
        var asm = [];
        while (i < len) {
            var line_number = le16(a, i);
            var line_end = i + a[i + 2];
            i += 3;

            var s = line_number + ' ';
            var pad = ('' + line_number).length + indent;
            var c = a[i++];
            if (c & 0x80) {
                c -= 0x80;  // label
                while (c--)
                    s += String.fromCharCode(a[i++]);
                if (i == line_end) {
                    asm.push(s);
                    continue;
                }
                c = a[i++];
            } else if (c == 0 || c == 88) {
                while (i < line_end)
                    s += String.fromCharCode(a[i++]);   // raw
                asm.push(s);
                continue;
            } else if (c == 1) {
                indent++;           // IF
            } else if (c == 3) {
                indent--;           // ENDIF
            }

            if (c >= 96)
                return null;
            while (s.length < pad)
                s += ' ';
            if (s[s.length - 1] != ' ')
                s += ' ';
            s += _mac65_table1[c] + ' ';   // token

            while (i < line_end) {
                c = a[i++];
                switch (c) {
                    case 5: s += '$' + hex(le16(a, i), 4); i += 2; break;
                    case 6: s += '$' + hex(a[i++]); break;
                    case 7: s += le16(a, i); i += 2; break;
                    case 8: s += a[i++]; break;
                    case 10: s += "'" + String.fromCharCode(a[i++]); break;
                    case 59:
                        s += ' ';
                        while (i < line_end)
                            s += String.fromCharCode(a[i++]);   // comment
                        break;
                    default:
                        if (c & 0x80) {
                            c -= 0x80;
                            while (c--)
                                s += String.fromCharCode(a[i++]);
                        } else {
                            var t = _mac65_table2[c];
                            if (!t)
                                return null;
                            s += t;
                            if (c > 64)
                                s += ' ';   // not sure all of all the padding rules
                        }
                        break;
                }
            }
            asm.push(s);
        }
        return asm;
    }

    //===================================================================================================
    // http://www.atarimax.com/jindroush.atari.org/afmtbas.html
    // Disassemble atari basic

    var _basic_commands = [
        // 56 in classic Basic
        "REM", "DATA", "INPUT", "COLOR", "LIST", "ENTER", "LET", "IF", "FOR", "NEXT", "GOTO",
        "GO TO", "GOSUB", "TRAP", "BYE", "CONT", "COM", "CLOSE", "CLR", "DEG", "DIM", "END",
        "NEW", "OPEN", "LOAD", "SAVE", "STATUS", "NOTE", "POINT", "XIO", "ON", "POKE", "PRINT",
        "RAD", "READ", "RESTORE", "RETURN", "RUN", "STOP", "POP", "?", "GET", "PUT", "GRAPHICS",
        "PLOT", "POSITION", "DOS", "DRAWTO", "SETCOLOR", "LOCATE", "SOUND", "LPRINT", "CSAVE",
        "CLOAD", "LET_", "ERROR",

        // Turbo Basic
        "DPOKE ", "MOVE ", "-MOVE ", "*F", "REPEAT ", "UNTIL ", "WHILE ", "WEND ",
        "ELSE ", "ENDIF ", "BPUT ", "BGET ", "FILLTO ", "DO ", "LOOP ", "EXIT ",
        "DIR ", "LOCK ", "UNLOCK ", "RENAME ", "DELETE ", "PAUSE ", "TIME$= ", "PROC ",
        "EXEC ", "ENDPROC ", "FCOLOR ", "*L ",
        "------------------------------",
        "RENUM ", "DEL ", "DUMP ",
        "TRACE ", "TEXT ", "BLOAD ", "BRUN ", "GO# ", "# ", "*B ", "PAINT ",
        "CLS ", "DSOUND ", "CIRCLE ", "%PUT ", "%GET "
    ];

    var _basic_operators = [
        "_0", "_1", "_2", "_3", "_4", "_5", "_6", "_7", "_8", "_9", "_A", "_B", "_C", "_D",
        "NCONST", "SCONST", "NOUSE", "NOUSE", ",", "$", ":", ";", "EOL", " GOTO ", " GOSUB ", " TO ",
        " STEP ", " THEN ", "#", "<=", "<>", ">=", "<", ">", "=", "^", "*", "+", "-", "/", " NOT ", " OR ", " AND ",
        "(", ")", "=", "=", "<=", "<>", ">=", "<", ">", "=", "+", "-", "(", "(", "(", "(", "(", ",",
        "STR$", "CHR$", "USR", "ASC", "VAL", "LEN", "ADR", "ATN", "COS", "PEEK", "SIN", "RND", "FRE",
        "EXP", "LOG", "CLOG", "SQR", "SGN", "ABS", "INT", "PADDLE", "STICK", "PTRIG", "STRIG",

        // Turbo Basic
        "DPEEK", "&", "!", "INSTR", "INKEY$", " EXOR ", "HEX$", "DEC",
        " DIV ", "FRAC", "TIME$", "TIME", " MOD ", "EXEC ", "RND", "RAND",
        "TRUNC", "%0", "%1", "%2", "%3", "GO# ", "UINSTR", "ERR", "ERL"
    ];

    function ataribasic(a, i, len) {
        var indenting = _checks['indent']; //identing == 0 (off) or 1 (on)
        var b = {
            lomem: le16(a, i + 0),   // should be zero
            vnt: le16(a, i + 2),     // start of variable name table
            vnte: le16(a, i + 4),    // end of variable name table
            vvt: le16(a, i + 6),     // start of variable values table
            stmtab: le16(a, i + 8),  // start of token area
            stmcur: le16(a, i + 10), // current line (line 32768)
            starp: le16(a, i + 12),  // end of token area, start of stacks

            variable_names: [],
            variable_values: [],
            statements: []
        }

        function failed(reason) {
            reason = reason || "Bytes don't look like Basic";
            console.log("ataribasic (): =>"); //(PVB ADD)
            console.log(reason);
            console.log(b);
            console.log(listing);
            console.log("*end of ataribasic ()*"); //(PVB ADD)
            return null;
        }

        var origin = b.vnt - b.lomem - 14; // file offsets are weird?
        if (origin < 0)
            return failed();
        b.vnt -= origin;
        b.vnte -= origin;
        b.vvt -= origin;
        b.stmtab -= origin;
        b.stmcur -= origin;
        b.starp -= origin;
        if (b.vnt > b.vnte || b.vnte > b.vvt || b.vvt > b.stmtab || b.stmtab > b.stmcur || b.stmcur > b.starp)
            return failed();    // Not a basic file?

        function get_string(data, si, len) {
            var s = '';
            while (len--) {
                var c = String.fromCharCode(data[si++]);
                s += c;
                if (c == '"')
                    s += c;
            }
            return s;
        }

        function bcd(data, bi) {
            var n = 0;
            var e = data[bi++];
            if (e == 0)
                return 0;
            for (var j = 0; j < 5; j++) {
                var c = data[bi++];
                n *= 10;
                n += c >> 4;
                n *= 10;
                n += c & 0xF;
            }
            e = (e - 68) * 2;

            switch (e) {	// Math.pow was not producing integers
                case -1: return n / 10;
                case -2: return n / 100;
                case -3: return n / 1000;
                case -4: return n / 10000;
            }
            return n * Math.pow(10, e);
        }

        var vnt_begin = i + b.vnt;
        var vnt_end = i + b.vnte;
        var n = '';
        var nmap = {};
        var ncount = 0;
        for (var j = vnt_begin; j < vnt_end; j++) {
            n += String.fromCharCode(a[j] & 0x7F);
            if (a[j] & 0x80) {
                if (n.length && n[n.length - 1] == '(')
                    n = n.substr(0, n.length - 1);	// 
                if (nmap[n])
                    console.log(`ataribasic(): reapeated variable name '${n}'`);
                nmap[n] = 1;
                ncount++;
                b.variable_names.push(n);
                n = '';
            }
        }

        if (Object.keys(nmap).length == 1) {
            console.log("ataribasic(): resetting variable names");
            b.variable_names = [];  // name table was set to the same value: reset it
        }

        var vvt_begin = i + b.vvt;	// NOT SURE WHY THESE ARE +1
        var tokens_begin = i + b.stmtab;
        var vid = 0;
        for (var j = vvt_begin; j < tokens_begin; j += 8) {
            var v = { name: b.variable_names[a[j + 1]] };

            if (!v.name) {  // someone got rid of all the variable names. make new ones
                var ch = String.fromCharCode(65 + (vid % 26));    // 'A'
                var n = Math.floor(vid++ / 26);
                if (n)
                    ch += n + 1;                              // A,B,C ... A2,B2...
                switch (a[j]) {
                    case 0x80:
                    case 0x81:
                        ch += '$';
                        break;
                }
                b.variable_names[a[j + 1]] = v.name = ch;     // make up a name if missing
            }

            var p0 = le16(a, j + 2);
            var p1 = le16(a, j + 4);
            var p2 = le16(a, j + 6);
            switch (a[j]) {
                case 0x00:
                    v.type = "scalar";
                    v.value = bcd(a, j + 2);
                    break;
                case 0x40:
                case 0x41:
                    v.type = "array";
                    break;
                case 0x80:
                case 0x81:
                    v.type = "string";
                    v.value = get_string(a, b.starp + i + p0, p1);
                    break;
                default:
                    v.type = a[j];
            }
            b.variable_values.push(v);
        }

        //var tokens_end = i+b.stmcur;
        var tokens_end = i + b.starp; // kings cribbage see https://www.atariarchives.org/mapping/memorymap.php STMCUR
        var turbo = false;

        var listing = [];
        var indent = 0;
        for (var j = tokens_begin; j < tokens_end;) {
            var s = { tok: [] };
            s.lineno = le16(a, j);
            var len = a[j + 2];

            if (s.lineno == 32768 || len == 0)
                break; // stmcur

            var line = s.lineno + " ";

            if (indent) {
                var cmd = a[j + 4];
                // Check if indent needs to decreased *before* the first command:
                //              NEXT           UNTIL          WEND           LOOP           ENDPROC        ENDIF     ELSE
                if (cmd == 0x09 || cmd == 0x3D || cmd == 0x3F || cmd == 0x46 || cmd == 0x51 || cmd == 0x41 || cmd == 0x40)
                    line = line + " ".repeat(2 * indent - 2);
                else
                    line = line + " ".repeat(2 * indent);
            }

            // Parse statements
            var k = 3;
            var op;
            while (k < len) {
                var end = a[j + k];
                var cmd = a[j + k + 1];
                k += 2;
                if (cmd >= 56) {
                    turbo = true;
                    if (cmd >= 101)
                        return failed("Unrecognized command index:" + cmd);    // not basic
                }

                s.tok.push(_basic_commands[cmd]);
                if (cmd != 0x36) {	// slient LET
                    line += _basic_commands[cmd];
                    if (line[line.length - 1] != ' ')
                        line += ' ';
                }

                if (cmd < 2) {	// REM,DATA
                    var txt = '';
                    while (k < end) {
                        var c = a[j + k++];
                        if (c == 0x9B)
                            break;
                        txt += String.fromCharCode(c);
                    }
                    s.tok.push(txt);
                    line += txt;
                    k = end;
                }

                // Check indent:
                //         FOR            REPEAT         WHILE          DO             PROC
                if (cmd == 0x08 || cmd == 0x3C || cmd == 0x3E || cmd == 0x45 || cmd == 0x4F)
                    indent += indenting;
                //              IF
                else if (cmd == 0x07) {
                    // Verify if there is THEN
                    var got_then = false;
                    for (var l = k; l < end; l++) {
                        var op = a[j + l];
                        if (op == 0x1B) {
                            got_then = true;
                            break;
                        }
                        else if (!op)
                            l++;
                        else if (op == 0x0F)
                            l += a[j + l + 1] + 1;
                        else if (op == 0x0E || op == 0x0D)
                            l += 6;
                    }
                    if (!got_then)
                        indent += indenting;
                }
                //              NEXT           UNTIL          WEND           LOOP           ENDPROC        ENDIF
                else if (cmd == 0x09 || cmd == 0x3D || cmd == 0x3F || cmd == 0x46 || cmd == 0x51 || cmd == 0x41)
                    indent = indent > 0 ? indent - 1 : 0;

                while (k < end) {
                    op = a[j + k++];
                    switch (op) {
                        case 0x0F: // SCONST
                            var txt = '';
                            var blen = a[j + k++];
                            while (blen--) {
                                c = a[j + k++];
                                if (c == 0x9B)
                                    break;
                                txt += String.fromCharCode(c);
                            }
                            s.tok.push(txt);
                            line += '"' + txt + '"';
                            break;
                        case 0x0D: // BCD hex const
                            var n = bcd(a, j + k);
                            var c = 1;
                            while (n >= (1 << c * 8))
                                c++;
                            s.tok.push(n);
                            k += 6;
                            line += '$' + hex(n, c * 2);
                            break;
                        case 0x0E: // NCONST
                            var n = bcd(a, j + k);
                            s.tok.push(n);
                            k += 6;
                            line += n;
                            break;
                        case 0x16: // EOL
                            k = end;
                            break;
                        default: {
                            var txt;
                            if (op & 0x80)
                                txt = b.variable_names[op & 0x7F];
                            else if (!op) {
                                turbo = true;
                                txt = b.variable_names[a[j + k++] ^ 0x80];    // thx dragonstomper
                            } else {
                                if (op >= 85) {
                                    turbo = true;
                                    if (op >= 110)
                                        return failed("Unrecognized operation:" + op);    // not basic
                                }
                                txt = _basic_operators[op];
                            }
                            if (txt == ":" || txt[0] == ' ')
                                line = line.trim();
                            line += txt;
                            s.tok.push(txt);
                        }
                    }
                }
            }
            b.statements.push(s);
            listing.push(line);
            j += len;
        }
        return { listing: listing, tokens: b }
    }

    //===================================================================================================
    // Atari syms equates : https://atariwiki.org/wiki/Wiki.jsp?page=Atari%20800%20Assembler%20Equates
    // also equates can be found in Atari OS Source listings
    // updated with information from Altirra Source Code, Disassembler DIS6502 https://sourceforge.net/p/dis6502/feature-requests/70/

    //(PVB ADD) 5200 EQUATES
    var _bShowA5200Equates = 0; //if set, A5200 disassembly equates instead of 800/XL/XE equates
    //for Atari 5200:
    //https://archive.org/details/analog-computing-magazine-15/page/n61/mode/2up?view=theater
    //commented by Dan Boris http://www.atarihq.com/danb/files/52analog.pdf
    var _A5200syms_zp = { //syms for Zero Page of Atari 5200
        //A5200 RAM is $0000 to $3FFF
        //PAGE zero $00-FF
        //$00 to $18 are reserved as follows
        '00':['POKMSK','SHADOW FOR IRQEN'],
        '01':['RTCLOKH','REAL TIME CLOCK (MSB)'],
        '02':['RTCLOKL','REAL TIME CLOCK (LSB)'],
        '03':['CRITIC','(ALSO NAMED CODFLG) IF NON-ZERO VBI ROUTINE IS SHORTEN'],
        '04':['ATRACT','ATRACT MODE TIME / FLAG'],
        '05':['SDLSTL','SHADOW FOR DLISTL'],
        '06':['SDLSTH','SHADOW FOR DLISTH'],
        '07':['SDMCTL','SHADOW FOR DMACTL'],
        '08':['PCOLR0','SHADOW FOR COLPM0'],
        '09':['PCOLR1','SHADOW FOR COLPM1'],
        '0A':['PCOLR2','SHADOW FOR COLPM2'],
        '0B':['PCOLR3','SHADOW FOR COLPM3'],
        '0C':['COLOR0','SHADOW FOR COLOR0'],
        '0D':['COLOR1','SHADOW FOR COLOR1'],
        '0E':['COLOR2','SHADOW FOR COLOR2'],
        '0F':['COLOR3','SHADOW FOR COLOR3'],
        '10':['COLOR4','SHADOW FOR COLBK'],
        '11':['PADDL0','SHADOW FOR POTO0'],
        '12':['PADDL1','SHADOW FOR POTO1'],
        '13':['PADDL2','SHADOW FOR POTO2'],
        '14':['PADDL3','SHADOW FOR POTO3'],
        '15':['PADDL4','SHADOW FOR POTO4'],
        '16':['PADDL5','SHADOW FOR POTO5'],
        '17':['PADDL6','SHADOW FOR POTO6'],
        '18':['PADDL7','SHADOW FOR POTO7'],
    }
    var _A5200syms = {
        //A5200 RAM is $0000 to $3FFF
        //PAGE 1 $100-1FF = 6502C CPU STACK
        '0100':["STACK", "6502C CPU STACK (256 BYTES UP TO $1FF)"],
        //$200 to $021B for the OS ROM Registers Shadows as follows
        '0200':['VIMIRQ ','IMMEDIATE IRQ VECTOR'],
        '0201':['VIMIRQ+1 ','...'],
        '0202':['VVBLKI ','IMMEDIATE VBI VECTOR'],
        '0203':['VVBLKI+1 ','...'],
        '0204':['VVBLKD ','DIFFERED VBI VECTOR'],
        '0205':['VVBLKD+1 ','...'],
        '0206':['VDLI ','VDSLST DLI VECTOR LOW'],
        '0207':['VDLI+1 ','VDSLST+1 DLI VECTOR HIGH'],
        '0208':['VKEYBD ','VKYBDI KEYBOARD IRQ VECTOR'],
        '0209':['VKEYBD+1 ','VKYBDI+1 KEYBOARD IRQ VECTOR'],
        '020A':['VKEYPAD ','VKYBDF KEYPAD ROUTINE CONTINUATION VECTOR'],
        '020B':['VKEYPAD+1 ','VKYBDF+1 KEYPAD ROUTINE CONTINUATION VECTOR'],
        '020C':['VBREAK ','VTRIGR BREAK KEY IRQ VECTOR'],
        '020D':['VBREAK+1 ','VTRIGR+1 BREAK KEY IRQ VECTOR'],
        '020E':['VBRK ','VBRKOP BREAK INSTRUCTION IRQ VECTOR'],
        '020F':['VBRK+1 ','VBRKOP+1 BREAK INSTRUCTION IRQ VECTOR'],
        '0210':['VSERIN ','SERIAL INPUT DATA READY IRQ VECTOR'],
        '0211':['VSERIN+1 ','...'],
        '0212':['VSEROR ','SERIAL OUTPUT DATA NEEDED IRQ VECTOR'],
        '0213':['VSEROR+1 ','...'],
        '0214':['VSEROC ','SERIAL OUTPUT FINISHED IRQ VECTOR'],
        '0215':['VSEROC+1 ','...'],
        '0216':['VTIMR1 ','POKEY TIMER 1 IRQ VECTOR'],
        '0217':['VTIMR1+1 ','...'],
        '0218':['VTIMR2 ','POKEY TIMER 2 IRQ VECTOR'],
        '0219':['VTIMR2+1 ','...'],
        '021A':['VTIMR4 ','POKEY TIMER 4 IRQ VECTOR'],
        '021B':['VTIMR4+1 ','...']
        //ROM CHAR SET is $F800 to $FBFF
        //ROM OS/MONITOR is $FC00 to $FFFF
    }
    //(PVB End Of ADD)

    //Atari 800/XL/XE equates
    //(PVB MOD) Update according to Altirra Source Equates & Disassembler
    var _A800syms_zp = { //zero page $00-FF
        '00': ["LINZBS", "[800]LINBUG STORAGE FOR ORIGINAL DEBUGGER"],
        '01': ["NGFLAG", "[XL]FOR POWER-UP SELF TEST"],
        '02': ["CASINI", "CASSETTE INIT LOC"],
        '03': ["CASINI+1", ""],
        '04': ["RAMLO", "RAM POINTER FOR MEM TEST"],
        '05': ["RAMLO+1", ""],
        '06': ["TRAMSZ", "TEMP LOC FOR RAM SIZE"],
        '07': ["TSTDAT", "RAM TEST DATA LOC"],
        '08': ["WARMST", "WARM START FLAG"],
        '09': ["BOOTQ", "SUCCESSFUL BOOT FLAG"],
        '0A': ["DOSVEC", "DOS START VECTOR (PROGRAM RUN VECTOR)"],
        '0B': ["DOSVEC+1", ""],
        '0C': ["DOSINI", "DOS INIT ADDRESS (PROGRAM INITIALIZATION)"],
        '0D': ["DOSINI+1", ""],
        '0E': ["APPMHI", "APPLICATION MEM HI LIMIT (DISPLAY LOW LIMIT)"],
        '0F': ["APPMHI+1", ""],
        '10': ["POKMSK", "SYSTEM MASK FOR POKEY IRQ ENABLE"],
        '11': ["BRKKEY", "BREAK KEY FLAG"],
        '12': ["RTCLOK", "REAL TIME CLOCK (60HZ OR 16.66666 MS) MSB"],
        '13': ["RTCLOK+1", "REAL TIME CLOCK MED BYTE"],
        '14': ["RTCLOK+2", "REAL TIME CLOCK LSB BYTE"],
        '15': ["BUFADR", "INDIRECT BUFFER ADDRESS REG"],
        '16': ["BUFADR+1", ""],
        '17': ["ICCOMT", "COMMAND FOR VECTOR HANDLER"],
        '18': ["DSKFMS", "DISK FILE MANAGER POINTER"],
        '19': ["DSKFMS+1", ""],
        '1A': ["DSKUTL", "DISK UTILITIES POINTER (DUP.SYS)"],
        '1B': ["DSKUTL+1", ""],
        '1C': ["PTIMOT/ABUFPT", "[800]PRINTER TIME OUT REGISTER /[XL]RESERVED"],
        '1D': ["PBPNT/ABUFPT+1", "[800]PRINT BUFFER POINTER /[XL]RESERVED"],
        '1E': ["PBUFSZ/ABUFPT+2", "[800]PRINT BUFFER SIZE /[XL]RESERVED"],
        '1F': ["PTEMP/ABUFPT+3", "[800]TEMPORARY REGISTER /[XL]RESERVED"],
        '20': ["ICHIDZ", "HANDLER INDEX NUMBER ($FF := IOCB FREE)"],//ZIOCB  = $20	; 32 ZERO PAGE IOCB
        '21': ["ICDNOZ", "DEVICE NUMBER (DRIVE NUMBER)"],
        '22': ["ICCOMZ", "COMMAND CODE"],
        '23': ["ICSTAZ", "STATUS OF LAST IOCB ACTION"],
        '24': ["ICBALZ", "BUFFER ADDRESS (LOW)"],
        '25': ["ICBAHZ", "BUFFER ADDRESS (HIGH)"],
        '26': ["ICPTLZ", "PUT BYTE ROUTINE ADDRESS-1 (LOW)"],
        '27': ["ICPTHZ", "PUT BYTE ROUTINE ADDRESS (HIGH)"],
        '28': ["ICBLLZ", "BUFFER LENGTH (LOW)"],
        '29': ["ICBLHZ", "BUFFER LENGTH (HIGH)"],
        '2A': ["ICAX1Z", "AUX INFO BYTE 1"],
        '2B': ["ICAX2Z", "AUX INFO BYTE 2"],
        '2C': ["ICSPRZ", "SPARE BYTE 1 (CIO LOCAL USE)"],
        '2D': ["ICSPRZ+1", "SPARE BYTE 1 (CIO LOCAL USE)"],
        '2E': ["ICIDNO", "IOCB LUMBER x 16"],
        '2F': ["CIOCHR", "CHARACTER BYTE FOR CURRENT OPERATION"],
        '30': ["STATUS", "INTERNAL STATUS STORAGE"],
        '31': ["CHKSUM", "CHECKSUM (SINGLE BYTE SUM WITH CARRY)"],
        '32': ["BUFRLO", "POINTER TO DATA BUFFER (LO BYTE)"],
        '33': ["BUFRHI", "POINTER TO DATA BUFFER (HI BYTE)"],
        '34': ["BFENLO", "NEXT BYTE PAST END OF BUFFER (LO BYTE)"],
        '35': ["BFENHI", "NEXT BYTE PAST END OF BUFFER (HI BYTE)"],
        '36': ["CRETRY/LTEMP", "[800]NBR OF COMMAND FRAME RETRIES /[XL]LOADER TEMP STORAGE"],
        '37': ["DRETRY/LTEMP+1", "[800]NBR OF DEVICE RETRIES/[XL]LOADER TEMP STORAGE"],
        '38': ["BUFRFL", "DATA BUFFER FULL FLAG"],
        '39': ["RECVDN", "RECEIVE DONE FLAG"],
        '3A': ["XMTDON", "XMIT DONE FLAG"],
        '3B': ["CHKSNT", "CHECKSUM SENT FLAG"],
        '3C': ["NOCKSM", "NO CHECKSUM FOLLOWS DATA FLAG"],
        '3D': ["BPTR", "BUFFER POINTER (CASSETTE)"],
        '3E': ["FTYPE", "FILE TYPE (SHORT IRG/LONG IRG)"],
        '3F': ["FEOF", "END OF FILE FLAG (CASSETTE)"],
        '40': ["FREQ", "FREQ COUNTER FOR CONSOLE SPEAKER"],
        '41': ["SOUNDR", "NOISY I/O FLAG (ZERO IS QUIET)"],
        '42': ["CRITIC", "CRITICAL CODE IF NON-ZERO (NO DEFFERED VBI)"],
        '43': ["FMSZPG", "DISK FILE MANAGER SYSTEM STORAGE (7 BYTES)"],
        '44': ["FMSZPG+1", ""],
        '45': ["FMSZPG+2", ""],
        '46': ["FMSZPG+3", ""],
        '47': ["FMSZPG+4", ""],
        '48': ["FMSZPG+5", ""],
        '49': ["FMSZPG+6", ""],
        '4A': ["CKEY/ZCHAIN", "[800]SET WHEN GAME START KEY PRESSED /[XL]HANDLER LOADER TEMP"],
        '4B': ["CASSBT/ZCHAIN+1", "[800]CASSETTE BOOT FLAG /[XL]HANDLER LOADER TEMP"],
        '4C': ["DSTAT", "DISPLAY STATUS"],
        '4D': ["ATRACT", "ATTRACT MODE FLAG"],
        '4E': ["DRKMSK", "DARK ATTRACT MASK"],
        '4F': ["COLRSH", "ATTRACT COLOR SHIFTER (XORED WITH PLAYFIELD)"],
        '50': ["TMPCHR", "TEMP CHAR STORAGE (DISPLAY HANDLER)"],
        '51': ["HOLD1", "TEMP STG (DISPLAY HANDLER)"],
        '52': ["LMARGN", "SCREEN LEFT MARGIN"],
        '53': ["RMARGN", "SCREEN RIGHT MARGIN"],
        '54': ["ROWCRS", "CURSOR COUNTERS (CURSOR ROW)"],
        '55': ["COLCRS", "CURSOR COUNTERS (CURSOR COLUMN), 2 BYTES"],
        '56': ["COLCRS+1", ""],
        '57': ["DINDEX", "DISPLAY INDEX (VARIOUS QUANTS)"],
        '58': ["SAVMSC", "SCREEN ADDRESS"],
        '59': ["SAVMSC+1", ""],
        '5A': ["OLDROW", "PREVIOUS ROW/COL (CURSOR BEFORE DRAW OR FILL)"],
        '5B': ["OLDCOL", ""],
        '5C': ["OLDCOL+1", ""],
        '5D': ["OLDCHR", "DATA UNDER CURSOR"],
        '5E': ["OLDADR", "CURSOR ADDRESS"],
        '5F': ["OLDADR+1", ""],
        '60': ["NEWROW/FKDEF", "[800]DRAWTO ROW DESTINATION /[XL]FUNCTION KEY POINTER"],
        '61': ["NEWCOL/FKDEF+1", "[800]DRAWTO COL DESTINATION /[XL]FUNCTION KEY POINTER"],
        '62': ["NEWCOL+1/PALNTS", "[800]DRAWTO COL DESTINATION /[XL]EUROPE/US TV FLAG"],
        '63': ["LOGCOL", "POINTS AT COLUMN IN LOGICAL LINE"],
        '64': ["ADRESS", "INDIRECT POINTER"],
        '65': ["ADRESS+1", ""],
        '66': ["MLTTMP", "MULTIPLY TEMP"],
        '67': ["TOADR+1", ""],
        '68': ["SAVADR", ""],
        '69': ["SAVADR+1", ""],
        '6A': ["RAMTOP", "RAM SIZE +1 DEFINED BY POWERON LOGIC (HIGH BYTE)"],
        '6B': ["BUFCNT", "BUFFER COUNT"],
        '6C': ["BUFSTR", "EDITOR GETCH POINTER"],
        '6D': ["BUFSTR+1", ""],
        '6E': ["BITMSK", "BIT MASK"],
        '6F': ["SHFAMT", "OUTCHR SHIFT"],
        '70': ["ROWAC", "USED BY \"DRAW\" 11 BYTES"],
        '71': ["ROWAC+1", ""],
        '72': ["COLAC", ""],
        '73': ["COLAC+1", ""],
        '74': ["ENDPT", ""],
        '75': ["ENDPT+1", ""],
        '76': ["DELTAR", ""],
        '77': ["DELTAC", ""],
        '78': ["DELTAC+1", ""],
        '79': ["ROWINC/KEYDEF", "[800] ROW /[XL]KEY DEFINITION POINTER"], //KEYDEF = 0x0079,	// XL/XE
        '7A': ["COLINC/KEYDEF+1", "[800] COL /[XL]KEY DEFINITION POINTER+1"],
        '7B': ["SWPFLG", "NON-0 IF TXT AND RAM SWAPPED"],
        '7C': ["HOLDCH", "CH BEFORE CNTL & SHFT PROCESSING IN KGETCH"],
        '7D': ["INSDAT", "INSERT CHAR SAVE"],
        '7E': ["COUNTR", "DRAW COUNTER"],
        '7F': ["COUNTR+1", ""],
        //$80 TO $FF ARE RESERVED FOR USER APPLICATION
        //ZROFRE = $80-D3 ; FREE ZERO PAGE, OR 84 BYTES USED BY BASIC
        '80': ["LOMEM", "BASIC POINTER TO LOW MEMORY"],
        '81': ["LOMEM+1", ""],
        '82': ["VNTP", "BASIC VARIABLE NAME TABLE"],
        '83': ["VNTP+1", ""],
        '84': ["VNTD", "BASIC VARIABLE NAME TABLE END"],
        '85': ["VNTD+1", ""],
        '86': ["VVTP", "BASIC VARIABLE VALUE TABLE"],
        '87': ["VVTP+1", ""],
        '88': ["STMTAB", "BASIC STATEMENT TABLE"],
        '89': ["STMTAB+1", ""],
        '8A': ["STMCUR", "BASIC CURRENT STATEMENT POINTER"],
        '8B': ["STMCUR+1", ""],
        '8C': ["STARP", "BASIC STRING AND ARRAY POINTER"],
        '8D': ["STARP+1", ""],
        '8E': ["RUNSTK", "BASIC RUNTIME STACK"],
        '8F': ["RUNSTK+1", ""],
        '90': ["MEMTOP", "BASIC TOP OF MEMORY"],
        '91': ["MEMTOP+1", ""],
        '92': ["MEOLFLG", ""],
        '94': ["COX", ""],
        '95': ["POKADR", ""],
        '96': ["POKADR+1", ""],
        '97': ["SVESA", ""],
        '98': ["SVESA+1", ""],
        '99': ["MVFA", ""],
        '9A': ["MVFA+1", ""],
        '9B': ["MVTA", ""],
        '9C': ["MVTA+1", ""],
        '9D': ["CPC", ""],
        '9E': ["CPC+1", ""],
        '9F': ["LLNGTH", ""],
        'A0': ["TSLNUM", ""],
        'A1': ["TSLNUM+1", ""],
        'A2': ["MVLNG", ""],
        'A3': ["MVLNG+1", ""],
        'A4': ["ECSIZE", ""],
        'A5': ["ECSIZE+1", ""],
        'A6': ["DIRFLG", ""],
        'A7': ["STMLBD", ""],
        'A8': ["STINDEX", ""],
        'A9': ["OPSTKX", ""],
        'AA': ["ARSTKX", ""],
        'AB': ["EXSVOP", ""],
        'AC': ["EXSVPR", ""],
        'AD': ["LELNUM", ""],
        'AE': ["LELNUM+1", ""],
        'AF': ["STENUM", ""],
        'B0': ["COMCNT", ""],
        'B1': ["ADFLAG", ""],
        'B2': ["SVDISP", ""],
        'B3': ["ONLOOP", ""],
        'B4': ["ENTDTD", ""],
        'B5': ["LISTDTD", ""],
        'B6': ["DATAD", ""],
        'B7': ["DATALN", ""],
        'B8': ["DATALN+1", ""],
        'B9': ["ERRNUM", ""],
        'BA': ["STOPLN", ""],
        'BB': ["STOPLN+1", ""],
        'BC': ["TRAPLN", ""],
        'BD': ["TRAPLN+1", ""],
        'BE': ["SAVCUR", ""],
        'BF': ["SAVCUR+1", ""],
        'C0': ["IOCMD", ""],
        'C1': ["IODVC", ""],
        'C2': ["PROMPT", ""],
        'C3': ["ERRSAV", ""],
        'C4': ["TEMPA", ""],
        'C5': ["TEMPA+1", ""],
        'C6': ["ZTEMP2", ""],
        'C7': ["ZTEMP2+1", ""],
        'C8': ["COLOR", ""],
        'C9': ["PTABW", ""],
        'CA': ["LOADFLG", ""],
        'D2': ["VTYPE", ""],
        'D3': ["VNUM", ""],
        //FPZRO  = $D4-$FF ; FLOATING POINT RAM, 43 BYTES
        'D4': ["FR0", "FP REGISTER 0 (6 BYTES)"],
        'D5': ["FR0+1", ""],
        'D6': ["FR0+2", ""],
        'D7': ["FR0+3", ""],
        'D8': ["FR0+4", ""],
        'D9': ["FR0+5", ""],
        'DA': ["FRE", "FP REGISTER EXP (6 BYTES)"],
        'DB': ["FRE+1", ""],
        'DC': ["FRE+2", ""],
        'DD': ["FRE+3", ""],
        'DE': ["FRE+4", ""],
        'DF': ["FRE+5", ""],
        'E0': ["FR1", "FP REGISTER 1 (6 BYTES)"],
        'E1': ["FR1+1", ""],
        'E2': ["FR1+2", ""],
        'E3': ["FR1+3", ""],
        'E4': ["FR1+4", ""],
        'E5': ["FR1+5", ""],
        'E6': ["FR2", "FP REGISTER 2 (6 BYTES)"],
        'E7': ["FR2+1", ""],
        'E8': ["FR2+2", ""],
        'E9': ["FR2+3", ""],
        'EA': ["FR2+4", ""],
        'EB': ["FR2+5", ""],
        'EC': ["FRX", "SPARE"],
        'ED': ["EEXP", "VALUE OF E"],
        'EE': ["NSIGN", "SIGN OF FP NUMBER"],
        'EF': ["ESIGN", "SIGN OF FP EXPONENT"],
        'F0': ["FCHRFLG", "FIRST CHARACTER FLAG"],
        'F1': ["DIGRT", "NUMBER OF DIGITS RIGHT OF DECIMAL POINT"],
        'F2': ["CIX", "INPUT INDEX"],
        'F3': ["INBUFF", "POINTER TO ASCII FP NUMBER"],
        'F4': ["INBUFF+1", ""],
        'F5': ["ZTEMP1", ""],
        'F6': ["ZTEMP1+1", ""],
        'F7': ["ZTEMP4", ""],
        'F8': ["ZTEMP4+1", ""],
        'F9': ["ZTEMP3", ""],
        'FA': ["ZTEMP3+1", ""],
        'FB': ["RADFLG", "0=RADIANS, 6=DEGREES"],
        'FC': ["FLPTR", "POINTER TO BCD FP NUMBER"],
        'FD': ["FLPTR+1", ""],
        'FE': ["FPTR2", ""],
        'FF': ["FPTR2+1", ""]
    }
    var _A800syms = {
        //PAGE 1 $100-1FF = 6502C CPU STACK
        '0100': ["STACK", "6502C CPU STACK (256 BYTES UP TO $1FF)"],
        //PAGE 2 $200-2FF
        //INTABS   =$200-232 ;INTERRUPT TABLE
        '0200': ["VDSLST", "DISPLAY LIST NMI VECTOR"],
        '0201': ["VDSLST+1", ""],
        '0202': ["VPRCED", "PROCEED LINE IRQ VECTOR"],
        '0203': ["VPRCED+1", ""],
        '0204': ["VINTER", "INTERRUPT LINE IRQ VECTOR"],
        '0205': ["VINTER+1", ""],
        '0206': ["VBREAK", "\"BRK\" VECTOR"],
        '0207': ["VBREAK+1", ""],
        '0208': ["VKEYBD", "POKEY KEYBOARD IRQ VECTOR"],
        '0209': ["VKEYBD+1", ""],
        '020A': ["VSERIN", "POKEY SERIAL INPUT READY"],
        '020B': ["VSERIN+1", ""],
        '020C': ["VSEROR", "POKEY SERIAL OUTPUT READY"],
        '020D': ["VSEROR+1", ""],
        '020E': ["VSEROC", "POKEY SERIAL OUTPUT DONE"],
        '020F': ["VSEROC+1", ""],
        '0210': ["VTIMR1", "POKEY TIMER 1 IRQ"],
        '0211': ["VTIMR1+1", ""],
        '0212': ["VTIMR2", "POKEY TIMER 2 IRQ"],
        '0213': ["VTIMR2+1", ""],
        '0214': ["VTIMR4", "POKEY TIMER 4 IRQ (DO NOT USE)"],
        '0215': ["VTIMR4+1", ""],
        '0216': ["VIMIRQ", "IMMEDIATE IRQ VECTOR"],
        '0217': ["VIMIRQ+1", ""],
        '0218': ["CDTMV1", "COUNT DOWN TIMER 1"],
        '0219': ["CDTMV1+1", ""],
        '021A': ["CDTMV1", "COUNT DOWN TIMER 2"],
        '021B': ["CDTMV2+1", ""],
        '021C': ["CDTMV1", "COUNT DOWN TIMER 3"],
        '021D': ["CDTMV3+1", ""],
        '021E': ["CDTMV1", "COUNT DOWN TIMER 4"],
        '021F': ["CDTMV4+1", ""],
        '0220': ["CDTMV1", "COUNT DOWN TIMER 5"],
        '0221': ["CDTMV5+1", ""],
        '0222': ["VVBLKI", "IMMEDIATE VERTICAL BLANK NMI VECTOR"],
        '0223': ["VVBLKI+1", ""],
        '0224': ["VVBLKD", "DEFERRED VERTICAL BLANK NMI VECTOR"],
        '0225': ["VVBLKD+1", ""],
        '0226': ["CDTMA1", "COUNT DOWN TIMER 1 JSR ADDRESS"],
        '0227': ["CDTMA1+1", ""],
        '0228': ["CDTMA2", "COUNT DOWN TIMER 2 JSR ADDRESS"],
        '0229': ["CDTMA2+1", ""],
        '022A': ["CDTMF3", "COUNT DOWN TIMER 3 FLAG"],
        '022B': ["SRTIMR", "SOFTWARE REPEAT TIMER"],
        '022C': ["CDTMF4", "COUNT DOWN TIMER 4 FLAG"],
        '022D': ["INTEMP", "IAN'S TEMP (???)"],
        '022E': ["CDTMF5", "COUNT DOWN TIMER 5 FLAG"],
        '022F': ["SDMCTL", "SAVE DMACTL REGISTER (DMACTL SHADOW)"],
        '0230': ["SDLSTL", "SAVE DISPLAY LIST (DL SHADOW)(LOW)"],
        '0231': ["SDLSTH", "SAVE DISPLAY LIST (DL SHADOW)(HIGH)"],
        '0232': ["SSKCTL", "SKCTL REGISTER RAM"],
        '0233': ["LCOUNT", "[XL]LOADER TEMP"],
        '0234': ["LPENH", "LIGHT PEN HORIZ VALUE"],
        '0235': ["LPENV", "LIGHT PEN VERT VALUE"],
        //[400/800] $236 - $239 SPARE
        '0236': ["BRKKY", "[XL]BREAK KEY VECTOR"],
        '0237': ["BRKKY+1", "[XL]BREAK KEY VECTOR"],
        '0238': ["VPIRQ/RELADR", "[XL]LOADER"],
        '0239': ["VPIRQ+1/RELADR+1", "[XL]LOADER"],
        '023A': ["CDEVIC", "COMMAND FRAME BUFFER - DEVICE"],
        '023B': ["CCOMND", "COMMAND"],
        '023C': ["CAUX1", "COMMAND AUX BYTE 1"],
        '023D': ["CAUX2", "COMMAND AUX BYTE 2"],
        '023E': ["TEMP", "TEMPORARY STORAGE"],
        '023F': ["ERRFLG", "ERROR FLAG (ANY DEVICE ERROR EXCEPT TIMEOUT)"],
        '0240': ["DFLAGS", "DISK FLAGS FROM BOOT SECTOR ONE (BYTE#00)"],
        '0241': ["DBSECT", "NUMBER OF DISK BOOT SECTORS (BYTE#01)"],
        '0242': ["BOOTAD", "LOW ADDRESS FOR DISK BOOT LOADER (BYTE#02)"],
        '0243': ["BOOTAD+1", "HIGH ADDRESS FOR DISK BOOT LOADER (BYTE#03)"],
        '0244': ["COLDST", "COLDSTART FLAG (1 = DOING COLDSTART)"],
        '0245': ["RECLEN", "[XL]LOADER"],
        '0246': ["DSKTIM", "[800]DISK TIME OUT REG"],
        //[XL] $246-26E 39 BYTES RESERVED
        '0247': ["LINBUF/PDVMSK", "[800]CHAR LINE BUFFER (40 BYTES UP TO $26E) /[XL]PDVMSK"],
        '0248': ["SHPDVS", "[XL]"],
        '0249': ["PDMSK", "[XL]"],
        '024A': ["RELADR", "[XL]"],
        '024B': ["RELADR+1", "[XL]"],
        '024C': ["PPTMPA", "[XL]"],
        '024D': ["PPTMPX", "[XL]"],
        '026B': ["CHSALT", "[XL]CHARACTER SET POINTER"],
        '026C': ["VSFLAG", "[XL]FINE SCROLL TEMPORARY"],
        '026D': ["KEYDIS", "[XL]KEYBOARD DISABLE"],
        '026E': ["FINE", "[XL]FINE SCROLL FLAG"],
        '026F': ["GPRIOR", "GLOBAL PRIORITY CELL (P-M PRIORITY AND GTIA MODES)"],
        //[XL] 3 MORE PADDLES, (800) 6 MORE PADDLE
        '0270': ["PADDL0", "POT 0 SHADOW"],
        '0271': ["PADDL1", "POT 1 SHADOW"],
        '0272': ["PADDL2", "POT 2 SHADOW"],
        '0273': ["PADDL3", "POT 3 SHADOW"],
        '0274': ["PADDL4", "POT 4 SHADOW"],
        '0275': ["PADDL5", "POT 5 SHADOW"],
        '0276': ["PADDL6", "POT 6 SHADOW"],
        '0277': ["PADDL7", "POT 7 SHADOW"],
        //[XL] 1 MORE STICK, (800) 3 MORE STICKS
        '0278': ["STICK0", "JOYSTICK 0 SHADOW"],
        '0279': ["STICK1", "JOYSTICK 1 SHADOW"],
        '027A': ["STICK2", "JOYSTICK 2 SHADOW"],
        '027B': ["STICK3", "JOYSTICK 3 SHADOW"],
        //[XL] 3 MORE PADDLE TRIGGERS, (800) 6 MOR
        '027C': ["PTRIG0", "PADDLE 0 TRIGGER"],
        '027D': ["PTRIG1", "PADDLE 1 TRIGGER"],
        '027E': ["PTRIG2", "PADDLE 2 TRIGGER"],
        '027F': ["PTRIG3", "PADDLE 3 TRIGGER"],
        '0280': ["PTRIG4", "PADDLE 4 TRIGGER"],
        '0281': ["PTRIG5", "PADDLE 5 TRIGGER"],
        '0282': ["PTRIG6", "PADDLE 6 TRIGGER"],
        '0283': ["PTRIG7", "PADDLE 7 TRIGGER"],
        //[XL] 1 MORE STICK TRIGGER, (800) 3 MORE
        '0284': ["STRIG0", "JOYSTICK 0 TRIGGER"],
        '0285': ["STRIG1", "JOYSTICK 1 TRIGGER"],
        '0286': ["STRIG2", "JOYSTICK 2 TRIGGER"],
        '0287': ["STRIG3", "JOYSTICK 3 TRIGGER"],
        '0288': ["CSTAT", "[800](UNUSED)"],
        '0289': ["WMODE", "R/W FLAG FOR CASSETTE"],
        '028A': ["BLIM", "BUFFER LIMIT (CASSETTE)"],
        //[400/800] $28B - $28F SPARE
        '028B': ["IMASK", "[XL]"],
        '028C': ["JVECK", "[XL]"],
        '028D': ["JVECK+1", "[XL]"],
        '028E': ["NEWADR", "[XL]LOADER RAM"],
        '028F': ["NEWADR+1", "[XL]LOADER RAM"],
        '0290': ["TXTROW", "TEXT ROWCRS"],
        '0291': ["TXTCOL", "TEXT ROWCOL"],
        '0292': ["TXTCOL+1", ""],
        '0293': ["TINDEX", "TEXT INDEX"],
        '0294': ["TXTMSC", "FOOLS CONVRT INTO NEW MSC"],
        '0295': ["TXTMSC+1", ""],
        '0296': ["TXTOLD", "OLDROW AND OLDCOL FOR TEXT (AND THEN SOME)"],
        '0297': ["TXTOLD+1", ""],
        '0298': ["TXTOLD+2", ""],
        '0299': ["TXTOLD+3", ""],
        '029A': ["TXTOLD+4", ""],
        '029B': ["TXTOLD+5", ""],
        '029C': ["TMPX1/CRETRY", " /[XL]NUMBER OF COMMAND FRAME RETRIES"],
        '029D': ["HOLD3", ""],
        '029E': ["SUBTMP", ""],
        '029F': ["HOLD2", ""],
        '02A0': ["DMASK", ""],
        '02A1': ["TMPLBT", ""],
        '02A2': ["ESCFLG", "ESCAPE FLAG"],
        '02A3': ["TABMAP", "TAB BUFFER 15 (BYTE BIT MAP FOR TAB SETTINGS)"],
        '02A4': ["TABMAP+1", ""],
        '02A5': ["TABMAP+2", ""],
        '02A6': ["TABMAP+3", ""],
        '02A7': ["TABMAP+4", ""],
        '02A8': ["TABMAP+5", ""],
        '02A9': ["TABMAP+6", ""],
        '02AA': ["TABMAP+7", ""],
        '02AB': ["TABMAP+8", ""],
        '02AC': ["TABMAP+9", ""],
        '02AD': ["TABMAP+A", ""],
        '02AE': ["TABMAP+B", ""],
        '02AF': ["TABMAP+C", ""],
        '02B0': ["TABMAP+D", ""],
        '02B1': ["TABMAP+E", ""],
        '02B2': ["LOGMAP", "LOGICAL LINE START BIT MAP (4 BYTES)"],
        '02B3': ["LOGMAP+1", ""],
        '02B4': ["LOGMAP+2", ""],
        '02B5': ["LOGMAP+3", ""],
        '02B6': ["INVFLG", "INVERSE VIDEO FLAG (ATARI KEY)"],
        '02B7': ["FILFLG", "RIGHT FILL FLAG FOR DRAW (FILL DIRING DRAW FLAG)"],
        '02B8': ["TMPROW", ""],
        '02B9': ["TMPCOL", ""],
        '02BA': ["TMPCOL+1", ""],
        '02BB': ["SCRFLG", "SET IF SCROLL OCCURS"],
        '02BC': ["HOLD4", "MORE DRAW TEMPS"],
        '02BD': ["HOLD5/DRETRY", "/[XL] NUMBER OF DEVICE RETRIES"],
        '02BE': ["SHFLOK", "SHIFT LOCK KEY"],
        '02BF': ["BOTSCR", "BOTTOM OF SCREEN (24 NORM, 4 SPLIT)"],
        '02C0': ["PCOLR0", "P0 COLOR"],
        '02C1': ["PCOLR1", "P1 COLOR"],
        '02C2': ["PCOLR2", "P2 COLOR"],
        '02C3': ["PCOLR3", "P3 COLOR"],
        '02C4': ["COLOR0", "COLOR 0"],
        '02C5': ["COLOR1", "COLOR 1"],
        '02C6': ["COLOR2", "COLOR 2"],
        '02C7': ["COLOR3", "COLOR 3"],
        '02C8': ["COLOR4", "BACKGROUND COLOR"],
        //[400/800] $2C9 - $2DF SPARE
        '02C9': ["RUNADR", "[XL]LOADER VECTOR"],
        '02CA': ["RUNADR+1", "[XL]LOADER VECTOR"],
        '02CB': ["HIUSED", "[XL]LOADER VECTOR"],
        '02CC': ["HIUSED+1", "[XL]LOADER VECTOR"],
        '02CD': ["ZHIUSE", "[XL]LOADER VECTOR"],
        '02CE': ["ZHIUSE+1", "[XL]LOADER VECTOR"],
        '02CF': ["GBYTEA", "[XL]LOADER VECTOR"],
        '02D0': ["GBYTEA+1", "[XL]LOADER VECTOR"],
        '02D1': ["LOADAD", "[XL]LOADER VECTOR"],
        '02D2': ["LOADAD+1", "[XL]LOADER VECTOR"],
        '02D3': ["ZLOADA", "[XL]LOADER VECTOR"],
        '02D4': ["ZLOADA+1", "[XL]LOADER VECTOR"],
        '02D5': ["DSCTLN", "[XL]LOADER VECTOR"],
        '02D6': ["DSCTLN+1", "[XL]LOADER VECTOR"],
        '02D7': ["ACMISR", "[XL]RESERVED"],
        '02D8': ["ACMISR+1", "[XL]RESERVED"],
        '02D9': ["KRPDEL", "[XL]KEY AUTO REPEAT DELAY"],
        '02DA': ["KEYREP", "[XL]KEY AUTO REPEAT RATE"],
        '02DB': ["NOCLIK", "[XL]KEY CLICK DISABLE"],
        '02DC': ["HELPFG", "[XL]HELP KEY FLAG"],
        '02DD': ["DMASAV", "[XL]SDMCTL (DMA) SAVE"],
        '02DE': ["PBPNT", "[XL]PRINTER BUFFER POINTER"],
        '02DF': ["PBUFSZ", "[XL]PRINTER BUFFER SIZE"],
        //[400/800] $2E0 - $2E3 SPARE
        '02E0': ["RUNAD", "DOS FILE RUN ADDRESS"],
        '02E1': ["RUNAD+1", ""],
        '02E2': ["INITAD", "DOS FILE INIT ADDRESS"],
        '02E3': ["INITAD+1", ""],
        '02E4': ["RAMSIZ", "RAM SIZE (HI BYTE ONLY)"],
        '02E5': ["MEMTOP", "TOP OF AVAILABLE MEMORY (END OF FREE RAM)"],
        '02E6': ["MEMTOP+1", ""],
        '02E7': ["MEMLO", "BOTTOM OF AVAILABLE MEMORY"],
        '02E8': ["MEMLO+1", ""],
        '02E9': ["HNDLOD", "[XL]HANDLER LOADER FLAG"],
        '02EA': ["DVSTAT", "STATUS BUFFER (4 BYTES)"],
        '02EB': ["DVSTAT+1", ""],
        '02EC': ["DVSTAT+2", ""],
        '02ED': ["DVSTAT+3", ""],
        '02EE': ["CBAUDL", "CASSETTE BAUD RATE (LO BYTE)"],
        '02EF': ["CBAUDH", "CASSETTE BAUD RATE (HI BYTE)"],
        '02F0': ["CRSINH", "CURSOR INHIBIT (0 = ON, 1 = INHIBIT)"],
        '02F1': ["KEYDEL", "KEY DELAY AND RATE"],
        '02F2': ["CH1", ""],
        '02F3': ["CHACT", "CHACTL REGISTER (SHADOW)"],
        '02F4': ["CHBAS", "CHBAS REGISTER (CHARACTER SET POINTER)(SHADOW)"],
        //[400/800] $2F5 - $2F9 SPARE
        '02F5': ["NEWROW", "[XL]DRAW DESTINATION"],
        '02F6': ["NEWCOL", "[XL]DRAW DESTINATION"],
        '02F7': ["NEWCOL+1", "[XL]DRAW DESTINATION"],
        '02F8': ["ROWINC", "[XL]"],
        '02F9': ["COLINC", "[XL]"],
        '02FA': ["CHAR", ""],
        '02FB': ["ATACHR", "ATASCII CHARACTER FOR CIO"],
        '02FC': ["CH", "GLOBAL VARIABLE FOR KEYBOARD"],
        '02FD': ["FILDAT", "RIGHT FILL DATA (DRAW)(COLOR FOR SCREEN FILL)"],
        '02FE': ["DSPFLG", "DISPLAY CONTROL CHAR FLAG IF NON-ZERO"],
        '02FF': ["SSFLAG", "DISPLAY START/STOP FLAG (CNTL-1) FOR PAGING"],
        //PAGE 3 $300-3FF RESIDENT DISK HANDLER/SIO INTERFACE
        //DCB = $0300 DEVICE CONTROL BLOCK
        '0300': ["DDEVIC", "BUS I.D. NUMBER"],
        '0301': ["DUNIT", "UNIT NUMBER"],
        '0302': ["DCOMND", "BUS COMMAND"],
        '0303': ["DSTATS", "COMMAND TYPE/STATUS RETURN"],
        '0304': ["DBUFLO", "DATA BUFFER POINTER (LO BYTE ADDR)"],
        '0305': ["DBUFHI", "DATA BUFFER POINTER (HI BYTE ADDR)"],
        '0306': ["DTIMLO", "DEVICE TIME OUT IN 1 SEC. UNITS"],
        '0307': ["DUNUSE", "UNUSED"],
        '0308': ["DBYTLO", "BYTE COUNT (SECTOR SIZE)(LO BYTE)"],
        '0309': ["DBYTHI", "BYTE COUNT (SECTOR SIZE)(HI BYTE)"],
        '030A': ["DAUX1", "COMMAND AUXILLARY BYTES (NBR OF SECTOR)(LO BYTE)"],
        '030B': ["DAUX2", "COMMAND AUXILLARY BYTES (NBR OF SECTOR)(HI BYTE)"],
        '030C': ["TIMER1", "INITIAL TIMER VALUE"],
        '030D': ["TIMER1+1", ""],
        '030E': ["ADDCOR/JMPERS", "[800]ADDITION CORRECTION /[XE]OPTION JUMPERS"],
        '030F': ["CASFLG", "CASSETTE MODE WHEN SET"],
        '0310': ["TIMER2", "FINAL TIME VALUE (USED TO COMPUTE BAUD RATE)"],
        '0311': ["TIMER2+1", ""],
        '0312': ["TEMP1", "TEMP LOCATION"],
        '0313': ["TEMP1+1/TEMP2", "TEMP LOCATION"],
        '0314': ["TEMP2/PTIMOT", "[800]TEMP2 /[XL]PRINTER TIME OUT"],
        '0315': ["TEMP3", ""],
        '0316': ["SAVIO", "SAVE SERIAL IN DATA PORT"],
        '0317': ["TIMFLG", "TIME OUT FLAG FOR BAUD RATE CORRECTION"],
        '0318': ["STACKP", "SIO STACK POINTER SAVE LOC"],
        '0319': ["TSTAT", "TEMP STATUS LOC"],
        '031A': ["HATABS", "HANDLER ADDRESS TABLE (38 BYTES UP TO $33F)"],
        '0321': ["MAXDEV", "MAXIMUM HANDLER ADDRESS INDEX"],
        '033D': ["PUPBT1", "[XL]POWER-UP/RESET"],
        '033E': ["PUPBT2", "[XL]POWER-UP/RESET"],
        '033F': ["PUPBT3", "[XL]POWER-UP/RESET"],
        //IOCB OFFSETS
        '0340': ["IOCB0", "ICHID I/O CONTROL BLOCK 0"],
        '0341': ["ICDNO", "DEVICE NUMBER (DRIVE NUMBER)"],
        '0342': ["ICCOM", "ICCMD COMMAND CODE"],
        '0343': ["ICSTA", "STATUS"],
        '0344': ["ICBAL", "BUFFER ADDRESS"],
        '0345': ["ICBAH", "..."],
        '0346': ["ICPTL", "PUT BYTE ROUTINE ADDRESS - 1"],
        '0347': ["ICPTH", "..."],
        '0348': ["ICBLL", "BUFFER LENGTH"],
        '0349': ["ICBLH", "..."],
        '034A': ["ICAX1", "AUXILLARY INFO"],
        '034B': ["ICAX2", "..."],
        '034C': ["ICSPR", "ICAX3 4 SPARE BYTES"],
        '034D': ["B0-ICAX4", ""],
        '034E': ["B0-ICAX5", ""],
        '034F': ["B0-ICAX6", ""],
        '0350': ["IOCB1", "I/O CONTROL BLOCK 1"],
        '0351': ["B1-ICDNO", ""],
        '0352': ["B1-ICCOM", ""],
        '0353': ["B1-ICSTA", ""],
        '0354': ["B1-ICBAL", ""],
        '0355': ["B1-ICBAH", ""],
        '0356': ["B1-ICPTL", ""],
        '0357': ["B1-ICPTH", ""],
        '0358': ["B1-ICBLL", ""],
        '0359': ["B1-ICBLH", ""],
        '035A': ["B1-ICAX1", ""],
        '035B': ["B1-ICAX2", ""],
        '035C': ["B1-ICAX3", ""],
        '035D': ["B1-ICAX4", ""],
        '035E': ["B1-ICAX5", ""],
        '035F': ["B1-ICAX6", ""],
        '0360': ["IOCB2", "I/O CONTROL BLOCK 2"],
        '0361': ["B2-ICDNO", ""],
        '0362': ["B2-ICCOM", ""],
        '0363': ["B2-ICSTA", ""],
        '0364': ["B2-ICBAL", ""],
        '0365': ["B2-ICBAH", ""],
        '0366': ["B2-ICPTL", ""],
        '0367': ["B2-ICPTH", ""],
        '0368': ["B2-ICBLL", ""],
        '0369': ["B2-ICBLH", ""],
        '036A': ["B2-ICAX1", ""],
        '036B': ["B2-ICAX2", ""],
        '036C': ["B2-ICAX3", ""],
        '036D': ["B2-ICAX4", ""],
        '036E': ["B2-ICAX5", ""],
        '036F': ["B2-ICAX6", ""],
        '0370': ["IOCB3", "I/O CONTROL BLOCK 3"],
        '0371': ["B3-ICDNO", ""],
        '0372': ["B3-ICCOM", ""],
        '0373': ["B3-ICSTA", ""],
        '0374': ["B3-ICBAL", ""],
        '0375': ["B3-ICBAH", ""],
        '0376': ["B3-ICPTL", ""],
        '0377': ["B3-ICPTH", ""],
        '0378': ["B3-ICBLL", ""],
        '0379': ["B3-ICBLH", ""],
        '037A': ["B3-ICAX1", ""],
        '037B': ["B3-ICAX2", ""],
        '037C': ["B3-ICAX3", ""],
        '037D': ["B3-ICAX4", ""],
        '037E': ["B3-ICAX5", ""],
        '037F': ["B3-ICAX6", ""],
        '0380': ["IOCB4", "I/O CONTROL BLOCK 4"],
        '0381': ["B4-ICDNO", ""],
        '0382': ["B4-ICCOM", ""],
        '0383': ["B4-ICSTA", ""],
        '0384': ["B4-ICBAL", ""],
        '0385': ["B4-ICBAH", ""],
        '0386': ["B4-ICPTL", ""],
        '0387': ["B4-ICPTH", ""],
        '0388': ["B4-ICBLL", ""],
        '0389': ["B4-ICBLH", ""],
        '038A': ["B4-ICAX1", ""],
        '038B': ["B4-ICAX2", ""],
        '038C': ["B4-ICAX3", ""],
        '038D': ["B4-ICAX4", ""],
        '038E': ["B4-ICAX5", ""],
        '038F': ["B4-ICAX6", ""],
        '0390': ["IOCB5", "I/O CONTROL BLOCK 5"],
        '0391': ["B5-ICDNO", ""],
        '0392': ["B5-ICCOM", ""],
        '0393': ["B5-ICSTA", ""],
        '0394': ["B5-ICBAL", ""],
        '0395': ["B5-ICBAH", ""],
        '0396': ["B5-ICPTL", ""],
        '0397': ["B5-ICPTH", ""],
        '0398': ["B5-ICBLL", ""],
        '0399': ["B5-ICBLH", ""],
        '039A': ["B5-ICAX1", ""],
        '039B': ["B5-ICAX2", ""],
        '039C': ["B5-ICAX3", ""],
        '039D': ["B5-ICAX4", ""],
        '039E': ["B5-ICAX5", ""],
        '039F': ["B5-ICAX6", ""],
        '03A0': ["IOCB6", "I/O CONTROL BLOCK 6"],
        '03A1': ["B6-ICDNO", ""],
        '03A2': ["B6-ICCOM", ""],
        '03A3': ["B6-ICSTA", ""],
        '03A4': ["B6-ICBAL", ""],
        '03A5': ["B6-ICBAH", ""],
        '03A6': ["B6-ICPTL", ""],
        '03A7': ["B6-ICPTH", ""],
        '03A8': ["B6-ICBLL", ""],
        '03A9': ["B6-ICBLH", ""],
        '03AA': ["B6-ICAX1", ""],
        '03AB': ["B6-ICAX2", ""],
        '03AC': ["B6-ICAX3", ""],
        '03AD': ["B6-ICAX4", ""],
        '03AE': ["B6-ICAX5", ""],
        '03AF': ["B6-ICAX6", ""],
        '03B0': ["IOCB7", "I/O CONTROL BLOCK 7"],
        '03B1': ["B7-ICDNO", ""],
        '03B2': ["B7-ICCOM", ""],
        '03B3': ["B7-ICSTA", ""],
        '03B4': ["B7-ICBAL", ""],
        '03B5': ["B7-ICBAH", ""],
        '03B6': ["B7-ICPTL", ""],
        '03B7': ["B7-ICPTH", ""],
        '03B8': ["B7-ICBLL", ""],
        '03B9': ["B7-ICBLH", ""],
        '03BA': ["B7-ICAX1", ""],
        '03BB': ["B7-ICAX2", ""],
        '03BC': ["B7-ICAX3", ""],
        '03BD': ["B7-ICAX4", ""],
        '03BE': ["B7-ICAX5", ""],
        '03BF': ["B7-ICAX6", ""],
        '03C0': ["PRNBUF", "PRINTER BUFFER (42 BYTES UP TO $3E9)"],
        '03E8': ["SUPERF", "[XL]SCREEN EDITOR"],
        '03E9': ["CKEY", "[XL]START KEY FLAG"],
        //[400/800] $3EA - $3FC SPARE
        '03EA': ["CASSBT", "[XL]CASSETTE BOOT FLAG"],
        '03EB': ["CARTCK", "[XL]CARTRIDGE CHECKSUM"],
        '03EC': ["DERRF", "[XL]"],
        '03ED': ["ACMVAR", "[XL]RESERVED, 6 BYTES"],
        '03F8': ["BASICF", "[XL]"],
        '03F9': ["MINTLK", "[XL]RESERVED"],
        '03FA': ["GINTLK", "[XL]CARTRIDGE INTERLOCK"],
        '03FB': ["CHLINK", "[XL]HANDLER CHAIN (2 BYTES)"],
        '03FC': ["CHLINK+1", "[XL]HANDLER CHAIN (2 BYTES)"],
        '03FD': ["CASBUF", "CASSETTE BUFFER (131 BYTES UP TO $47F)"],
        //USAREA $480-57F 256 BYTES AREA FOR USER
        '0580': ["LBUFF", "TEMP BUFFER (128 BYTES UP TO $5FF)"],
        //RAM ALWAYS FREE ABOVE $600
        //CART LOW (RIGHT)
        '9FFA': ["R-CARTCS", "R-CARTRIDGE COLD START ADDRESS"],
        '9FFB': ["R-CARTCS+1", "..."],
        '9FFC': ["R-CART", "R-CARTRIDGE AVAILABLE FLAG BYTE"],
        '9FFD': ["R-CARTFG", "R-CARTRIDGE FLAG BYTE"],
        '9FFE': ["R-CARTAD", "R-CARTRIDGE START VECTOR ADDRESS"],
        '9FFF': ["R-CARTAD+1", "..."],
        //CART HIGH
        'BFFA': ["CARTCS", "CARTRIDGE COLD START ADDRESS"],
        'BFFB': ["CARTCS+1", "..."],
        'BFFC': ["CART", "CARTRIDGE AVAILABLE FLAG BYTE"],
        'BFFD': ["CARTFG", "CARTRIDGE FLAG BYTE"],
        'BFFE': ["CARTAD", "CARTRIDGE START VECTOR ADDRESS"],
        'BFFF': ["CARTAD+1", "..."],
        //$C000-CFFF 4K OS ROM for XL/XE
        //$D000-D7FF is the hardware chip interface -> no RAM, nor ROM
        //NOTE : in ATARI XL/XE ROM, data from $D000 to D7FF are the diagnostic 2K ROM program, are copied in RAM at $5000-57FF when requested
        //GTIA $D000-D01F
        'D000': ["M0PF/HPOSP0", "MIS-PLAYF COLLISION(R)/P0 POSITION(W)"],
        'D001': ["M1PF/HPOSP1", "MIS-PLAYF COLLISION(R)/P1 POSITION(W)"],
        'D002': ["M2PF/HPOSP2", "MIS-PLAYF COLLISION(R)/P2 POSITION(W)"],
        'D003': ["M3PF/HPOSP3", "MIS-PLAYF COLLISION(R)/P3 POSITION(W)"],
        'D004': ["P0PF/HPOSM0", "PLAYER-PLAYF COLLISION(R)/M0 POSITION(W)"],
        'D005': ["P1PF/HPOSM1", "PLAYER-PLAYF COLLISION(R)/M1 POSITION(W)"],
        'D006': ["P2PF/HPOSM2", "PLAYER-PLAYF COLLISION(R)/M2 POSITION(W)"],
        'D007': ["P3PF/HPOSM3", "PLAYER-PLAYF COLLISION(R)/M3 POSITION(W)"],
        'D008': ["M0PL/SIZEP0", "MIS-PLAYER COLLISION(R)/P0 SIZE(W)"],
        'D009': ["M1PL/SIZEP1", "MIS-PLAYER COLLISION(R)/P1 SIZE(W)"],
        'D00A': ["M2PL/SIZEP2", "MIS-PLAYER COLLISION(R)/P2 SIZE(W)"],
        'D00B': ["M3PL/SIZEP3", "MIS-PLAYER COLLISION(R)/P3 SIZE(W)"],
        'D00C': ["P0PL/SIZEM", "PLAYER-PLAYER COLLISION(R)/MIS SIZE(W)"],
        'D00D': ["P1PL/GRAFP0", "PLAYER-PLAYER COLLISION(R)/P0 GRAPH LATCH(W)"],
        'D00E': ["P2PL/GRAFP1", "PLAYER-PLAYER COLLISION(R)/P1 GRAPH LATCH(W)"],
        'D00F': ["P3PL/GRAFP2", "PLAYER-PLAYER COLLISION(R)/P2 GRAPH LATCH(W)"],
        'D010': ["TRIG0/GRAFP3", "JOYSTK0 TRIGG(R)/P4 GRAPH LATCH(W)"],
        'D011': ["TRIG1/GRAFM", "JOYSTK1 TRIGG(R)/MISSILE GRAPH LATCH(W)"],
        'D012': ["TRIG2/COLPM0", "JOYSTK2 TRIGG(R)/PLAYER&MISS COLOR(W)"],
        'D013': ["TRIG3/COLPM1", "JOYSTK3 TRIGG(R)/PLAYER&MISS COLOR(W)"],
        'D014': ["PAL/COLPM2", "NTSC/PAL DETECT(R)/PLAYER&MISS COLOR(W)"],
        'D015': ["COLPM3", "PLAYER&MISS COLOR(W)"],
        'D016': ["COLPF0", "PALYFIELD0 COLOR(W)"],
        'D017': ["COLPF1", "PALYFIELD1 COLOR(W)"],
        'D018': ["COLPF2", "PALYFIELD2 COLOR(W)"],
        'D019': ["COLPF3", "PALYFIELD3 COLOR(W)"],
        'D01A': ["COLBK", "BACKGROUND COLOR(W)"],
        'D01B': ["PRIOR", "PRIORITY CONTROL(W)"],
        'D01C': ["VDELAY", "VERTICAL DELAY(W)"],
        'D01D': ["GRACTL", "GRAPHIC CONTROL(W)"],
        'D01E': ["HITCLR", "COLLISION CLEAR STROBE(W)"],
        'D01F': ["CONSOL", "CONSOLE SWITCHES OPTION-SELECT-START(R&W)"],
        //PBI Paralel bus interface CONTROL $D100
        'D100': ["PBI", ""],
        'D1FF': ["PDVI", ""],
        //POKEY $D200-D20F
        'D200': ["POT0/AUDF1", "PAD POT POS(R)/AUDIO CHANNEL 1 FREQ(W)"], 
        'D201': ["POT1/AUDF2", "PAD POT POS(R)/AUDIO CHANNEL 2 FREQ(W)"],
        'D202': ["POT2/AUDF3", "PAD POT POS(R)/AUDIO CHANNEL 3 FREQ(W)"],
        'D203': ["POT3/AUDF4", "PAD POT POS(R)/AUDIO CHANNEL 4 FREQ(W)"],
        'D204': ["POT4/AUDC1", "PAD POT POS(R)/AUDIO CHANNEL 1 CONTROL(W)"],
        'D205': ["POT5/AUDC2", "PAD POT POS(R)/AUDIO CHANNEL 2 CONTROL(W)"],
        'D206': ["POT6/AUDC3", "PAD POT POS(R)/AUDIO CHANNEL 3 CONTROL(W)"],
        'D207': ["POT7/AUDC4", "PAD POT POS(R)/AUDIO CHANNEL 4 CONTROL(W)"],
        'D208': ["ALLPOT/AUDCTL", "PAD DIRECTION(R)/AUDIO CONTROL(W)"],
        'D209': ["KBCODE/STIMER", "KEYB CODE(R)/START TIMER STROBE(W)"],
        'D20A': ["RANDOM/SKRES", "RANDOM(R)/SERIAL&KEYB RESET(W)"],
        'D20B': ["POTGO", "PADDLE POT READ START STROBE(W)"],
        'D20D': ["SERIN/SEROUT", "SERIAL IN(R)/SERIAL OUT(W) DATA"],
        'D20E': ["IRQST/IRQEN", "IRQ STATUS(R)/IRQ ENABLE(W)"],
        'D20F': ["SKSTAT/SKCTL", "SERIAL&KEYB STATUS(R)/SERIAL&KEYB CONTROL(W)"],
        //PIA $D300-D303
        'D300': ["PORTA", "PORT A DATA DIRECTION JOYSTICKS(R&W)"],
        'D301': ["PORTB", "PORT B DATA DIRECTION(R&W)"],
        'D302': ["PACTL", "PORT A CONTROL(R&W)"],
        'D303': ["PBCTL", "PORT B CONTROL(R&W)"],
        //ANTIC $D400-D40F
        'D400': ["DMACTL", "DMA CONTROL(W)"],
        'D401': ["CHACTL", "CHAR CONTROL(W)"],
        'D402': ["DLISTL", "DISPLAY LIST ADDRESS (LO BYTE)(W)"],
        'D403': ["DLISTH", "DISPLAY LIST ADDRESS (HI BYTE)(W)"],
        'D404': ["HSCROL", "HORIZONTAL SCROLL(W)"],
        'D405': ["VSCROL", "VERTICAL SCROLL(W)"],
        'D407': ["PMBASE", "PLAYER MISSILE BASE(W)"],
        'D409': ["CHBASE", "CHAR SET BASE(W)"],
        'D40A': ["WSYNC", "WAIT FOR H SYNC(W)"],
        'D40B': ["VCOUNT", "VERTICAL COUNT(R)"],
        'D40C': ["PENH", "PEN H POSITION(R)"],
        'D40D': ["PENV", "PEN H POSITION(R)"],
        'D40E': ["NMIEN", "NMI INTERRUPT ENABLE(W)"],
        'D40F': ["NMIST/NMIRES", "NMI STATUS(R)/NMI RESET(W)"],
        //CART CONBTROL $D500-D5FF => ROM BANK SWITCHING CONTROL
        'D500': ["BKSWITCH", "MEMORY BANK SWITCHING CONTROL"],
        //PBI CONTROL $D600-$D7FF
        'D600': ["PBIRAM", ""],
        //MATH PACK (Floating Point FP) 2K OS ROM $D800-DFFF
        'D800': ["AFP", ""],
        'D803': ["PDID1", ""],
        'D805': ["PDIOV", ""],
        'D806': ["PDIOV+1", ""],
        'D808': ["PDIRQV", ""],
        'D809': ["PDIRQV+1", ""],
        'D80B': ["PDID2", ""],
        'D80D': ["PDVV", ""],
        'D8E6': ["FASC", ""],
        'D9AA': ["IFP", ""], //IPF    = 0xD9AA,
        'D9D2': ["FPI", ""],
        'DA44': ["ZFR0", ""],
        'DA46': ["ZF1", ""],
        'DA60': ["FSUB", ""],
        'DA66': ["FADD", ""],
        'DADB': ["FMUL", ""],
        'DB28': ["FDIV", ""],
        'DD40': ["PLYEVL", ""],
        'DD89': ["FLD0R", ""],
        'DD8D': ["FLD0P", ""],
        'DD98': ["FLD1R", ""],
        'DD9C': ["FLD1P", ""],
        'DDA7': ["FST0R", ""],
        'DDAB': ["FST0P", ""],
        'DDB6': ["FMOVE", ""],
        'DDC0': ["EXP", ""],
        'DDCC': ["EXP10", ""],
        'DECD': ["LOG", ""],
        'DED1': ["LOG10", ""],
        //OS ROM 8K $E000-FFFF
        //$E000-E3FF RESIDENT CHAR SET 
        //$E400-EFFF OS ROM ROUTINES
        'E400': ["EDITRV", "EDITOR"],
        'E410': ["SCRENV", "TELEVISION SCREEN"],
        'E420': ["KEYBDV", "KEYBOARD"],
        'E430': ["PRINTV", "PRINTER"],
        'E440': ["CASETV", "CASSETTE"],
        'E450': ["DISKIV", "DISK INITIALIZATION"],
        'E453': ["DSKINV", "DISK INTERFACE"],
        'E456': ["CIOV", "CIO ROUTINE"],
        'E459': ["SIOV", "SIO ROUTINE"],
        'E45C': ["SETVBV", "SET VERTICAL BLANK VECTORS"],
        'E45F': ["SYSVBV", "SYSTEM VERTICAL BLANK ROUTINE"],
        'E462': ["XITVBV", "EXIT VERTICAL BLANK ROUTINE"],
        'E465': ["SIOINV", "SIO INIT"],
        'E468': ["SENDEV", "SEND ENABLE ROUTINE"],
        'E46B': ["INTINV", "INTERRUPT HANDLER INIT"],
        'E46E': ["CIOINV", "CIO INIT"],
        'E471': ["BLKBDV", "BLACKBOARD MODE"],
        'E474': ["WARMSV", "WARM START ENTRY POINT"],
        'E477': ["COLDSV", "COLD START ENTRY POINT"],
        'E47A': ["RBLOKV", "CASSETTE READ BLOCK VECTOR"],
        'E47D': ["CSOPIV", "CASSETTE OPEN FOR INPUT VECTOR"],
        'E480': ["VCTABL", "PUPDIV"],
        'E483': ["SLFTSV", ""],
        'E486': ["PHENTV", ""],
        'E489': ["PHUNLV", ""],
        'E48C': ["PHINIV", ""],
        'E48F': ["GPDVV", ""],
        'F385': ["PUTLIN", "OUTPUT LINE TO IOCB#0"],
        'F6A4': ["EOUTCH", "OUTPUT CHAR TO SCREEN"],
        'F6E2': ["KGETCH", "GET CHAR FROM KEYBOARD"],
        //6502 CPU RESIDENT CPU VECTORS
        'FFFA': ["NMIVEC", "NMI NON MASKABLE INTERRUPT OS ROM VECTOR"],
        'FFFB': ["NMIVEC+1", "..."],
        'FFFC': ["RESETVEC", "RESET OS ROM VECTOR"],
        'FFFD': ["RESETVEC+1", "..."],
        'FFFE': ["IRQVEC", "IRQ INTERRUPT REQUEST OS ROM VECTOR"],
        'FFFF': ["IRQVEC+1", "..."],
    }

    //===================================================================================================
    // 6502 disassembler derived from
    // n. landsteiner, mass:werk / electronic tradion 2005; e-tradion.net
    //(PVB COM) see also https://www.masswerk.at/6502/6502_instruction_set.html
    var opctab = [
        ['BRK', 'imp'], ['ORA', 'inx'], ['???', 'imp'], ['???', 'imp'], //00--03
        ['???', 'imp'], ['ORA', 'zpg'], ['ASL', 'zpg'], ['???', 'imp'], //04--07
        ['PHP', 'imp'], ['ORA', 'imm'], ['ASL', 'acc'], ['???', 'imp'], //08--0B
        ['???', 'imp'], ['ORA', 'abs'], ['ASL', 'abs'], ['???', 'imp'], //0C--0F
        //10
        ['BPL', 'rel'], ['ORA', 'iny'], ['???', 'imp'], ['???', 'imp'],
        ['???', 'imp'], ['ORA', 'zpx'], ['ASL', 'zpx'], ['???', 'imp'],
        ['CLC', 'imp'], ['ORA', 'aby'], ['???', 'imp'], ['???', 'imp'],
        ['???', 'imp'], ['ORA', 'abx'], ['ASL', 'abx'], ['???', 'imp'],
        //20
        ['JSR', 'abs'], ['AND', 'inx'], ['???', 'imp'], ['???', 'imp'],
        ['BIT', 'zpg'], ['AND', 'zpg'], ['ROL', 'zpg'], ['???', 'imp'],
        ['PLP', 'imp'], ['AND', 'imm'], ['ROL', 'acc'], ['???', 'imp'],
        ['BIT', 'abs'], ['AND', 'abs'], ['ROL', 'abs'], ['???', 'imp'],
        //30
        ['BMI', 'rel'], ['AND', 'iny'], ['???', 'imp'], ['???', 'imp'],
        ['???', 'imp'], ['AND', 'zpx'], ['ROL', 'zpx'], ['???', 'imp'],
        ['SEC', 'imp'], ['AND', 'aby'], ['???', 'imp'], ['???', 'imp'],
        ['???', 'imp'], ['AND', 'abx'], ['ROL', 'abx'], ['???', 'imp'],
        //40
        ['RTI', 'imp'], ['EOR', 'inx'], ['???', 'imp'], ['???', 'imp'],
        ['???', 'imp'], ['EOR', 'zpg'], ['LSR', 'zpg'], ['???', 'imp'],
        ['PHA', 'imp'], ['EOR', 'imm'], ['LSR', 'acc'], ['???', 'imp'],
        ['JMP', 'abs'], ['EOR', 'abs'], ['LSR', 'abs'], ['???', 'imp'],
        //50
        ['BVC', 'rel'], ['EOR', 'iny'], ['???', 'imp'], ['???', 'imp'],
        ['???', 'imp'], ['EOR', 'zpx'], ['LSR', 'zpx'], ['???', 'imp'],
        ['CLI', 'imp'], ['EOR', 'aby'], ['???', 'imp'], ['???', 'imp'],
        ['???', 'imp'], ['EOR', 'abx'], ['LSR', 'abx'], ['???', 'imp'],
        //60
        ['RTS', 'imp'], ['ADC', 'inx'], ['???', 'imp'], ['???', 'imp'],
        ['???', 'imp'], ['ADC', 'zpg'], ['ROR', 'zpg'], ['???', 'imp'],
        ['PLA', 'imp'], ['ADC', 'imm'], ['ROR', 'acc'], ['???', 'imp'],
        ['JMP', 'ind'], ['ADC', 'abs'], ['ROR', 'abs'], ['???', 'imp'],
        //70
        ['BVS', 'rel'], ['ADC', 'iny'], ['???', 'imp'], ['???', 'imp'],
        ['???', 'imp'], ['ADC', 'zpx'], ['ROR', 'zpx'], ['???', 'imp'],
        ['SEI', 'imp'], ['ADC', 'aby'], ['???', 'imp'], ['???', 'imp'],
        ['???', 'imp'], ['ADC', 'abx'], ['ROR', 'abx'], ['???', 'imp'],
        //80
        ['???', 'imp'], ['STA', 'inx'], ['???', 'imp'], ['???', 'imp'],
        ['STY', 'zpg'], ['STA', 'zpg'], ['STX', 'zpg'], ['???', 'imp'],
        ['DEY', 'imp'], ['???', 'imp'], ['TXA', 'imp'], ['???', 'imp'],
        ['STY', 'abs'], ['STA', 'abs'], ['STX', 'abs'], ['???', 'imp'],
        //90
        ['BCC', 'rel'], ['STA', 'iny'], ['???', 'imp'], ['???', 'imp'],
        ['STY', 'zpx'], ['STA', 'zpx'], ['STX', 'zpy'], ['???', 'imp'],
        ['TYA', 'imp'], ['STA', 'aby'], ['TXS', 'imp'], ['???', 'imp'],
        ['???', 'imp'], ['STA', 'abx'], ['???', 'imp'], ['???', 'imp'],
        //A0
        ['LDY', 'imm'], ['LDA', 'inx'], ['LDX', 'imm'], ['???', 'imp'],
        ['LDY', 'zpg'], ['LDA', 'zpg'], ['LDX', 'zpg'], ['???', 'imp'],
        ['TAY', 'imp'], ['LDA', 'imm'], ['TAX', 'imp'], ['???', 'imp'],
        ['LDY', 'abs'], ['LDA', 'abs'], ['LDX', 'abs'], ['???', 'imp'],
        //B0
        ['BCS', 'rel'], ['LDA', 'iny'], ['???', 'imp'], ['???', 'imp'],
        ['LDY', 'zpx'], ['LDA', 'zpx'], ['LDX', 'zpy'], ['???', 'imp'],
        ['CLV', 'imp'], ['LDA', 'aby'], ['TSX', 'imp'], ['???', 'imp'],
        ['LDY', 'abx'], ['LDA', 'abx'], ['LDX', 'aby'], ['???', 'imp'],
        //C0
        ['CPY', 'imm'], ['CMP', 'inx'], ['???', 'imp'], ['???', 'imp'],
        ['CPY', 'zpg'], ['CMP', 'zpg'], ['DEC', 'zpg'], ['???', 'imp'],
        ['INY', 'imp'], ['CMP', 'imm'], ['DEX', 'imp'], ['???', 'imp'],
        ['CPY', 'abs'], ['CMP', 'abs'], ['DEC', 'abs'], ['???', 'imp'],
        //D0
        ['BNE', 'rel'], ['CMP', 'iny'], ['???', 'imp'], ['???', 'imp'],
        ['???', 'imp'], ['CMP', 'zpx'], ['DEC', 'zpx'], ['???', 'imp'],
        ['CLD', 'imp'], ['CMP', 'aby'], ['???', 'imp'], ['???', 'imp'],
        ['???', 'imp'], ['CMP', 'abx'], ['DEC', 'abx'], ['???', 'imp'],
        //E0
        ['CPX', 'imm'], ['SBC', 'inx'], ['???', 'imp'], ['???', 'imp'],
        ['CPX', 'zpg'], ['SBC', 'zpg'], ['INC', 'zpg'], ['???', 'imp'],
        ['INX', 'imp'], ['SBC', 'imm'], ['NOP', 'imp'], ['???', 'imp'],
        ['CPX', 'abs'], ['SBC', 'abs'], ['INC', 'abs'], ['???', 'imp'],
        //F0
        ['BEQ', 'rel'], ['SBC', 'iny'], ['???', 'imp'], ['???', 'imp'],
        ['???', 'imp'], ['SBC', 'zpx'], ['INC', 'zpx'], ['???', 'imp'],
        ['SED', 'imp'], ['SBC', 'aby'], ['???', 'imp'], ['???', 'imp'],
        ['???', 'imp'], ['SBC', 'abx'], ['INC', 'abx'], ['???', 'imp']
    ];

    var addrtab = {
        acc: 'A',
        abs: 'abs',
        abx: 'abs,X',
        aby: 'abs,Y',
        imm: '#',
        imp: 'impl',
        ind: 'ind',
        inx: 'X,ind',
        iny: 'ind,Y',
        rel: 'rel',
        zpg: 'zpg',
        zpx: 'zpg,X',
        zpy: 'zpg,Y'
    }

    var steptab = { //step is the number of bytes within the instruction line
        imp: 1,
        acc: 1,
        imm: 2,
        abs: 3,
        abx: 3,
        aby: 3,
        zpg: 2,
        zpx: 2,
        zpy: 2,
        ind: 3,
        inx: 2,
        iny: 2,
        rel: 2
    };

    //(PVB ADD) disassembly and hex dump display options variables //(PVB TODO) use bits in a byte rather than global variables ?
    var _bShowDisLinks = 1; // set to show disassembly links
    var _bShowDisFlags = 0; // set to show disassembly code flags
    var _bShowDisBRK = 0; // set for up to 2 x BRK in disassembly
    var _bShowAtasciiChar = 1; // set for Atascii code
    var _bShowDispChar = 1; // set for internal display code
    var _bShowROMBank = 0; //set for showing rom bank in disassembly

    var _bShowAtariFont = false; // true for atari font for the wall display
    var _bShowWebChar = false; // true for using normal monosapace for char dump
    
    // functions

    //(PVB ADD) the get_symbol(memadd, opc) function
    function get_symbol(memadd, opc) {
        var str1, str2, n1, n2, sym, a;
        var a5200eq = _bShowA5200Equates;
        if (memadd.length == 2) { //zero page
            return (a5200eq ? _A5200syms_zp[memadd] : _A800syms_zp[memadd]);
        }
        //(PVB TODO) : convert memadd for A5200 ?//
        a = Number("0x" + memadd);
        if (a < 0xC000)
            return (a5200eq ? _A5200syms[memadd] : _A800syms[memadd]);
        if (a5200eq) { //Hardware chip addressing in A5200
            if (a >= 0xC000 && a <= 0xC0FF ) //GTIA at $C000-C0FF, that is at $D000-D0FF for A800
                memadd = hex(((a & 0x001F) | 0xD000),4);
            if (a >= 0xE800 && a <= 0xEBFF ) //POKEY at $E800-EBFF (that can feature 4xPOKEY chips ?), that is at $D200-D2FF for A800
                memadd = hex(((a & 0x000F) | 0xD200),4);
            if (a >= 0xD400 && a <= 0xD4FF ) {//ANTIC at $D400-D4FF, that is also at $D400-D4FF for A800
                memadd = hex(((a & 0x000F) | 0xD400),4);
            }
            if (a >= 0xF800 && a <= 0xFFF9)
            //(PVB TODO) : EXPERIMENTAL : within the OS ROM, shows "A5200 ROM"//
                return [" ", "A5200 ROM"]; //EXPERIMENTAL
            //if (a in the 2KB ROM)
            //ROM CHARSET is $F800 to $FBFF
            //ROM MONITOR is $FC00 to $FFFF
        } 
        else { // for A800
            if (a < 0xD000 || a> 0xDFFF) //ROM
                return _A800syms[memadd];
        }
        //check and display the adequat READ or WRITE symbol and informative text
        sym = _A800syms[memadd];
        if (!sym) return sym;
        str1 = sym[0];
        n1 = str1.indexOf("/");
        str2 = sym[1];
        n2 = str2.indexOf("/");
        switch(opc) {
            // following case are "write to Hardware chips"
            case 0x8C: //STY abs
            case 0x8D: //STA abs
            case 0x8E: //STX abs
            case 0x99: //STA abs,Y
            case 0x9D: //STA abs,X
                // extract write text
                if (n1 > 1) {
                    str1 = str1.slice(n1+1);
                }
                if (n2 > 1) {
                    str2 = str2.slice(n2+1);
                }
                break;
            default:
                // else by default, this is a read from Hardware chips
                // extract read text
                if (n1 > 1) {
                    str1 = str1.slice(0,n1);
                }
                if (n2 > 1) {
                    str2 = str2.slice(0,n2);
                }
                break;
        }
        sym = [str1, str2];
        return sym;
    }
    //(PVB END OF ADD)

    //(PVB MOD) improvement of disassembleStep() function 
    //previously //function disassembleStep(pc, ram, asm, flags)// so it is added :
    //'lastopcode' for identifying the last opcode matter, and then to stop fetching from the memory
    //so number of remaining bytes to desassemble is given in 'lastopcode' variable (lastopcode is included !)
    //'inner' = true to avoid display of "End of data or max address reached" when it's note the case when reajusting disassembly in dissassemble()
    function disassembleStep(pc, ram, asm, flags, lastopcode, inner) {
        var instr, op1, op2, addr, ops, disas, adm, step;
        var symbol;
        // get instruction and ops, inc PC (PC = program counter)
        
        function u8(i) {
            return ram[i];
        }

        instr = u8(pc);
        addr = hex(pc, 4); //Convert PC into address like '$0A39'
        ops = hex(instr); //Convert the instruction byte into hex like 'A0'
        disin = opctab[instr][0]; //(PVB MOD) opcode instruction like 'LDA'
        disas = ""; //(PVB ADD) variable initialization for operand display string like '#$A0'
        adm = opctab[instr][1]; //(PVB COM) type of opcode instruction like "imm" for immediat
        step = steptab[adm]; //(PVB COM) number of step = number of opcode+operands including the instruction (like 3 for LDA $A039)
        //(PVB MOD) change the validity declaration
        var valid = true;
        var oldstep = step;
        //(PVB ADD) Check the remaining bytes in the data block to disassemble
        var r = lastopcode - pc; // if pc = lastopcode then r == 0; no more data to disassemble, it is OK with Step = 1
        if (step > 1) {
            if (r == 0) {
                op1 = op2 = '..'; //even if op2 not used
                step = 1; // reajust step by forcing opcode = last instruction
            }
            else if ((r == 1) && (step > 2)) {
                op2 = '..';
                step = 2; // // reajust step by forcing opcode & operand n1 as last instructions
            }
        }
        if (step > 1) op1 = hex(u8(pc + 1)); // (PVB COM) get operand n1
        if (step > 2) op2 = hex(u8(pc + 2)); //(PVB COM) get operand n2
        //(PVB ADD) Priority to entry_points identified with a 0x84 flags at PC
        if (oldstep > 1) { // step = 2 or 3;
            if ((flags[pc + 1] & 0x84) == 0x84) { //entry_point flag
                op1 = op2 = '..'; //even if op2 not used
                flags[pc] &= 0xFE; //reset valid bit for a display in disassembly Data Block in case of
                step = 1; //force to last instruction before entry_point
                valid = false;
                }
            else if (oldstep == 3 && ((flags[pc + 2] & 0x84) == 0x84)) { //entry_point flag
                op2 = '..';
                flags[pc] &= 0xFE; //reset valid bit for a display in disassembly Data Block in case of
                step = 2; //force to 2 last instructions before entry_point
                valid = false;
                }
        }
        //(PVB MOD) disas and disin
        // format and output to listing
        switch (adm) {
            case 'imm':
                ops += ' ' + op1 + '   '; // 'ops' string looks like 'EA A0   '
                disas = '#$' + op1;
                break;
            case 'zpg':
                ops += ' ' + op1 + '   ';
                disas = '$' + op1;
                break;
            case 'acc':
                ops += '      ';
                disas = 'A';
                break;
            case 'abs':
                ops += ' ' + op1 + ' ' + op2; // 'ops' string looks like 'EA A0 00'
                disas = '$' + op2 + op1;
                break;
            case 'zpx':
                ops += ' ' + op1 + '   ';
                disas = '$' + op1 + ',X';
                break;
            case 'zpy':
                ops += ' ' + op1 + '   ';
                disas = '$' + op1 + ',Y';
                break;
            case 'abx':
                ops += ' ' + op1 + ' ' + op2;
                disas = '$' + op2 + op1 + ',X';
                break;
            case 'aby':
                ops += ' ' + op1 + ' ' + op2;
                disas = '$' + op2 + op1 + ',Y';
                break;
            case 'iny':
                ops += ' ' + op1 + '   ';
                disas = '($' + op1 + '),Y';
                break;
            case 'inx':
                ops += ' ' + op1 + '   ';
                disas = '($' + op1 + ',X)';
                break;
            case 'rel':
                //(PVB ADD & MOD)
                ops += ' ' + op1 + '   ';
                if (op1 == '..') { //no calculation of target address was possible
                    disas = '$----'; // so display  '$----' as target
                    break;
                }
                //(PVB end of ADD & MOD)
                var opv = u8(pc + 1); //(PVB COM) operand = displacement value
                var targ = pc + 2; //(PVB COM) min target for calculation
                if (opv & 0x80) { //(PVB COM) negative displacement if bit #7 is on
                    targ -= (opv ^ 255) + 1; //(PVB COM) compute the backward displacement = (displacement XOR $FF) + 1
                }
                else { //(PVB COM) forward displacement
                    targ += opv; //(PVB COM) target = jump length
                }
                targ &= 0xffff; //(PVB COM) clipping to 64K boundary
                disas = '$' + hex(targ, 4); // 'disas' string looks like 'BNE $targ' -> 'BNE $A000'
                break;
            case 'ind':
                ops += ' ' + op1 + ' ' + op2;
                disas = '($' + op2 + op1 + ')';
                break;
            case 'imp': //(PVB ADD) guess it was "imp" implied by default
            default: //(PVB ADD) in case of we miss an 'adm' type
                ops += '      '; // no ops string and 'disin' variable will contain the instruction
                break;
        }
        // add symbols
        // (PVB ADD) use the new function get_symbol():
        // - to retrieve memory equate symbol for XL, A800, A5200
        // - and for CHIP ROM, make the difference in Sym equate & displayed text if read (R) or if write (W) 
        switch (adm) {
            //zero page address instructions
            case 'zpg':
            case 'zpx':
            case 'zpy':
            case 'inx':
            case 'iny':
                symbol = get_symbol(op1);
                break;
            //normal address instructions
            case 'abs':
            case 'abx':
            case 'aby':
            case 'ind':
                if (op2 == '00') { //in case of 2-byte adress operand is in zero page like 'CMP $0052'
                    symbol = get_symbol(op1);
                }
                else {
                    symbol = get_symbol(op2+op1, instr);
                }
                break;
        }
        if (ops == '')
            ops = '        ';
        //(PVB MOD) change and improve the "valid" management
        //previously // var valid = instr && disas != '???';
        if (disin == '???') valid = false; //disin = disassembled instruction like 'CMP'
        //mark validity, entry and exit points:
        //in the memory flag chart: 
        // 0x01 = opcode is valid
        // 0x02 = "BRK" opcode (PVB ADD)
        // 0x04 = entry_point, with 0x80 = 0x84 (PVB ADD)
        // + 0x08 = end of block => request empty line after block
        // 0x10 = "RTS" opcode
        // 0x20 = "RTI" opcode
        // 0x40 = "JMP" opcode
        // + 0x80 = start of block => request empty line before block - target of relative instruction (BEQ..) are flagged with 0x80 to start a new bloc
        //(PVB MOD) mark validity in flags improvment as described below
        if (valid) { 
            for (var i = 0; i < step; i++){
                flags[i + pc] |= 1;    // valid code
            }
            var a = (step > 2) ? (ram[pc + 1] + (ram[pc + 2] << 8)) : -1; //a = destination address, -1 if not valid (in case of end-of-file was reached)
            switch (instr) {
                case 0x20: // jsr JSR
                    //check the validity of the destination address, for JSR opcode $20 it is mandatory as data $20 $20 $20... are also space chars in code !
                    if ((a >= 0) && (opctab[u8(a)][0] != '???')) { //instruction at target is valid (zero is valid because somewhere in the memory but not loaded at that time),
                        if ((r > 2) && (opctab[u8(pc+3)][0] != '???')) //if there is remaining code to dissassemble && next instruction after JSR is valid
                            if (!_bShowDisBRK && !(flags[a] & 0x02)) //if not already a BRK 
                                flags[a] |= 0x81; //target is validated 
                    }
                    break; 
                case 0x4C: // jump JMP
                    //check validity of destination address
                    if (a >= 0 && opctab[u8(a)][0] != '???') { //instruction at target is valid (zero is valid)
                        flags[a] |= 0x81; //target is validated
                    }
                    flags[pc] |= 0x48; // + 0x08 jump a ligne after
                    break;
                case 0x6C:  //JMP (indirect)
                    a = -1; //no destination since it's an indirect, like JMP (DOSINI) => DOSINI is not the destination address, but its content yes
                    flags[pc] |= 0x48; // + 0x08 jump a ligne after
                    break;
                case 0x40: flags[pc] |= 0x28; a = -1; break; // rti // + 0x08 jump a ligne after
                case 0x60: flags[pc] |= 0x18; a = -1; break; // rts // + 0x08 jump a ligne after
                case 0x00: flags[pc] |= 0x02; a = -1; break; // brk instruction
                default:
                    a = -1;
            }
            // (PVB ADD) create hyperlink to destination and display in bold if OPTION '_bShowDisLinks' is true
            if (_bShowDisLinks)
                if (a != -1) { //for JMP & JSR if destination 'a' is valid
                    disin = '<b>' + disin;
                    disas = '<a href="#PCn' + _nBankId + '$' + hex(a,4) + '">' + disas + '</a></b>';
                }
                else {
                    if (flags[pc] & 0x08) { //make it display in bold for RTS, RTI et JMP (ADD)
                        disin = '<b>' + disin;
                        disas = disas + '</b>';
                    }
                }
            // (PVB ADD) handle the 'rel' instruction (BEQ, BNE, Bxx...) validity and target validity
            if (adm == 'rel' && step > 1) { //if step == 1, there was no operand because end of file was reached, so no check exit 'if' statement
                //by default, invalid the 'rel' instruction, and seek and set validity...
                flags[pc] &= 0xFE;
                flags[pc+1] &= 0xFE;
                valid = false;
                var c = false;
                while (true) { //PVB says there nothing like an infinite loop to break ;-)
                    if ((pc != 0) && !(flags[pc-1] & 0x01)) break; // previous is not valid (seen if the flag) => exit
                    //check the next instruction validity
                    if (flags[pc] & 0x08) { //if there is already a flag set, it means we are at the second 'rel' in the pair like BEQ/BNE
                        c = true; //so 'rel' is valid
                        break; //and exit without any other verification
                    } 
                    if (pc > 0xFFFD) break; // if so, checking of the next instruction at pc+2 is not possible, so exit
                    if (ram[pc+2] == ram[pc]) break; // next is the same 'rel' instruction, like BNE xx BNE xx, we assume not possible, exit
                    if ((pc > 1) && ((ram[pc-2] == 0xA9) || (ram[pc-2] == 0xA0) || (ram[pc-2] == 0xA2))) {
                        //the previous instruction is a load imm like LDA #$00, the load imm sets the 'rel' status
                        flags[pc] |= 0x08; //valid 'rel' jump => so we set the flag for a line feed to create a block before
                    } //(PVB TODO) we could validate the same with "store" & "transfer" instruction, and 6502 flag set instruction like SEC/BCS & CLC/BCC
                    if (opctab[u8(pc + 2)][0] == '???') break; // if the next instruction at PC+2 is unknown => exit
                    if (!_bShowDisBRK && opctab[u8(pc + 2)][0] == 'BRK') break; //if the next instruction at PC+2 is BRK instruction => exit
                    //note : same as "if (!_bShowDisBRK && !ram[pc+2])"
                    if (!c && (opctab[u8(pc + 2)][1] == 'rel') && ((ram[pc] & 0xC0) == (ram[pc+2] & 0xC0))) { //check i's a pair with the next instruction like BEQ/BNE
                        //for a pair, 'rel' have same bits #7 #6 (0xC0), they only differ on bit #5, remaining bits are always 0x10.
                        flags[pc + 2] |= 0x08; //valid 'rel' jump pair => so we set the flag for a line feed to create a bloc
                    }
                    //at this point we have a valid 'rel' instruction, next instruction is OK (or it is a BRK that is accepted)
                    //or next is not OK but 'rel' is OK thanks to previous instruction like in "LDA #$00 BEQ XXX"
                    //or next instruction is also a 'rel' pair like BEQ/BNE..
                    c = true; //so set 'rel' as a valid instruction
                    break; //and exit loop
                }      
                //and now, let's check the target...
                if ((c && (opctab[u8(targ)][0] == '???') || (!_bShowDisBRK && !ram[targ]))) {
                    //if instruction at target is unknown or is equal to zero (BRK) memory not accepted)
                    c = false; //'rel' is no more valid
                }
                if (c) { //validation of 'rel' instruction if c = true
                    flags[targ] |= 0x81; // target set to valid
                    if (_bShowDisLinks) {
                        disas = '<a href="#PCn' + _nBankId + '$' + hex(targ,4) + '">' + disas + '</a>'; //create hyperlink to destination
                    }
                    flags[pc] |= 1;
                    flags[pc+1] |= 1;
                    valid = true;
                }   
            } 
        }
        //(PVB ADD) mark the end of disassembly
        if ((valid && (op1 == ".." || op2 == ".."))) {
            flags[pc] &= 0xFE;
            valid = false;
            if (!inner)
                disas += ' <span style="color:red;">[!End of data or max address reached!]</span>';
        }
        //(PVB ADD) Add the ROM bank number id for ROM disassembly
        if (_bShowROMBank && _nBankId)
            addr = "n" + _nBankId + ":" + addr;
        // then finaly make the asm listing
        asm.push({
            pc: pc, step: step, valid: valid,
            s: addr + '   ' + ops + '   ' + disin + ' ' + disas + (symbol ? " ; " + symbol[0] + (symbol[1] ? (" <i>" + " >" + symbol[1] + "</i>") : "") : "")
         });
        return (pc + step);
    }

    //  First disassembly pass
    //(PVB MOD) improvement of disassemble() function 
    function disassemble(addr, data, i, len, ram, flags) {
        //(PVB COM) "addr" = disassembly start address, "data" = data to disassemble (bytes array), "len" = number of bytes to disassemble 
        //array of variables : "ram" byte array that is the 64KB Atari memory (0-$FFFF) where data are copied, and corresponding byte array of "flags"
        var asm = []; //asm is the disassembly result (string of text)
        //(PVB ADD) add a protection in order not to overpass the 0xFFFF in the "ram" byte array !
        if ((addr + len) > 0x10000) { //len + start address should not be greater than 0xFFFF otherwise there is a bug
            len = 0x10000 - addr; //if it is the case, len is decreased (clipped) to max 64K memory = 0xFFFF
            console.log("disassemble() => has limited the lenght of block to disassemble for not overpass 0xFFFF");
        }
        //(PVB end of ADD)
        for (var j = 0; j < len; j++) //(PVB COM) 'data[]' are stored in the corresponding 'ram[]' 64K buffer at the real starting address
            ram[addr + j] = data[i + j];
        var pc = addr;
        var lastopcode =  addr + len; //(PVB ADD) Adde the 'lastopcode' variable feature for handling the last opcode issue & stop fetching from the memory, 
        while (pc < lastopcode) {
            //(PVB MOD) pc = lastopcode for the last instruction byte
            pc = disassembleStep(pc, ram, asm, flags, lastopcode-1, false); //inner = false
        }
        return asm;
    }
    
    // Two pass: disassembly then basic blocks
    //(PVB MOD) improvement of disassemble2() function
    // _nBankId global variable (initialized in xex_dump() function) is used
    // _nBankId = "" if no rom, or _nBankId = number of bank to disassemble if rom
    // nSeg for the segment number for tagging disassembly links
    // segData, segStart for retrieving data from the segments and not from the "ram" that can be overloaded by segments
    function disassemble2(asm, str, ram, flags, nSeg, segData, segStart) {
        var start = 0xFFFF; //overall of asm
        var end = 0;        //overall of asm
        var blocks = [];
        var block = { lines: [], errs: 0, bll: 0 };
        var nbrk = 0;
        //(PVB HINT! ) ***************** here Javascript variable for dev. *************************************
        var _sh = false; //if true => valids the console.log() for displaying disassembling hints in the console

        //(PVB MOD) initialization of the "asm" array
        function asmlist_add_flags(asmlist) {
            asmlist.forEach(a => { // for each desassembly lines
                a.flags = flags[a.pc];
                start = Math.min(start, a.pc);
                end = Math.max(end, a.pc + a.step); //(PVB MOD)
                if (_bShowDisFlags)
                    a.s = "["+ hex(a.flags) + "]" + a.s; //(PVB COM) show the flag for each line
            });
        }

        function separator() {
        if (str[str.length - 1] == "")
                return;
            str.push("");
        }

        function end_of_lines(lines) {
            return lines[lines.length - 1].pc + lines[lines.length - 1].step;
        }

        function runny(lines) {
            if (lines === undefined)
                return false;
            if (!lines[0].pc)
                console.log("disassemble2()/runny() =>Huston we've got a problem: lines[0].pc = " + lines[0].pc);
            var start = lines[0].pc;
            var end = end_of_lines(lines); //end is not included (end is the 1st instruction of next block)
            if ((end - start) < 4) //(PVB MOD) Runny lines are considered only after 3 instructions (i.e. 4C 4C4C is valid within a block)
                return;
            for (var i = start + 1; i < end; i++)
                if (ram[start] != ram[i])
                    return false;
            return true;    // All data is the same value in all the lines
        }

        function as_data(blocks) { //(PVB COM) "Show as Code" = as data; create Hexdump to display in case of non disassembled code
            var from = blocks[0].lines[0].pc;
            var to = end_of_lines(blocks[blocks.length - 1].lines);
            var di = to - from; //(PVB ADD) to simplify

            var key = hex(from, 4);
            var stmp = '' + (nSeg ? hdx(nSeg) : _nBankId); //(PVB ADD) segment or rom bank add
            //(PVB ADD) the _nBankId in the "show as code" id selector
            str.push(`; Data block of $${hdx(di)} (${di}) bytes at $${key}:${hex(to - 1, 4)}<em class='showcode' onclick='toggle("#C${stmp}_${key}")'>Show As Code</em>`);
            //  stick all the code in too
            str.push(`<div id='C${stmp}_${key}' style='color:#00F;display:none'>;`); //(PVB MOD) color set to blue instead of red
            blocks.forEach(block => block.lines.forEach(line => str.push(line.s)));
            str.push(`</div>;`);

            while (from < to) {
                var mx = 16 - (from & 0xF);
                var n = Math.min(mx, to - from);
                //(PVB ADD) display the _nBankId if _bShowROMBank flag and _nBankId not empty
                stmp = _bShowROMBank && _nBankId ? ('n' + _nBankId + ':') : '';
                //(PVB ADD) if segments, then use data from the segments and not from the "ram"
                stmp += segData ? hex_line(from, segData, (from - segStart), n, 4) : hex_line(from, ram, from, n, 4);
                str.push(stmp);
                from += n;
            }
            str.push(";");
            separator(); //line feed in the disassembly
        }

        // slice into blocks, mark those
        function flush_block() {
            //(PVB COM) create a block
            if (block.lines.length) {
                block.bll = block.lines.length;
                blocks.push(block);   
            }
            block = { lines: [], errs: 0, bll: 0}; //and initialize new empty block
        }
        //(PVB ADD)
        function make_disas_anchor(a) {
            if ((a.flags & 0x01) && _bShowDisLinks) {
                a.s = a.s.replace(' ', ' </strong>');
                a.s = '<strong id="PCn' + _nBankId + '$' + hex(a.pc,4) + '">' + a.s; //create destination HTML anchor for disassembly address hyperlinks
            }
        }
        //(PVB END OF ADD)
        
        //(PVB MOD & ADD) disassemble2() starts now here
        asmlist_add_flags(asm);
        nbrk = 0;
        asm.forEach(a => {
            //(PVB ADD) add a tolerance of 2 errors when this is a BRK instruction if _bShowDisBRK
            if (a.flags & 0x02) { //BRK instruction
                if (_bShowDisBRK && (nbrk < 3)) {
                    nbrk++;
                }
                else {
                    block.errs++;
                    nbrk = 0;
                }     
            }
            //else { //else activated = BRK can not be a jump Target
                if (a.flags & 0x80) { //if the asm listing encounter a 0x80 then create a new block
                    make_disas_anchor(a);
                    if (a.flags & 0x04) //if 0x84 then this is an entry point
                        a.s = ";<i><b>[Entry_Point]</i></b><br />"+ a.s;
                    flush_block(); //creat new block starting with 0x81
                }
            //}
            block.lines.push(a); //put asm listing in a new block lines

            if (!a.valid)
                block.errs++; //(PVB COM) err++ counts the number of error in the block, that is the number of "valid = false"
            
            //if the asm listing encounter a 0x08 then create a new block
            if ((a.flags & 0x08) && !block.errs)
                flush_block();
        });

        flush_block(); // the last block is created
        separator(); //line feed in the disassembly
        
        // determine if each block is ASM or DATA

        //(PVB MOD) block analysis and adjust disassembly listing if needed
        var tmpb = [];
        var blen, pcmax, pcmin;
        var b = 0;
        var b2;
        var f = 0;
        var lb, nbe, pbe;

        //check each 'b' blocks for validity set in the above "asm.forEach" loop
        for (b = 0; b < blocks.length; b++) { //for each block in blocks
            if (runny(blocks[b].lines)) {
                blocks[b].errs = 1; //RULE : the current block shall not contain the same bytes value
            }
            //if (b > 0 && b < (blocks.length - 1)) { //not the first block, neither the last => replaced by 'lb'
            lb = (b == (blocks.length - 1)) ? true : false;
            if (b > 0) pbe = blocks[b - 1].errs ? true : false; else pbe = false;
            if (!lb) nbe = blocks[b + 1].errs ? true : false; else nbe = false;
            //checking validity of blocks...
            while (true) { //PVB says there is nothing like a while(true) loop to avoid chaining the if/else...
                tmpb = blocks[b]; //copy of current block
                if (!tmpb.bll) {
                    if (_sh) console.log("Skipping block b=" + b + " that is empty...");
                    break; //if empty block then exit the loop (and go to next block)
                }
                if (tmpb.errs) {
                    //if (_sh) console.log("Skipping block b=" + b + " that has " + tmpb.errs + " errors...");
                    break; //if non valid block then exit the loop (and go to next block)
                }
                if (!nbe && !pbe) {
                    //if (_sh) console.log("Skipping block b=" + b + " that has no error, like next and previous");
                    break; //exit the loop (and go to next block)
                }
                blen = tmpb.lines.length; //block number of lines
                f = tmpb.lines[0].flags;
                if (blen != tmpb.bll) console.log("disassemble2() Huston we've got a problem: 'blen' is not equal to 'tmpb.bll'");
               
                if (_sh) console.log("!>Chekking block b=" + b + ", errs=" + tmpb.errs + ", lines length=" + tmpb.lines.length + ", PC=" + hex(tmpb.lines[0].pc,4));

                if (blen == 1) { // RULE for a single line block //
                    if (_sh) console.log(" ...one line checking...");
                    //RULE: if a block is a valid one-line instruction, before an invalid block [nbe],
                    //it must be the end of block, hence containing the 0x08 flag (JMP, RTI, RTS, BXX pair) => otherwise invalid current block
                    if (nbe && !(f & 0x08)) { //if next block invalid && the single block is not "a end of block" like JMP, RTI, RTS, BXX couple
                        tmpb.errs = 1;
                        if (_sh) console.log(" --1- >>single line block before invalid block shall end with JMP, RTI, RTS or Bxx pair!")
                        if (!pbe && b > 0) { //if previous was valid...
                            b = b - 2; // re-check previous block by decreasing b (-2 because the for loop increase by 1)
                        }
                        break;
                    }
                    //RULE: if the one-line valid block containing a single RTI, RTS ou JMP (that is a 0x70)
                    // => cannot be after an invalid block [pbe] (except if containing the 0x80 flag)
                    // => cannot follow a valid block that already ends with RTI, RTS instruction (that is a 0x30) (except if containing the 0x80 flag)
                    if ((f & 0x70) && !(f & 0x80)) { //the single line is RTS, RTI, JMP; and does not contain a 0x80 flag
                        if (pbe) { //if previous block is not valid
                            tmpb.errs = 1; //then block not valid
                            if (_sh) console.log(" --2- >>cannot have a single line RTS/RTI/JMP without 0x80 flag after invalid block!");
                            break;
                        }
                        else { // if previous block is valid
                            if ((b>0) && (blocks[b - 1].lines[(blocks[b - 1].lines.length - 1)].flags & 0x30)) { //if previous block also ends with RTS or RTI
                                tmpb.errs = 1; //then block not valid
                                if (_sh) console.log(" --3- >>cannot have a single line RTS/RTI/JMP without 0x80 flag after a block ending with RTS/RTI/JMP!");
                                if (!pbe && b>0) { //if previous was valid...
                                    b = b - 2; // re-check previous block by decreasing b (-2 because the for loop increase by 1)
                                }
                                break;
                            }
                        }
                    }
                    //RULE: the one-line valid block cannot have the same instruction as the previous block
                    if (b>0 && pbe) { //if previous block is not valid
                        var s0 = tmpb.lines[0].s.substring((tmpb.lines[0].s.indexOf('  ')))
                        var s1 = blocks[b-1].lines[0].s.substring((blocks[b-1].lines[0].s.indexOf('  ')));
                        if (s0 && s1 && (s0 == s1)) { //the single ligne is same as the previous (instruction & operands)
                            tmpb.errs = 1; //then block not valid
                            if (_sh) console.log(" --4- >>2 lines of instruction identical found!");
                            break;
                        }
                    }
                    break;    
                }//END OF RULE for a single line block

                //RULE for normal current valid & previous invalid
                if (pbe && !(f & 0x81 == 0x81)) { //if no 0x81 flag at the beginning of bloc, then invalidate
                    tmpb.errs = 1;
                    if (_sh) console.log(" --5- => current block shall start with valid 0x81 flag when previous is not valid")
                    break;
                }
                //RULE for normal current valid, next invalid and last line of current valid block not ending with 0x08
                var r = false;
                if (!lb)
                    r = runny(blocks[b+1].lines);
                if ((r || nbe) && !(tmpb.lines[(blen-1)].flags & 0x08)) {
                    tmpb.errs = 1;
                    if (_sh) console.log(" --6- => cannot have a next block invalid and current block not ending with RTS/RTI/JMP 0x08 flag")
                    if (!pbe && b>0) { //if previous was valid...
                        b = b - 2; // re-check previous block by decreasing b (-2 because the for loop increase by 1)
                    }
                    break;
                }
                
                if (_sh) console.log("  => end of block " + b + " verification---");
                break; //security
            } //end Of while(true) for checking validity of blocks...
        } //end of 'for' loop for all blocks  

        //Code loop for Searching for 0x80 flags in previous unvalid block, and rajust disassembly listing block
        for (b = 1; b < blocks.length; b++) { //for each block in blocks starting at block #1
            //if current block is valid, but previous is not, then
            //seek the 0x81 hidden flag in the previous and if needed reajust block disassembly
            pbe = blocks[b - 1].errs ? true : false;
            b2 = b; //save b in b2
            if (!blocks[b].errs && pbe) { //RULE for current valid block && previous invalid;
                tmpb = blocks[b-1]; //tmpb = previous

                var pc, i, pc_flag, b2;
                var errs, ite = 0;
                var tmpasm =[];
                var m = false;

                blen = tmpb.lines.length
                pcmax = tmpb.lines[blen - 1].pc + tmpb.lines[blen - 1].step; //pcmax not included, it is the pc of next block
                pcmin = tmpb.lines[0].pc;
                while (true) { // as long as we find 0x80 flags in the non-valid current block
                    if (!blen) break; //protection just in case
                    ite ++;
                    if (_sh) console.log("!>Seek 0x80 flags in previous Block b-1=" + (b-1) + " of "+ blocks.length + ", line len=" + blen + ", iteration #" + ite + ", PC=" + hex(pcmin,4) + "-" + hex(pcmax,4));
                    //search a hidden 0x81 from the end of block
                    if (m) //if m then a first one has been found but was wrong
                        i = pc_flag - 1;
                    else
                        i = pcmax - 1 ; //i is set to PcMax of the block
                    m = false; //reset
                    while (i > pcmin) {
                        if (flags[i] & 0x80) {
                        //if ((flags[i] & 0x81) == 0x81) {
                            pc_flag = i;
                            m = true;
                            break; // exit the "while" loop
                        }
                    i--;
                    }
                    if (!m) {
                        if (_sh) console.log("  >>Nothing found !");
                        break;
                    } // flag 0x81 not find, so exi0 &&
                    tmpasm =[];
                    pc = i;
                    while (pc < pcmax) {
                        pc = disassembleStep(pc, ram, tmpasm, flags, pcmax-1, true);
                    }
                    if (pc != pcmax) { // disassembly does not match the current disassembly, so exit the while (true) loop!
                        if (_sh) console.log("  >>but no recovery with current block b=" + b + " ! ..continue..");
                        continue;
                        //break;
                    } 
                    //prepare new asm list and check the validity (errs)
                    errs = 0;
                    tmpasm.forEach(a => {
                        a.flags = flags[a.pc];
                        if (_bShowDisFlags)
                            a.s = "[" + hex(a.flags) + "]" + a.s;
                        if (a.flags & 0x80)
                            make_disas_anchor(a);
                        if (!a.valid)
                            errs++;
                    });
                    if (errs) {
                        if (_sh) console.log("  >>but previous Block b-1=" + (b-1) + " has errors! ..continue..");
                        // if there is non-valid in the disassembly, return to the beginnning of loop to find another 0x81
                        continue; 
                    }
                    if (_sh) {
                        console.log("  >>Previous Block b-1=" + (b-1) + " making OK >>tmplines :");
                        console.log(tmpasm);
                    }
                    //push new valid block into the blocks list at next position
                    blocks.splice(b, 0, {lines: tmpasm, errs: 0, bll: tmpasm.length});
                    b2++; //index of the current block is +1
                    if (_sh) console.log("  >>Block b=" + b + " created in the block chart !!, Nbr of blocks=" + blocks.length);
        
                    // reajust the first part of the current block (before the found 0x81)
                    pc = pcmin; //pc for the 1st line
                    tmpasm = []; //reset
                    while (pc < pc_flag) {
                        pc = disassembleStep(pc, ram, tmpasm, flags, pc_flag-1, true);
                    }
                    errs = 0;
                    tmpasm.forEach(a => {
                        a.flags = flags[a.pc];
                        if (_bShowDisFlags)
                            a.s = "[" + hex(a.flags) + "]" + a.s;
                        if (!a.valid)
                             errs++;
                    });
                    blocks[b-1].lines = tmpasm;
                    blocks[b-1].errs = errs;
                    blocks[b-1].bll = blocks[b-1].lines.length;
                    
                    //adjust the block
                    tmpb = blocks[b-1]; //copy of current block
                    blen = tmpb.lines.length;
                    if (!blen) break;
                    pcmax = tmpb.lines[blen - 1].pc + tmpb.lines[blen - 1].step;
                    m = false; // to analyse new remaining block
                    //back to the beginning of the while(true) loop
                }
                b = b2; //update block pointer after having add the previous blocks
            }
        }//end of for loop

        // determine if each block is ASM or DATA
        var first_code = true;
        separator();
        var data = [];
        if (_sh) console.log("!>making block of Data");
        blocks.forEach(block => {
            if (block.errs || runny(block.lines)) {
                data.push(block);           // start of data
            } else {
                if (first_code) {
                    str.push("; <b>Disassembly listing from $" + hex(start, 4) + " to $" + hex(end - 1, 4) + ":</b>\n");
                    first_code = false;
                }
                if (data.length) {
                    as_data(data);    // end of data
                    data = [];
                }
                block.lines.forEach(a => str.push(a.s));
            }
            separator();
        });
        if (_sh) console.log("  => end of block of Data making!");
        if (data.length)
            as_data(data);
        separator();
    }

    // eof

    //===================================================================================================
    //===================================================================================================

    function le16(a, i) {
        return a[i] | ((a[i + 1]) << 8);
    }

    function le24(a, i) {
        return a[i] | ((a[i + 1]) << 8) | ((a[i + 2]) << 16);
    }

    function le32(a, i) {
        return a[i] | ((a[i + 1]) << 8) | ((a[i + 2]) << 16) | ((a[i + 3]) << 24);
    }

    function is_zero(d, i, len) {
        while (len--)
            if (d[i++])
                return false;
        return true;
    }

    function toAscii(a, i, len) {
        var s = '';
        while (len--)
            s += String.fromCharCode(a[i++] & 0x7F); //(PVB MOD) add the 0x7F mask to force the inverted Atari char into normal ($80-$FF => $00-$7F)
        return s;
    }
    
    //(PVB ADD)
    function isAtariNameChar(str, md) { //isAtariText // valid filename char are 'space' 0-9 A-Z a-z
    // plus '@' and '_' for myDOS fileName
        if (str[0] == 0x20) return false; // valid file name cannot start with a space
        for (var i = 0; i < str.length; i++) {
            var c = str[i];
            if (!((c >= 0x30 && c <= 0x39) || (c >= 0x41 && c <= 0x5A) || (c >= 0x61 && c <= 0x7A))) //not OK if not alphabet
                if (!(c == 0x20)) //not OK if not 'space'
                    if (!(md && (c == 0x40 || c == 0x5F))) //not OK if not '@' or '_' (for myDOS fileName)
                        return false; //exit because char not OK
        }
        return true;
    }
    //(PVB END OF ADD)

    function err(e) {
        _m("#err", "#toc", { err: e });
    }

    function ataritext(a) { //called by show_txt(f) to read txt, just before show_ataritext(f, t)
        var s = '';
        var lst = [];
        for (var i = 0; i < a.length; i++) {
            if (a[i] == 0x9B) {
                lst.push(s);
                s = '';
            } else
                s += String.fromCharCode(a[i]);
        }
        if (s.length)
            lst.push(s);
        return lst;
    }

    function parse_failed(f) {
        return [`Can't parse ${f.name} as a ${f.ext} file`]; //'
    }

    function show_m65(f) {
        var asm = mac65(f.data, 0, f.data.length);
        // expand tabs?
        show_ataritext(f, asm ? asm : parse_failed(f));
    }

    function show_bas(f) {
        var t = ataribasic(f.data, 0, f.data.length);
        show_ataritext(f, t ? t.listing : parse_failed(f));
    }

    function show_txt(f) {
        var t = ataritext(f.data, 0, f.data.length);
        show_ataritext(f, t);
    }

    // 160*192 2 bit + [4 byte palette]
    function show_img(f) {
        render_file(f);
        var c = _q("#show");
        var aspect = render_image(c, f);
        resize_parent(c, aspect[0], aspect[1]);
    }

    // https://github.com/TheRobotFactory/EightBit-Atari-Fonts
    function show_fnt(f) {
        var pal = _reload_palette ? [0, 5, 10, 15] : _palette.slice();
        var multicolor = _checks['multicolor'];

        function fnt(n, len) {
            var space = (n & 0x80) ? String.fromCharCode(128 + 32) : ' ';
            var s = space;
            for (var i = 0; i < len; i++)
                s += String.fromCharCode(n + i);
            return s + space;
        }
        var inverted = '';
        for (var i = 0; i < 34; i++)
            inverted += String.fromCharCode(32 + 128);

        var t = [];
        t.push("");
        t.push(fnt(32, 32)); t.push("");
        t.push(fnt(64, 32)); t.push("");
        t.push(fnt(0, 32)); t.push("");
        t.push(fnt(96, 32)); t.push("");
        t.push(inverted);
        t.push(fnt(32 + 128, 32)); t.push(inverted);
        t.push(fnt(64 + 128, 32)); t.push(inverted);
        t.push(fnt(0 + 128, 32)); t.push(inverted);
        t.push(fnt(96 + 128, 32)); t.push(inverted);
        var s = [
            "",
            "YOU ARE IN A MAZE OF TWISTY",
            "LITTLE PASSAGES, ALL ALIKE.",
            "",
            " - Crowther & Woods",
            "",
            "",
            "Never argue with an idiot.",
            "They will drag you down to their",
            "level and beat you with",
            "experience.",
            "",
            " - Mark Twain",
            "",
            "",
            "Nobody ever figures out what",
            "life is all about, and it doesn't",
            "matter. Explore the world. Nearly",
            "everything is really interesting",
            "if you go into it deeply enough.",
            "",
            " - Richard P. Feynman",
            "",
        ];
        s.forEach(line => t.push(' ' + line));
        t.push("");
        show_font(f, t, f.data, multicolor ? _palette : null);
    }

    //(PVB MOD) update the list of possible extensions
    var _exts = {
        "atr": { name: "ATR Disk Image", is_disk: true },
        "atx": { name: "ATX Disk Image", is_disk: true },
        "pro": { name: "PRO Disk Image", is_disk: true },
        "xfd": { name: "XFD Disk Image", is_disk: true },
        "dsk": { name: "Raw Sectors for Disk Image File", is_disk: true }, //(PVB MOD)
        "dat": { name: "Raw Data or DAT Image File (default)", is_dat: true }, //(PVB MOD)
        "arc": { name: "ARC Archive of Image File"},

        "--0": { name: "Languages (formated text files)" }, //(PVB MOD)
        "bas": { name: "Atari Basic/Turbo Basic XL", is_txt: true },
        "lst": { name: "Atari Basic Listing", is_txt: true },
        "asm": { name: "Assembly Listing", is_txt: true },
        "m65": { name: "MAC/65 Assembly Listing", is_txt: true },
        "lis": { name: "Listing", is_txt: true },
        "doc": { name: "Document", is_txt: true },
        "ata": { name: "ATASCII Text File", is_txt: true },
        "txt": { name: "Text File", is_txt: true },
        "bat": { name: "Batch File", is_txt: true },
        "man": { name: "Manual", is_txt: true },

        "--1": { name: "Font & Graphics" },
        "fnt": { name: "Font File", is_fontset: true }, //(PVB MOD)
        "chr": { name: "Font File", is_fontset: true }, //(PVB MOD) chr instead of set

        "gr7": { name: "Graphics 7 Image", is_img: true },
        "gr8": { name: "Graphics 8 Image", is_img: true },
        "gr9": { name: "Graphics 9 Image", is_img: true },
        "g10": { name: "Graphics 10 Image", is_img: true },

        "mic": { name: "Micropainter Image", is_img: true },
        "mcp": { name: "McPainter/Paradox Image", is_img: true },
        "apc": { name: "APAC 256 Color Image", is_img: true },
        "plm": { name: "Plasma 256 Color Image", is_img: true },
        "pzm": { name: "Pryzm Artist Image", is_img: true },
        "ilc": { name: "Digi Paint Image", is_img: true },
        "inp": { name: "InterPainter Image", is_img: true },
        "cin": { name: "Champions' Interlace", is_img: true },
        "pic": { name: "Koala MicroIllustrator", is_img: true },
        "raw": { name: "XL-Paint MAX Image", is_img: true },
        "scr": { name: "Atari Graphics Works Image", is_img: true },
        "ist": { name: "Interlace Studio Image", is_img: true },
        "rip": { name: "Rocky Interlace Picture", is_img: true },
        "hip": { name: "Hard Interlace Picture", is_img: true },
        "tip": { name: "Taquart Interlace Picture", is_img: true },
        //(PVB MOD & ADD) here after file are 'code' an not 'text'; add the "is_romdump" flag; add the "a52" extension
        //(PVB COM) all "is_code" files are either binary DOS file or ROM (memory dump) file; check is done in load_one() and load_data()
        "--2": { name: "Executable Atari DOS Files & Dumps" },
        "sys": { name: "DOS System file", is_code: true, has_header: true }, //(PVB MOD) "sys" are special DOS files and can have $FFFF header that is checked in xex_dump()
        "obj": { name: "Object Code (data or executable)", is_code: true, has_header: true }, //(PVB MOD) 'OBJ' can have header 0xFFFF
        "xex": { name: "Load and Go Executable", is_code: true, has_header: true }, //(PVB MOD) usually has 0xFFFF header
        "exe": { name: "Load and Go Executable", is_code: true, has_header: true }, //(PVB MOD) usually has 0xFFFF header
        "com": { name: "Load and Go Executable", is_code: true, has_header: true }, //(PVB MOD) usually has 0xFFFF header
        "bin": { name: "Atari Raw Binary Dump File", is_code: true, is_romdump: true }, //(PVB ADD) "bin" is a DOS file of raw binary bytes without header; or ROM dump
        "rom": { name: "ROM Dump Image File", is_code: true, is_romdump: true }, //(PVB MOD) ROM dump, or binary equivalent 'BIN' if in a DOS File
        "a52": { name: "Atari 5200 Rom Dump Image File", is_code: true, is_romdump: true }, //(PVB ADD) ROM dump of Atari 5200 ROM
        "car": { name: "Cartridge Image File with CART header", is_code: true, is_romdump: true } //(PVB MOD) ROM dump with CART header
    };
    
    //(PVB ADD) Added the ROM Types table from
    //https://github.com/atari800/atari800/blob/master/DOC/cart.txt
    var _romtypes = {
        "Type_##" : {machine : "on Machine...", size : "Size in KB...", name : "Cart name..."}, //memmap: [size (in page HB), start address (in page HB), number of bank at same address]
        "Type_00" : {machine : "Unknown", size : "0", name : "Unknown CART cartridge", memmap : [0, 0, 0]},
        "Type_01" : {machine : "800/XL/XE", size : "8", name : "Standard 8 KB cartridge", memmap : [0x20, 0xA0, 1]},
        "Type_02" : {machine : "800/XL/XE", size : "16", name : "Standard 16 KB cartridge", memmap : [0x40, 0x80, 1]},
        "Type_03" : {machine : "800/XL/XE", size : "16", name : "OSS two chip 16 KB cartridge (034M)", memmap : [0x10, 0xA0, 3, 0x10, 0xB0, 1]},
        "Type_04" : {machine : "5200", size : "32", name : "Standard 32 KB 5200 cartridge", memmap : [0x80, 0x40, 1]},
        "Type_05" : {machine : "800/XL/XE", size : "32", name : "DB 32 KB cartridge", memmap : [0x20, 0x80, 3, 0x20, 0xA0, 1]},
        "Type_06" : {machine : "5200", size : "16", name : "Two chip 16 KB 5200 cartridge", memmap : [0x20, 0x60, 1, 0x20, 0xA0, 1]}, //todo : handle copie bank (address duplicate)
        "Type_07" : {machine : "5200", size : "40", name : "Bounty Bob Strikes Back 40 KB 5200 cartridge", memmap : [0x10, 0x40, 4, 0x10, 0x50, 4, 0x20, 0xA0, 1]}, //todo : handle copie bank (address duplicate)
        //It exists an alternate Type_07 in Altirra : "Same as cart mapper 7 except that the fixed bank is first" as per Altirra sources "cartridgetypes.h"; that would be :
        //"Type_07" : {machine : "5200", size : "40", name : "Bounty Bob Strikes Back 40 KB 5200 cartridge (Alt Layout)", memmap : [0x20, 0xA0, 1, 0x10, 0x40, 4, 0x10, 0x50, 4]},
        "Type_08" : {machine : "800/XL/XE", size : "64", name : "64 KB Williams cartridge", memmap : [0x20, 0xA0, 8]},
        "Type_09" : {machine : "800/XL/XE", size : "64", name : "Express 64 KB cartridge", memmap : [0x20, 0xA0, 8]},
        "Type_10" : {machine : "800/XL/XE", size : "64", name : "Diamond 64 KB cartridge", memmap : [0x20, 0xA0, 8]},
        "Type_11" : {machine : "800/XL/XE", size : "64", name : "SpartaDOS X 64 KB cartridge", memmap : [0x20, 0xA0, 8]},
        "Type_12" : {machine : "800/XL/XE", size : "32", name : "XEGS 32 KB cartridge", memmap : [0x20, 0x80, 3, 0x20, 0xA0, 1]},
        "Type_13" : {machine : "800/XL/XE", size : "64", name : "XEGS 64 KB cartridge", memmap : [0x20, 0x80, 7, 0x20, 0xA0, 1]},
        "Type_14" : {machine : "800/XL/XE", size : "128", name : "XEGS 128 KB cartridge", memmap : [0x20, 0x80, 15, 0x20, 0xA0, 1]},
        "Type_15" : {machine : "800/XL/XE", size : "16", name : "OSS one chip 16 KB cartridge", memmap : [0x10, 0xB0, 1, 0x10, 0xA0, 3]},
        "Type_16" : {machine : "5200", size : "16", name : "One chip 16 KB 5200 cartridge", memmap : [0x40, 0x80, 1]},
        "Type_17" : {machine : "800/XL/XE", size : "128", name : "(decoded) Atrax 128 KB cartridge", memmap : [0x20, 0xA0, 16]},
        "Type_18" : {machine : "800/XL/XE", size : "40", name : "Bounty Bob Strikes Back 40 KB cartridge", memmap : [0x10, 0x80, 4, 0x10, 0x90, 4, 0x20, 0xA0, 1]},
        "Type_19" : {machine : "5200", size : "8", name : "Standard 8 KB 5200 cartridge", memmap : [0x20, 0xA0, 1]},
        "Type_20" : {machine : "5200", size : "4", name : "Standard 4 KB 5200 cartridge", memmap : [0x10, 0xB0, 1]},
        "Type_21" : {machine : "800", size : "8", name : "Right slot 8 KB cartridge", memmap : [0x20, 0x80, 1]},
        "Type_22" : {machine : "800/XL/XE", size : "32", name : "32 KB Williams cartridge", memmap : [0x20, 0xA0, 4]},
        "Type_23" : {machine : "800/XL/XE", size : "256", name : "XEGS 256 KB cartridge", memmap : [0x20, 0x80, 31, 0x20, 0xA0, 1]},
        "Type_24" : {machine : "800/XL/XE", size : "512", name : "XEGS 512 KB cartridge", memmap : [0x20, 0x80, 63, 0x20, 0xA0, 1]},
        "Type_25" : {machine : "800/XL/XE", size : "1024", name : "XEGS 1 MB cartridge", memmap : [0x20, 0x80, 127, 0x20, 0xA0, 1]},
        "Type_26" : {machine : "800/XL/XE", size : "16", name : "MegaCart 16 KB cartridge", memmap : [0x40, 0x80, 1]},
        "Type_27" : {machine : "800/XL/XE", size : "32", name : "MegaCart 32 KB cartridge", memmap : [0x40, 0x80, 2]},
        "Type_28" : {machine : "800/XL/XE", size : "64", name : "MegaCart 64 KB cartridge", memmap : [0x40, 0x80, 4]},
        "Type_29" : {machine : "800/XL/XE", size : "128", name : "MegaCart 128 KB cartridge", memmap : [0x40, 0x80, 8]},
        "Type_30" : {machine : "800/XL/XE", size : "256", name : "MegaCart 256 KB cartridge", memmap : [0x40, 0x80, 16]},
        "Type_31" : {machine : "800/XL/XE", size : "512", name : "MegaCart 512 KB cartridge", memmap : [0x40, 0x80, 32]},
        "Type_32" : {machine : "800/XL/XE", size : "1024", name : "MegaCart 1 MB cartridge", memmap : [0x40, 0x80, 64]},
        "Type_33" : {machine : "800/XL/XE", size : "32", name : "Switchable XEGS 32 KB cartridge", memmap : [0x20, 0x80, 3, 0x20, 0xA0, 1]},
        "Type_34" : {machine : "800/XL/XE", size : "64", name : "Switchable XEGS 64 KB cartridge", memmap : [0x20, 0x80, 7, 0x20, 0xA0, 1]},
        "Type_35" : {machine : "800/XL/XE", size : "128", name : "Switchable XEGS 128 KB cartridge", memmap : [0x20, 0x80, 15, 0x20, 0xA0, 1]},
        "Type_36" : {machine : "800/XL/XE", size : "256", name : "Switchable XEGS 256 KB cartridge", memmap : [0x20, 0x80, 31, 0x20, 0xA0, 1]},
        "Type_37" : {machine : "800/XL/XE", size : "512", name : "Switchable XEGS 512 KB cartridge", memmap : [0x20, 0x80, 63, 0x20, 0xA0, 1]},
        "Type_38" : {machine : "800/XL/XE", size : "1024", name : "Switchable XEGS 1 MB cartridge", memmap : [0x20, 0x80, 127, 0x20, 0xA0, 1]},
        "Type_39" : {machine : "800/XL/XE", size : "8", name : "Phoenix 8 KB cartridge", memmap : [0x20, 0xA0, 1]},
        "Type_40" : {machine : "800/XL/XE", size : "16", name : "Blizzard 16 KB cartridge", memmap : [0x40, 0x80, 1]},
        "Type_41" : {machine : "800/XL/XE", size : "128", name : "Atarimax 128 KB Flash cartridge", memmap : [0x20, 0xA0, 16]},
        "Type_42" : {machine : "800/XL/XE", size : "1024", name : "Atarimax 1 MB Flash cartridge", memmap : [0x20, 0xA0, 128]},
        "Type_43" : {machine : "800/XL/XE", size : "128", name : "SpartaDOS X 128 KB cartridge", memmap : [0x20, 0xA0, 16]},
        "Type_44" : {machine : "800/XL/XE", size : "8", name : "OSS 8 KB cartridge", memmap : [0x10, 0xB0, 1, 0x10, 0xA0, 1]},
        "Type_45" : {machine : "800/XL/XE", size : "16", name : "OSS two chip 16 KB cartridge (043M)", memmap : [0x10, 0xA0, 3, 0x10, 0xB0, 1]},
        "Type_46" : {machine : "800/XL/XE", size : "4", name : "Blizzard 4 KB cartridge", memmap : [0x10, 0xB0, 1]},
        "Type_47" : {machine : "800/XL/XE", size : "32", name : "AST 32 KB cartridge", memmap : [0x01, 0xBF, 256]},
        "Type_48" : {machine : "800/XL/XE", size : "64", name : "Atrax SDX 64 KB cartridge", memmap : [0x20, 0xA0, 8]},
        "Type_49" : {machine : "800/XL/XE", size : "128", name : "Atrax SDX 128 KB cartridge", memmap : [0x20, 0xA0, 16]},
        "Type_50" : {machine : "800/XL/XE", size : "64", name : "Turbosoft 64 KB cartridge", memmap : [0x20, 0xA0, 8]},
        "Type_51" : {machine : "800/XL/XE", size : "128", name : "Turbosoft 128 KB cartridge", memmap : [0x20, 0xA0, 16]},
        "Type_52" : {machine : "800/XL/XE", size : "32", name : "Ultracart 32 KB cartridge", memmap : [0x20, 0xA0, 4]},
        "Type_53" : {machine : "800/XL/XE", size : "8", name : "Low bank 8 KB cartridge", memmap : [0x20, 0x80, 1]},
        "Type_54" : {machine : "800/XL/XE", size : "128", name : "SIC! 128 KB cartridge", memmap : [0x40, 0x80, 8]}, //to check
        "Type_55" : {machine : "800/XL/XE", size : "256", name : "SIC! 256 KB cartridge", memmap : [0x40, 0x80, 16]}, //to check
        "Type_56" : {machine : "800/XL/XE", size : "512", name : "SIC! 512 KB cartridge", memmap : [0x40, 0x80, 32]}, //to check
        "Type_57" : {machine : "800/XL/XE", size : "2", name : "Standard 2 KB cartridge", memmap : [0x08, 0xB8, 1]},
        "Type_58" : {machine : "800/XL/XE", size : "4", name : "Standard 4 KB cartridge", memmap : [0x10, 0xB0, 1]},
        "Type_59" : {machine : "800", size : "4", name : "Right slot 4 KB cartridge", memmap : [0x10, 0x90, 1]},
        "Type_60" : {machine : "800/XL/XE", size : "32", name : "Blizzard 32 KB cartridge", memmap : [0x20, 0xA0, 4]},
        "Type_61" : {machine : "800/XL/XE", size : "2048", name : "MegaMax 2 MB cartridge", memmap : [0x40, 0x80, 128]}, //bank 0 first
        "Type_62" : {machine : "800/XL/XE", size : "128M", name : "The!Cart 128 MB cartridge", memmap : [0, 0, 0]}, //bank 0 first //(PVB TODO) =>not supported yet
        "Type_63" : {machine : "800/XL/XE", size : "4096", name : "Flash MegaCart 4 MB cartridge", memmap : [0x40, 0x80, 255]}, //bank 254 is ennable, no 255 bank
        "Type_64" : {machine : "800/XL/XE", size : "2048", name : "MegaCart 2 MB cartridge", memmap : [0x40, 0x80, 128]},
        "Type_65" : {machine : "800/XL/XE", size : "32M", name : "The!Cart 32 MB cartridge (!not supported yet)", memmap : [0, 0, 0]}, //bank 0 first //(PVB TODO) =>not supported yet
        "Type_66 ": {machine : "800/XL/XE", size : "64M", name : "The!Cart 64 MB cartridge (!not supported yet)", memmap : [0, 0, 0]}, //bank 0 first //(PVB TODO) =>not supported yet
        "Type_67" : {machine : "800/XL/XE", size : "64", name : "XEGS 64 KB cartridge (banks 8-15)", memmap : [0x20, 0x80, 7, 0x20, 0xA0, 1]}, //bank 0 first
        "Type_68" : {machine : "800/XL/XE", size : "128", name : "Atrax 128 KB cartridge", memmap : [0x20, 0xA0, 16]}, //coded cartridge of type 17
        "Type_69" : {machine : "800/XL/XE", size : "32", name : "aDawliah 32 KB cartridge", memmap : [0x20, 0xA0, 4]}, //bank 0 first 
        "Type_70" : {machine : "800/XL/XE", size : "64", name : "aDawliah 64 KB cartridge", memmap : [0x20, 0xA0, 8]}, //bank 0 first 
        // ALTIRRA V3.90 does not support next types ?
        "Type_71" : {machine : "5200", size : "64", name : "Super Cart 64 KB 5200 cartridge (32K banks)", memmap : [0x80, 0x40, 2]},
        "Type_72" : {machine : "5200", size : "128", name : "Super Cart 128 KB 5200 cartridge (32K banks)", memmap : [0x80, 0x40, 4]},
        "Type_73" : {machine : "5200", size : "256", name : "Super Cart 256 KB 5200 cartridge (32K banks)", memmap : [0x80, 0x40, 8]},
        "Type_74" : {machine : "5200", size : "512", name : "Super Cart 512 KB 5200 cartridge (32K banks)", memmap : [0x80, 0x40, 16]},
        "Type_75" : {machine : "800/XL/XE", size : "1024", name : "Atarimax 1 MB Flash cartridge (new)", memmap : [0x20, 0xA0, 128]},
        //(PVB TODO) Add futur type above type_75 : https://github.com/atari800/atari800/blob/master/DOC/cart.txt
    };
    //(PVB end of ADD)

    //(PVB ADD) "_extractedfile" = default values in the disk file extract to be disassembled
    var _extracted_disk = {start_sect: 1, start_sect_off: 6, end_sect: 3, start_add: 0x706 };
    var _extracted_file = {start_offset: 0, end_offset: 0, start_add: 0x1000 };
    //(PVB end of ADD)

    // guess the file type
    //(PVB MOD) improvement of get_ext() function
    function get_ext(name, a, imgTag, dosfileTag) { //(PVB COM get_ext() is called by load_data() function and returns, the loaded file extension "xxx"
        //(PVB COM) name = file name; a = the file byte data; imgTag = is set with the image (type/mime) extension; dosfileTag set to force ROM or disk images as DOS file
        //(PVB MOD) read the file header...
        var sig = le16(a, 0); //(PVB COM)  sig = signature or file header (2 first bytes)
        var n = name.lastIndexOf("."); //(PVB COM) is there a file extension (a dot) ? n is the number of char before the extension dot "."
        if (n != -1) { //(PVB COM) if it is not -1, then an extension has been found in the loaded file
            var ext = name.substr(n + 1).toLowerCase(); //(PVB COM) ext is set to lowercase
            if (dosfileTag) {
                if (ext == "rom" || ext == "a52" || ext == "car") { // .rom .a52 and .car files are in a DOS disk image file
                    ext = "bin"; //so force extension type to 'bin' DOS file
                    console.log(" get_ext() has forced orignal extension of file " + name + " to 'bin', for not to confuse it with ROM image file");
                }
                if (ext == "atr" || ext == "atx" || ext == "pro" || ext == "xfd" || ext == "dsk") { //disk image file extensions as Atari DOS files, this is not possible
                    ext = "???"; //so force extension type to '???'' to escape the _exts[ext] known extension here after
                    console.log(" get_ext() has forced orignal extension of file " + name + " to '???', for not to confuse it with Disk image file");
                }
            }
            if (_exts[ext]) { //(PVB COM) returns the extension if found in the table of extensions
                console.log(" get_ext() has found extension '" + ext + "' for file " + name + " in the _exts table");
                return ext;
            }
        } //else no extension or unknown extension in the filename
        //(PVB COM) no ext in the file name, or unknown extension from the table... is it a type/mime image ?
        if (imgTag) {
            console.log(" get_ext() has found imgTag for image in file " + name);
            return imgTag.width == 320 ? "gr8" : "gr7"; //(PVB COM) if yes, the ext is forced to gr8 or gr7
        }
        //(PVB COM) no ext in the file name, or unknown extension from the table, or not a type/mime image
        if (!dosfileTag) { //check disk image type....
            console.log(" get_ext() checks if " + name + " is a disk image like ATR, ATX, PRO or XFD...");
            if (ATR.is_atr(a)) //(PVB MOD) function is_atr() has been added, so use it to check is it is an ATR
                //(previously) if (sig == 0x0296) //(PVB COM) $0296 (sum of 'NICKATARI') return "atr";) => this check is now in is_atr()
                return "atr";
            if (ATX.is_atx(a)) //(PVB COM) note : static function call is done by CLASS.funtion()
                return "atx";
            if (PRO.is_pro(a))
                return "pro";
            if (XFD.is_xfd(a))  //(PVB COM) XFD is identified thanks to the disk image file size that shall correspond to real Atari disk size
                return "xfd";
        }
        //(PVB MOD) use a switch function to check the file header to identify the file type
        console.log(" get_ext() checks if " + name + " is an Atari file with a specific header...");
        switch (sig) {
            case 0xFFFF:
                if (le16(a, 2) <= le16(a, 4)) {
                    return "xex"; //(PVB COM) it is a valid executable Atari file with 0xFFFF header and the 2 segment address vector are consistent
                }
                break;
            case 0x80FF:
                if (le16(a, 2) == 0xC7C9) {
                    return "pic";
                }
                break;
            case 0x4952:
                return "rip";
            case 0xFEFE:
                return "m65";
            case 0x081A:
            case 0x041A:
                return "arc";
        }
        //(PVB COM) check for Basic file...
        console.log(" get_ext() checks if " + name + " is an Atari BASIC file ...");
        try {
            if (ataribasic(a, 0, a.length)) {
                console.log(" get_ext()... yes it is BASIC file !");
                return "bas";
            }
        }
        catch (err) {
            console.log(err);   // guess it wasn't basic because ataribasic() returns an error
        }
        //still not find the file type here, so check for general LST file (basic listing)
        console.log(" get_ext() checks if " + name + " is an Atari LST or Text file ...");
        var s = '';
        var tx = true;
        for (var i = 0; i < a.length; i++) { //(PVB COM) searching in the file for keywords "REM, GOTO, THEN" that should be in an Atari LST file
            var d = a[i];
            s += String.fromCharCode(d);
            d = (d == 0x9B) ? 0x20 : (d & 0x7F); //check if it's a valid 0x9B EOL char and replace it by a space
            if ((d >= 0x1B && d <= 0x1F) || (d >= 0x7D && d <= 0x7F)) //is it a control char ?
                tx = false; //then it's not a text file !
        }
        if ((s.indexOf("REM") != -1) || (s.indexOf("GOTO") != -1) || (s.indexOf("THEN") != -1)) {
            console.log(" get_ext() ... looks like a LST file because contains REM, or GOTO, or THEN words!");
            return "lst";
        }
        if (tx) {
            console.log(" get_ext() ... looks like a Text file as it does not contain control char (except EOL $9B)!");
            return "txt";
        }
        //still not find the file type here, so it will be shown as a .DAT RAW file (just a binary dump, no disassembly)
        console.log(" get_ext() has not found a known Atari file, so ext of  " + name + " is set to '???'");
        return "???"; //(PVB MOD) ext = "???" that is an unknown type, displayed as a DAT file
    }

    //(PVB ADD) get_type() function to get the overall type among isFile, isRomdump, isDisk, isRaw adn isArc. This will be used by ext_option(f) 
    function get_type(ext, flfile) { //flfile set to true for "isFile" for DOS file
        var e = _exts[ext];
        if (!e || ext == "???" || ext == "dat") {
            console.log(" ...get_type() has set file with extension '" + ext + "' to Raw file");
            return "isRaw";
        }
        if (!flfile) {
            if (ext == "arc")
                return "isArc";
            if (e.is_romdump)
                return "isRomdump";
            if (e.is_disk)
                return "isDisk";
        }
        if (e.is_txt || e.is_img || e.is_fontset) //these are not displayed as listing
            return "isTxtImg";
        console.log(" ...get_type() assume that file with extension '" + ext + "' is an Atari DOS File (isFile)");
        return "isFile"; //displayed as listing
    }
    //(PVB END OF ADD)

    var _id = 1;
    var _container_id = 1;
    var _containers = [];
    function get_file(id) {
        var f;
        _containers.forEach(c => c.files.forEach(i => { if (i.id == id) f = i }));
        return f;
    }
    var _shown;

    function save(as_lst) {
        var f = _shown;
        if (as_lst == 2) { //(PVB ADD) [Save as UTF text] Button
            var lst = editor().innerText.split("\n");
            lst = ascii2print(lst);
            save_bytes(f.name + ".txt", lst); //Add .txt extension whatever what was filename.ext
        }
        else if (as_lst == 1) { //(PVB COM) [Save as Atari LST] Button 
            var data = get_ataritext(); //get text from Editor, including text edition & modifications
            var n = f.name;
            if (n.substr(n.length - 4).toLowerCase() == ".bas" || n.substr(n.length - 4).toLowerCase() == ".lst")
                n = n.substr(0, n.length - 4);     // trim ".BAS" // or trim .LST to replace extension by LST
            save_bytes(n + ".LST", data); //no need to add .LST if it is already a LST
        }
        else {
            if (f.packed_img) { //(PVB COM) [Download original file] Button 
                if (f.rgb)
                    save_bytes(f.name + ".rgb", f.rgb);
                else
                    save_bytes(f.name + "." + f.ext, f.packed_img);
            }
            else save_bytes(f.name, f.data);
        }
    }

    //(PVB ADD) new save_as_xxx() functionx
    function save_as_new() {
        var f = _shown;
        save_bytes(f.name + "." + f.ext, f.data);
    }
    function save_as_extract() {
        var f = _shown;
        if (f.extractedData)
            save_bytes(f.name + "_extract.dat" , f.extractedData);
    }
    function save_as_dsk(ext) {
        var f = _shown;
        if (ext == "ATR")
            save_bytes(f.name + ".ATR", f.atr.d);
        if (ext == "XFD") {
            var d = f.atr.d.slice(16);
            save_bytes(f.name + ".XFD", d);
        }
        if (ext == "ALL") { //Save (download) all the valid DOS files // Experimental because limited by the Browser and OS like windows
            var ct;
            if (f.dosdir && f.dosdir.length) {
                _containers.forEach((c, t) => c.files.forEach(i => { if (i.id == f.id) ct = t }));
                var n = _containers[ct].files[_containers[ct].files.length - 1].name; // name of the disk
                _containers[ct].files.forEach((i, t) => {
                    if (i.type != "spacer" && i.type != "isDisk") {
                        var e ='';
                        if (i.ext == 'bat') e = ".txt"; //windows OS Client protection, as bat extension is reserved, so add .txt extension
                        if (i.ext == 'sys') e = ".obj"; //windows OS Client protection, as sys extension is reserved, so add .obj extension
                        if (i.ext == 'com' || i.ext == 'exe') e = ".xex"; //windows OS protection, as com & exe extension are reserved, so add ".xex"
                        e = n + "_" + t + "_" + i.name + e;
                        save_bytes(e, i.data);
                        console.log("save_as_dsk() =>Saving file #" + t + " named " + e + " !");
                    }
                });     
            }
        }
    }
    function save_as_cart() {
        var f = _shown;
        save_bytes(f.name + ".car", f.rom.romData);
        /*if (f.rom.tmpData) save_bytes(f.name, f.rom.tmpData); //Saving the new bank map : See apply_rommap(id)*/
    }
    function save_wo_header() {
        var f = _shown;
        var d = f.rom.romData.slice(16);
        save_bytes(f.name + ".rom", d);
    }
    function save_disassembly(h) {
        var f = _shown;
        var s = "Atari 8-bit rom image file explorer - Listing";
        if (!h) { //request to save in txt format: _txt("#show") get the text (inner text) of the listing display in the html page
            var str = s + "\n\n" + f.name + "\n\n" + _txt("#show") + "\n\nThis text listing is given without any warranty\n";
            str += "PVBestInFoo on @github https://github.com/pvbestinfoo/Atari_8-Bit_Rom_Image_File_Explorer";
            save_bytes(f.name + ".txt", str);
        }
        else { //request to save in html format: get the (inner html) of the listing display in the html page
            var strhtml = `<!DOCTYPE html>
            <html lang="en">
            <head><title>${s}</title>
            <style>`;
            if (h == 2) { //save with the atari font and style, go get the style
                var ff = document.getElementsByTagName("STYLE");
                strhtml += ff[0].innerHTML;
            }
            strhtml += `</style>
            <body>
                <h2>${s}</h2><h3>${f.name}</h3><br />
                <div><pre>`;
            strhtml += document.querySelector("#show").innerHTML;
            strhtml += `</div></pre><br />
            This HTML page may have bugs and is given without any warranty<br />
            <a href="https://github.com/pvbestinfoo/Atari_8-Bit_Rom_Image_File_Explorer">PVBestInFoo on @github</a> 
            </body>
            </html>`;
            save_bytes(f.name + ".html", strhtml);
        }
    }
    //(PVB END OF ADD)
    
    //===================================================================================================
    //===================================================================================================
    // xex/obj disassembly

    //(PVB ADD) the hdx(x) function to shorten the "x.toString(16).toUpperCase()" function !
    function hdx(x) {
        return x.toString(16).toUpperCase();
    }
    //(PVB MOD) improvement of get_xex_segs(): accept several 0xFFFF headers in same file, check segment validity and set error text in segs.err
    function get_xex_segs(a, i, len) {
        //(PVB COM) a = file data, i = 0 (index = offset from beginning of file data) //len = file size
        var segs = [];
        var segnum = 0; //(PVB ADD) segment counter
        var e = i + len; // e is the index of the last byte of the file (+1)
        var err = ""; //(PVB ADD) segment error string
        //(PVB MOD) put the variable declaration before code
        //(PVB COM) test the first 2 bytes
        if (le16(a, i) != 0xFFFF) //(PVB COM) header shall be 0xFFFF for Atari Executable files (COM, EXE, XEX)
            return null; //(PVB COM) This is not an executable file - return !
        //(PVB TODO) handle file without 0xFFFF header but with segments if it exists ?
        if (le16(a, i+2) == 0xFFFF) { //(PVB COM) 2 following 0xFFFF header not allowed - return !
            console.log("get_xex_segs() => 2 following 0xFFFF header are not allowed at beginning of executable file!");
            return null;
        }
        mainlp: while (i < e) {
            segnum ++; //increase the segment counter, it starts at 1
            while (le16(a, i) == 0xFFFF) { //(PVB COM) header 0xFFFF is okay.
                //(PVB COM) 2 consecutive 0xFFFF header should not appear in executable file. If the file must be invalidated, uncomment code
                /*if (le16(a, i+2) == 0xFFFF) {
                    err = "ERROR in segment header! (offset $" + hdx(i+2) + "): 2 consecutive $FFFF header found!";
                    break mainlp;
                }*/
                //(PVB ADD)(PVB MOD) 0xFFFF segments are stored in the 'segs' array, with the number 0xFFFF. Add the "segid" in the 'segs' array.
                seg = { segid: 0xFFFF, start: 0, end: 0, offset: i, len: 2 };
                segs.push(seg); //push the seg in the segs table
                //(PVB end of ADD)
                i += 2; // increase of 2
            }
            if ((e - i) < 4) {
                err = "EOF ERROR in Segment #" + segnum + " definition! (offset $" + hdx(i) + "): not enough data to make a new header";
                err += "\n;  (a header must have 4 bytes, and only " + (e-i) + " bytes left in file!)";
                break; //exit the while loop
            }
            // i is lower that e, this should be a valid segment
            var start = le16(a, i); // then the start address of segment
            var end = le16(a, i + 2); // then the end address of segment
            i += 4; // then at +4 there are the segment data
            var slen = end + 1 - start; // length of data formula, shall be from 1 to max length of file
            console.log("get_xex_segs() => Info: Found segment #" + segnum + " (index $" + hdx(i) + "): $" + hex(start,4) + ":" + hex(end,4) + ", length $" + hex(slen,4) + " bytes");
            if ((slen < 1) || (i + slen > e)){ //check if segment is inconsistent : length shall be 1 at least
                //(PVB ADD)(PVB MOD) check the segment validity
                if (!segs){ //(PVB) in case of there is no segment found after the $FFFF header (should not appear in real life for binary file!)
                    console.log("get_xex_segs() => Info: no valid segment found!"); //(PVB CONSOLE HINT)
                    return null; //(PVB) first segment is not OK, we do nothing and return
                }
                else { //(PVB) in case of there are some segments found
                    //(PVB) save this last not-OK segment with the segs.err error text and return
                    err = "Code segment #" + segnum + " ERROR! $[" + hex(start,4) + ":" + hex(end,4) + "] (offset $" + hdx(i-4) + ")";
                    if (slen < 1)
                        err += ": segment start address is greater that end address!";
                    if (i + slen > e) {
                        err += ": $" + hdx(slen) + " bytes required, but only $" + hdx(e-i) +" bytes left in file!"
                        err += "\n;  ($"+ hdx(i+slen - e) +" bytes are missing in file; expected file size should be $" + hdx(i+slen) + ")";
                    }
                    break;
                }
            } 
            //(PVB end Of add)
            //(PVB MOD) added : "segid" in the 'segs' array
            var seg = { segid:segnum, start: start, end: end, offset: i, len: slen }; //(PVB COM) offset is the memory pointer of the first byte in the segment
            segs.push(seg); //push the seg in the segs table
            i += slen; // i is set for next segment
        } //end of while loop
        if (err) { //if err then save the segment with the error string
            segs.push({ segid:segnum, start: 0, end: 0, offset: i, len: 0, err: err });
            console.log("get_xex_segs() => !" + err); //err contains the error description
        }
        return segs;
    }

    //(PVB ADD)
    var _nBankId = ""; 
    function seg_data(aData, aSeg) {
        var sData = [];
        for (var i = 0; i < aSeg.len; i++) {
            sData[i] = aData[aSeg.offset + i];
        }
        return sData;
    }
    //(PVB MOD) improvement of xex_dump(): handle ROM, entry_points, dump types, disassembly origin
    var _hr = "; ===============================================================================";
    function xex_dump(name, a, i, len, dump_type, org, entry_points) {
        //previously //function xex_dump(name, a, i, len, expect_header, org, entry) { //(PVB COM) expect_header & entry have no use!
        //"name" is name of file; "a" is the UintArray of Data; "i" is the offset index in the Data; "len" is the length of Data to disassemble
        //"dump_type" is the string of the type of Data to disassemble : "HEAD" for binary file with 0xFFFF headers (and "BIN" if no header), "ROM" for ROM, "BOOT" for boot sector
        //"org" = address origin of the disassembly // for dump_type = "BOOT", "org" is the "BLDADDR" boot loading address
        //"entry_points" = array of important addresses to highlight in the disassembly listing:
        // => BCONT address of boot continuation after JUMP $4C (like $714 for DOS); "BINTAD" for Boot Initializarion Address (after a SEC + RTS)
        // => rom_coldstart = CARTCS (cold start at len-6); rom_init = CARTAD (initialisation start vector at len-2) for the "ROM"
        // note : RUNAD (DOS RUN ADDRESS) at $2E0; and INITAD (DOS INIT ADDRESS) at $2E2 for "HEAD" are set in the present function and not pass in entry_points
        var so =""; //(PVB ADD)
        if (name == "DOS.SYS") { //http://data.atariwiki.org/DOC/Inside_Atari_DOS_GBXL.pdf
            org = _shown.dosType == 1 ? 0x0780 : 0x07CB;   //DOS.SYS start loading address according to DOS type
            entry_points = _shown.dosType == 1 ? [0x1300] : [0x1540]; //DOS.SYS entry run address
            so = "; <i>Normal loading address of DOS.SYS set to $" + hex(org,4) + "</i>"; //(PVB ADD)
        }
        else if (dump_type == 'BIN' && name.lastIndexOf(".ROM") >= 0) { //(PVB WIP)// this is a rom calculation for the start address //TODO// maybe add a form input field to enter start address ?
            if ((len & 0xFFF) == 0 && (len >> 12) <= 12) { //len is a multiple of 0x1000, which is 4KB; len >> 12 is number of 4KB, max 48kB in the RAM
                org = (0xC000 - len) & 0xFFFF; //RAM is from 0 to $BFFF
                so = "; <i>Memory Dump binary loading address set to $" + hex(org,4) + "</i>"; //(PVB ADD)
            }
        }
        if (org === undefined || org === 0 ) { //(PVB MOD) check the 'org' disassembly start address 
            org = 0x700;
            so = "; <i>Default loading address set to $0700 for the binary object file</i>"; //(PVB ADD)
        }
        //(PVB COM) memory array for flags and ram
        var flags = new Uint8Array(0x10000);
        var ram = new Uint8Array(0x10000);
        //(PVB ADD) seems to be better to erase arrays, in case of...
        flags.fill(0); 
        ram.fill(0);
        if (org >= 0xFFFF) {
            console.log("xex_dump()=> 'org' error ! value was :" + org);
            org = 0;
        }
        //(PVB MOD & ADD)
        //(PVB MOD) here declaration of the segheader
        var segheader = false;
        //(PVB ADD) here declaration of the is_rom
        var is_rom = false;
        //(PVB ADD) "dump_type" managment
        if (dump_type.lastIndexOf("ROM") >= 0) {
            _nBankId = dump_type.slice(dump_type.indexOf("_") + 1);
            is_rom = true;
        }
        else _nBankId = "";
        if (dump_type == 'HEAD') { //(PVB ADD) if it is "HEAD" => seek the headers; it is not necessary for "SEL", "BOOT", "EXTRACT", and "BIN"
            var segs = get_xex_segs(a, i, len);
            //(PVB COM) segs is an array of n seg (n = 0, 1, ...); Segments are count in "seg.segid", which is is set to $FFFF for header
            //(PVB COM) if segheader is true, there are headers in the "has_header" file type, ohterwise display a direct disassembling starting from "org"
            segheader = segs && (segs.length > 1); //(PVB COM) segheader is OK if segments found above the $FFFF header which is the first 
            //(PVB WIP)// maybe do a better check of the header validity ?
            //if (segheader) { //check validity of header because not checked when extension is forced
            //    if (segs[0].segid == 0xFFFF)
            //        if (segs[1] && segs[1].err) //first segment is faulty
            //                segheader = false;
            //}
            if (!segheader) console.log("xex_dump()=> No segment found, this is not a standalone executable file!");
            else console.log("xex_dump()=> OK, " + segs.length + " segments found, this is a standalone executable file!");
        }
        var lines = [];
        //(PVB ADD) more displayed informations
        /*showDisOption(); ==> now put in render_file()*/
        if (dump_type == 'BOOT') {
            lines.push(_hr);
            lines.push("; <b>Disk Boot program is $" + hdx(len) + " (" + len + ") bytes on " + name + " sectors </b>");
        }
        else if (!is_rom) {
            lines.push("; <b>File '" + name + "' is $" + hdx(len) + " (" + len + ") bytes</b>");
            if (_shown.start && (dump_type == 'HEAD' || dump_type == 'BIN' || !dump_type)) {
                lines.push("; [Start sector: " + _shown.start + " ($" + hex(_shown.start, 3) + "); " + _shown.total + " ($" + hex(_shown.total, 3) + ") blocks]");
            }
            if (dump_type == 'HEAD' && !segheader && name != "DOS.SYS")
                lines.push("; <i>Header and segment were expected in the binary file, nothing valid found</i>");
            if (!segheader) lines.push(so);
            lines.push("");
        }
        //else //(PVB COM) we are in a ROM here !
            //lines.push("; <b>Disassembly of ROM bank at $" + hex(org, 4) + ", size: " + len + " ($" + len.toString(16).toUpperCase() + ") bytes</b>");
        if (!segheader) { //(PVB COM) if no segments, it is not a binary file with header.
            if (dump_type == "BOOT") {
                flags[org + 6] = 0x84; //add the address (org + 6) as an entry_points (flags = 0x84 to for the disassembly address)
                console.log("xex_dump()=> Origin address entry point is: $" + hex(org + 6, 4)); //(PVB CONSOLE HINT)
            }
            if (entry_points) {
                var n = entry_points.length;
                console.log("xex_dump()=> Other entry_points (length=" + n + ") array is:"); //(PVB CONSOLE HINT)
                while (n--) {
                    console.log("   " + n + ": $" + hex(entry_points[n], 4)); //(PVB CONSOLE HINT)
                    flags[entry_points[n]] = 0x84;
                }
            }
            var asms = [];
            asms.push(disassemble(org, a, i, len, ram, flags));
            if (!is_rom)
                lines.push(_hr); //(PVB ADD)
            asms.forEach(asm => disassemble2(asm, lines, ram, flags, false));
        }
        else { //(PVB COM) There are segments
            var s;
            // walk segments, collect entry points
            // draw them all at head, repeat them in body
            segs.forEach(seg => {
                //(PVB MOD) Adding the hyperlinks display 
                var stmp = seg.segid; //(PVB) segment number
                if (stmp == 0xFFFF) { //(PVB) this is an header 
                    s="; Header 0xFFFF at file offset $" + hdx(seg.offset);  //(PVB ADD)
                }
                else if (!seg.err) { // this is not a header but a displayable segment of code
                    s = "; Code <a id='BKTOSEG" + stmp + "' href='#FWTOSEG" + stmp + "'>segment \#" + stmp + "</a>";  // hyperlink to the segment disassembly
                    s += "  $[" + hex(seg.start, 4) + ":" + hex(seg.end, 4) + "]";
                    s += ", total $" + hdx(seg.len) + " (" + seg.len + ") bytes, at offset $" + hdx(seg.offset); //(PVB) ajout hexa $ et valeur
                }
                else s = ""; //here (stmp == -1) nothing to display for the faultly indisplayable segment (except error text below)
                switch (seg.start) {
                    case 0x2E0: //RUNAD (DOS RUN ADDRESS) at $2E0 (736)
                        flags[seg.run = le16(a, seg.offset)] = 0x84; //(PVB ADD) flagged as an entry point for disassembly listing
                        if (seg.len == 4) { // if the len is 4, then 2E0 to 2E3 are initialized within the same segment
                            flags[seg.initialize = le16(a, seg.offset + 2)] = 0x84;
                            seg.note = " -> initialize at $" + hex(seg.initialize, 4) + ", run at $" + hex(seg.run, 4); // (PVB) rajout hexa $ et valeur hexa
                        } else
                            seg.note = " -> run at $" + hex(seg.run, 4); //(PVB MOD) hexa $ display
                        break;
                    case 0x2E2: //INITAD (DOS INIT ADDRESS) at $2E2 (738)
                        flags[seg.initialize = le16(a, seg.offset)] = 0x84; //(PVB ADD) flagged as an entry point for disassembly listing
                        seg.note = " -> initialize at $" + hex(seg.initialize, 4); //(PVB MOD) hexa $ display
                        break;
                }
                if (seg.note) s += seg.note;
                if (s) lines.push(s);
                if (seg.err) lines.push(';<span style="color:red;"> => ' + seg.err + '</span>'); //display the error if there is an error in segment
            });
            lines.push('');

            // Do the disassembly, first pass
            var asms = {};
            console.log("xex_dump()=> Time for 1st PASS !");
            segs.forEach(seg => {
                if (seg.segid != 0xFFFF && !seg.err) { //(PVB) if segment number is not the header, and not a faultly indisplayable segment
                    console.log("xex_dump()=> DISASS 1st PASS of SEGMENT #" + seg.segid + " > " + hex(seg.start, 4) + ":" + hex(seg.end, 4));
                    asms[seg.segid] = disassemble(seg.start, a, seg.offset, seg.len, ram, flags);  // disassemble the segment with first pass
                }
            });
            console.log("xex_dump()=> Time for 2nd PASS !");
            // Complete the disassembly, second pass
            segs.forEach(seg => {
                //lines.push(hr); //(PVB ADD) more char
                //(PVB MOD) Adding the hyperlinks display
                var stmp = seg.segid; //(PVB COM) segment display
                if (seg.segid != 0xFFFF) { //&& !seg.err) { //(PVB COM) if segment number is not the header, and not a faultly indisplayable segment
                    lines.push(_hr);
                    s = "<span id='FWTOSEG" + stmp + "'>; Code segment \#" + stmp + "<a href='#BKTOSEG" + stmp + "'>(back)</a></span>";  // hyperlink to the segement
                    s = s + ": $" + hdx(seg.len) + " (" + seg.len + ") bytes at $" + hex(seg.start, 4) + ":" + hex(seg.end, 4); // (PVB) hexa $ and value display
                    if (seg.note)
                        s += seg.note;
                    lines.push(s);
                    if (seg.err)
                        lines.push(';<span style="color:red;"> => ' + seg.err + '</span>');
                    lines.push(_hr); //(PVB ADD) more char
                    lines.push('');
                    if (asms[seg.segid]) {
                        console.log("xex_dump()=> DISASS 2nd PASS of SEGMENT #" + seg.segid + " > " + hex(seg.start, 4) + ":" + hex(seg.end, 4));
                        disassemble2(asms[seg.segid], lines, ram, flags, seg.segid, seg_data(a, seg), seg.start); // disassemble the segment with 2nd pass
                    }
                }
            });
        }
        if (!is_rom)
            lines.push(';<i>End of disassembly \><a href="#top">Back to top</a></i>');
        return lines.join("\n");
    }

    //===================================================================================================
    // (PVB COM) Class declaration of the different possible Disk Images

    class PRO {
        static
        is_pro(d) {
            var s = toAscii(d, 2, 2);
            return s == "P2" || s == "P3";
        }

        static
        to_atr(d) {
            var sector_total = (d[0] << 8) | d[1];
            var sector_count = (d[6] << 8) | d[7];
            if (sector_count == 0)
                sector_count = 720; // p2?
            var sector_size = 128;
            var size = sector_count * sector_size;

            var atr = new Uint8Array(16 + size);
            atr[0] = 0x96; //150 //(PVB COM) $0296 (checksum of 'NICKATARI')
            atr[1] = 0x02; //02
            atr[2] = (size >> 4) & 0xFF;
            atr[3] = (size >> 4) >> 8;
            atr[4] = sector_size & 0xFF;
            atr[5] = sector_size >> 8;
            atr[6] = (size >> 4) >> 16;
            var dst = 16;
            for (var i = 0; i < sector_count; i++) {
                var src = 16 + 12 + (12 + sector_size) * i;
                var n = sector_size;
                while (n--)
                    atr[dst++] = d[src++];
            }
            return atr;
        }
    }
    
    //(PVB ADD) the calChkSum(d, i) for calculating the checksum of data array "d" from position "i"
    function calChkSum(d, i) {
            var chksm = 0;
            while (i < d.length)
                chksm += d[i++];
            return chksm;
    }
    //(PVB ADD) add the ROM class, its constructor and additional functions
    class ROM {
        is_cart(d) {
            if (le32(d,0) == 0x54524143) // 'ATASCII code of Cart signature 'C' 'A' 'R' 'T'
                if ((d.length - 16) && 0x3FF) {
                     //var i = 0;
                    var tchksm = (d[8] << 24) | ((d[9]) << 16) | ((d[10]) << 8) | (d[11]);
                    var chksm = calChkSum(d, 16);
                    console.log("ROM Constructor ==>checksum in rom $" + tchksm.toString(16) + " vs $" + chksm.toString(16));
                    if (tchksm != chksm)
                         console.log("ROM Constructor ==>Error : checksum does not match !!");
                    return true;
                    }
            return false;
        }
        to_cart(d) {
            var cartRom = new Uint8Array(16 + d.length);
            cartRom[0] = 0x43; //67 "C"
            cartRom[1] = 0x41; //61 "A"
            cartRom[2] = 0x52; //82 "R"
            cartRom[3] = 0x54; //84 "T"
            for (var i = 4; i < 16; i++)
                cartRom[i] = 0; //at this stage : unkown type is 00 in header [7]
            //set the checksum
            var chksm = calChkSum(d, 0);
            console.log("ROM Constructor ==>calculated checksum is $" + chksm.toString(16));
            cartRom[8] = (chksm >> 24) & 0xFF;
            cartRom[9] = (chksm >> 16) & 0xFF;
            cartRom[10] = (chksm >> 8) & 0xFF;
            cartRom[11] = chksm & 0xFF;
            cartRom.set(d, 16);
            return cartRom;
        }
        constructor(d, name) {
            var re;
            var len = d.length;
            this.romData = d;
            this.isCart = this.is_cart(d);
            if (this.isCart) { // this is a CART due to size and CART signature
                if (d[7] > 0 && d[7] < 76) { //signature = type if CART ROM, according to https://github.com/atari800/atari800/blob/master/DOC/cart.txt
                    this.romType = d[7];
                    console.log("ROM Constructor ==>Cart Rom Type is " + this.romType);
                }
                else { //no valid signature
                    this.romType = 0;
                    console.log("ROM Constructor ==>Cart Rom Type is unknown in the CART !!");
                }
                re = ( (this.romType < 10) ? "Type_0" : "Type_" ) + this.romType;
                // TODO tester si re est dans la liste ...
                this.romName = _romtypes[re].name;
                this.romMachine = _romtypes[re].machine;
                this.romKBSize = _romtypes[re].size;
                if (this.romKBSize != (d.length >> 10))
                    console.log("ROM Constructor ==>CART Rom size in KB mismatch as not a KB multiple !!");
                else
                    console.log("ROM Constructor ==>OK CART Rom type is valid with size...");
                this.romMachine = _romtypes[re].machine;
                this.romMap = _romtypes[re].memmap;
                this.romTypeTxt = re;
            }
            else { //this is not a CART, so there are no 16 bytes header
                console.log("ROM Constructor ==>This is not a CART ROM");
                if (len & 0x3FF) {
                    console.log("ROM Constructor ==>ROM size " + len + " is not a multiple of KB !!");
                    // modifier romLen ???
                }
                this.romData = this.to_cart(d); //conversion
                this.romType = 0;
                this.romTypeTxt = "Type_00";
                if (name.includes(".a52"))
                    this.romMachine = "5200";
                else
                    this.romMachine = "800/XL/XE";
                this.romKBSize = '' + (d.length >> 10);
                switch (len) { //romMap = memmap: [size in page, start address in page, number of bank at same address]
                    case 0x0800: //2K use for A5200 ROM 
                        this.romMap = [0x08, 0xF8, 1];
                        this.romMachine = "5200";
                        console.log("ROM Constructor ==>Using the 2K ROM Mapping for A5200!");
                        break;
                    case 0x1000: //4K default 
                        this.romMap = [0x10, 0xB0, 1];
                        break;
                    case 0x2000: //8K use for ATARI BASIC ROM ROM 
                        this.romMap = [0x20, 0xA0, 1];
                        break;
                    case 0x2800: //10K use for ATARI OS A/B 
                        this.romMap = [0x28, 0xD8, 1];
                        console.log("ROM Constructor ==>Using the 10K ROM Mapping for OS A/B ROM!");
                        break;
                    case 0x4000: //16k use for XE/XL OS ROM
                        this.romMap = [0x40, 0xC0, 1];
                        console.log("ROM Constructor ==>Using the 16K ROM Mapping for XL/XE OS ROM!");
                        break;
                    case 0x8000: //32k only works for an A5200 ROM that can start at $4000; 32KB OS for XEGS not supported yet due to its special mapping
                        this.romMap = [0x80, 0x40, 1];
                        break;
                    default: //use a default mapping, n 4K banks in B000-BFFF
                        this.romMap = [0x10, 0xB0, len >> 12]; //'>> 12' is eq to divide by 0x1000
                        console.log("ROM Constructor ==>Using default mapping (n 4K banks in B000-BFFF)!");
                }
                this.romName = "Unknown cartridge for " + this.romMachine + "? => set to default / OS ROM";
            }
        }
    }
    //(PVB end of ADD)

    class XFD {
        static
        is_xfd(d) {
            //(PVB MOD) Modified : no rule for data in XFD image, since it's just an Atari raw disk image file.
            //Hence to be an XFD, image size shoud only be equal a disk size.
            //note : 256*720 stands for buggy image that considers the 3 first sectors may be 256 bytes on double density disk
            //https://forums.atariage.com/topic/123109-atr-format-reference/
            //https://forums.atariage.com/topic/293817-first-3-disk-sectors-always-128-bytes/
            //previously //return (le16(d,0) == 0x0300) && (le16(d,2) == 0x0700);    
            if ((d.length == 720*128) || (d.length == 3*128 + (720-3)*256) || (d.length == 1040*128) || (d.length == 720*256) || (d.length == 3*128 + (2*720 - 3)*256))
                return true;
            //(PVB end of MOD)
        }

        static
        to_atr(d) {  // (PVB) append header to raw atrs or new raw XFD = convert the XFD into ATR
            //(PVB COM) assume the defaut is Single Density disk:
            var sector_total = 720; // raw image was 702 sectors... typo of 720?
            var sector_size = 128;
            //(PVB) Enhanced Density disk:
            if (d.length == 1040*128)
                sector_total = 1040;
            //(PVB) Double Density disk:
            if ((d.length == (128*3 + (720-3)*256)) || (d.length == 256*720)) { //(PVB MOD) Correct the Double Density which has 717+3 sectors) + buggy XFD with 256*720 :
                sector_total = 720;
                sector_size = 256;
            }
            //(PVB ADD) Double Sided, Double Density disk:
            if ((d.length == (3*128 + (2*720 - 3)*256))) {
                sector_total = 1040; 
                sector_size = 256;
            }
            //(PVB end of ADD)  
            var size = sector_total * sector_size;
            var atr = new Uint8Array(16 + size);
            atr[0] = 0x96; // (PVB COM) $0296 (sum of 'NICKATARI')
            atr[1] = 0x02;
            atr[2] = (size >> 4) & 0xFF;
            atr[3] = (size >> 4) >> 8;
            atr[4] = sector_size & 0xFF;
            atr[5] = sector_size >> 8;
            atr[6] = (size >> 4) >> 16;
            atr.set(d, 16);
            return atr;
        }
    }

    class ATX {
        static
        is_atx(d) {
            return toAscii(d, 0, 4) == "AT8X";
        }

        static
        to_atr(d) {
            if (!ATX.is_atx(d))
                return null;
            var atx = new ATX(d);
            var atr = new Uint8Array(16 + atx.size);
            var sector_count = 720;

            atr[0] = 0x96;   //(PVB COM) $0296 (sum of 'NICKATARI')
            atr[1] = 0x02;
            atr[2] = (atx.size >> 4) & 0xFF;
            atr[3] = (atx.size >> 4) >> 8;
            atr[4] = atx.sector_size & 0xFF;
            atr[5] = atx.sector_size >> 8;
            atr[6] = (atx.size >> 4) >> 16;
            var dst = 16;
            for (var i = 0; i < sector_count; i++)
                dst = atx.readsector(i, atr, dst);
            return atr;
        }

        constructor(d) {
            this.d = d;
            this.sector_size = 128;
            this.tracks = [];
            var t = le32(d, 28);
            while (t > 0 && t < d.length) {
                var track = { toff: [] };
                track.offset = t;
                track.size = le32(d, t);
                track.type = le16(d, t + 4);
                track.tracknum = d[t + 8];
                track.sectorcount = le16(d, t + 10);
                track.headersize = le32(d, t + 20);
                track.sectorlistsize = le32(d, t + 32) - 8;
                for (var i = 0; i < 16; i++)
                    track.toff[i] = 0;
                var sl = t + 40;
                for (var i = 0; i < track.sectorlistsize; i += 8) {
                    var dat = le32(d, sl + i + 4);
                    if (dat && d[sl + i])
                        track.toff[d[sl + i] - 1] = dat;
                }
                this.tracks.push(track);
                t += track.size;
            }
            this.size = 720 * this.sector_size;
        }

        readsector(n, dst, dsti) {
            var d = this.d;
            var track = n / 18 | 0;
            var ss = this.sector_size;
            this.tracks.forEach(t => {
                if (t.tracknum == track) {
                    var dat = t.toff[n % 18];
                    if (dat) {
                        for (var i = 0; i < ss; i++)
                            dst[dsti + i] = d[t.offset + dat++];
                    }
                }
            });
            return dsti + this.sector_size;
        }
    }
    
    //(PVB MOD & ADD) improvement of the features of the SpartaDOS class functions
    class SpartaDOS { //(PVB COM) see http://atariki.krap.pl/index.php/Format_SpartaDOS for details
        constructor(atr) {
            var d = atr.d;
            this.atr = atr;
            this.boot = {
                sector_map: le16(d, 16 + 9),       // $09-$0A/Sector, where is the first Sector map of the main directory.
                sector_count: le16(d, 16 + 11),    // $0B-$0C/Number of every sectors on the disk
                free_sectors: le16(d, 16 + 13),    // $0D-$0E/Number of free sectors
                bitmaps: d[16 + 15],               // $0F/Number of sectors of the Bitmaps
                first_bitmap: le16(d, 16 + 16),    // $10-$11/Sector used for the first Bitmap.
                sector_file: le16(d, 16 + 18),     // $12-$13/The first sector, where may be allocated a data sector for a file
                sector_dir: le16(d, 16 + 20),      // $14-$15/The first sector, where may be allocated a data sector for a directory
                volume_name: toAscii(d, 16 + 22, 8).trim(),  //$16-$1D/Volume name
                tracks: d[16 + 30],                // $1E/Number of tracks; when the bit D7 is set, then the drive is double
                sector_size: d[16 + 31] ? 128 : 256,// $1F/Size of sectors ($80 = 128 bytes; 0 == 256 bytes) [NOTE if 1 == 512 bytes -- not handled by the Tool !]
                version: d[16 + 32],               // $20/version ($11 - created by SpartaDOS 1.x; $20 for SpartaDOS 2.x, 3.x, DOS X 4.1x/4.2x
                                                   // SpartaDOS X >= 4.39 gives $21 here (version 2.1 filesystem)...
                sequential: d[16 + 38],            // $26/This number is incremented every time you're making any changes on the disk
                random: d[16 + 39],                // $27/Random number of the disk. This number is created while formatting the disk.
                boot_sector: le16(d, 16 + 40)      // $28-$29/Sector of the DOS file, where is the first Sector map of file specified for booting
            } //$21-$25/other significant bytes; $2A/diskette write protection indicator ($00 - unlocked, $FF - protected) 
            this.file_info = {};
            this.fcount = 0;
        }

        // first entry in directory is information about the directory itself
        // start == parent;
        get_dir(sector_map, dir_name) {
            sector_map = sector_map || this.boot.sector_map;
            if (!dir_name) dir_name = "MAIN"; 
            var dir = this.read_file(sector_map); // secor_map is the sector map of a directory
            var files = [];
            var dir_info;
            var isMain = false;
            var sector_size = this.boot.sector_size;
            console.log(`SPARTA => ...entering directory at ${sector_map}, nammed ${dir_name}`);
            //this is a directory
            for (var i = 0; i < dir.length && dir[i+6]; i += 23) { //if dir[i+6] == 0, there is no more entry as an empty filename
                if (i == 0) { //first entry is for MAIN dir, it contains information about the directory itself
                    dir_info = {
                        flags: dir[i],              //$00/value $00 in SpartaDOS 3 and BW DOS, $A8 in Sparta 4.2x; $28 in Sparta 4.4x
                        parent: le16(dir, i + 1),   //$01-$02/parent directory sector map, $0000 if main disk directory (MAIN)
                        len: le24(dir, i + 3),      //$3-$05/length of directory file in bytes, 00036A for exemple
                        name83: toAscii(dir, i + 6, 8), //$6-$10/dir name, "MAIN" for the first
                        name: toAscii(dir, i + 6, 8).trim(),
                    }
                    //(PVB ADD)
                    if (!this.main_dir_info) { //just for MAIN
                        isMain = true; //just to get MAIN as a file to display it
                        dir = dir.slice(0, dir_info.len);
                        this.main_dir_info = dir_info;
                    }
                    else continue; //skip the following file identification because it's a DIR
                }
                //else// at byte offset 23/46/69...$17/$2E/...
                /* (PVB MOD) 0x00 > End of Directory
                0x01 > entry is protected;    0x02 > hidden (Sparta>4.0)
                0x04 > archived (Sparta>4.0); 0x08 > entry (file or dir) in use (not deleted)
                0x10 > Erased (not is use);   0x20 > entry is a (sub)directory
                0x40 > (res. Sparta 4.49e);   0x80 > entry open for writing */
                /*previously// var flags = (dir[i] & 0x04) ? 0 : 0x42;*/ //convert flags to standard DOS ?
                var flags = isMain ? 0x20 : dir[i];
                /*previously//if (dir[i] & 1) flags |= 0x20;  // locked*/ //convert flags to standard DOS ?
                var f = {
                    numidf: this.fcount++, //(PVB ADD)
                    flags: flags,
                    valid: 2, //(PVB MOD) previously //valid: true, 2 is file OK, 1 is for beeing displayed only in #show
                    start: isMain ? sector_map : le16(dir, i + 1),    //start sector for file map or subdirectory
                    len: le24(dir, i + 3),      //len in bytes (PVB TODO) check if it can be cancelled because of fsize
                    fsize: le24(dir, i + 3),    //(PVB ADD)
                    name83: toAscii(dir, i + 6, 11),
                    name: toAscii(dir, i + 6, 8).trim(),
                    date: le24(dir, i + 17),    //$11-$13/entry creation date in DD/MM/YY
                    time: le24(dir, i + 20),    //$14-$16/entry creation time in HH/MM/SS
                    dir_name: isMain ? "NO PARENT" : dir_name,  //(PVB ADD) parent directory name 
                    is_dir: (dir[i] & 0x20)     //is it a (sub)directory ?
                }
                var ext = toAscii(dir, i + 14, 3).trim();
                if (ext.length)  //make full name with dot like "TOTO.BAS"
                    f.name += '.' + ext;

                f.sectors = [];
                f.maps = []; //(PVB ADD)
                    //(PVB ADD) Adding the deleted file handling
                if (flags & 0x10) {
                    f.valid = 1;
                    f.err = " =>SpartaDOS deleted file ($10 flag)";
                }
                else {
                    this.file_info[f.start] = f; // we know the length
                    var sec = this.get_sectors(f.start);
                    for (var j = 0; j < sec.sectors_file.length; j++) {
                        f.sectors.push({
                            sector: sec.sectors_file[j],
                            len: Math.min(sector_size, f.len - j * sector_size),
                            offset: j,
                            fbloc: j //(PVB ADD)
                        });
                    }
                    //(PVB ADD)
                    for (var j = 0; j < sec.sectors_map.length; j++) {
                        f.maps.push({
                            map: sec.sectors_map[j],
                            fbloc: j
                        });
                    }
                }
                f.total = f.sectors.length;
                f.total_map = f.maps.length; //(PVB ADD)
                files.push(f);
                console.log(`SPARTA => File #${f.numidf} ${f.name} with flag $${hex(flags,2)} recorded !`);
                // recurse get_dir if a file is a subdirectory
                if (f.is_dir && !isMain) {
                    console.log(`SPARTA => Directory #${f.numidf} ${f.name} exploration...`);
                    files = files.concat(this.get_dir(f.start, f.name));
                }
                isMain = false; //reset MAIN "as a file"
            }
            return files;
        }

        // get all the sectors associated with a file or a directory
        get_sectors(sector_map) {
            var atr = this.atr;
            var d = atr.d;
            var sector_size = this.boot.sector_size;
            // format of sector_map is next:prev:s:s:s.... 16 bit entries
            // next == 0 this is last sector map; prev == 0 this is first sector
            var sectors_file = [];
            var sectors_map = []; //(PVB ADD)
            while (sector_map) {
                var sm = atr.sector_offset(sector_map);
                sectors_map.push(sector_map); //(PVB ADD)
                for (var i = 2; i < sector_size / 2; i++) {
                    var s = le16(d, sm + i * 2);
                    if (!s) //stop fetching sector map if sector == $0000
                        break;
                    sectors_file.push(s);
                }
                sector_map = le16(d, sm);    // next sector of sector map
            }
            return {sectors_file : sectors_file, sectors_map : sectors_map}; //(PVB MOD)
        }

        read_file(sector_map) {
            var atr = this.atr;
            var file_info = this.file_info[sector_map];
            var d = atr.d;
            var dst = [];
            this.get_sectors(sector_map).sectors_file.forEach(s => { //(PVB MOD)
                var src = atr.sector_offset(s);
                for (var i = 0; i < this.boot.sector_size; i++)
                    dst.push(d[src + i]);
            });
            if (file_info && !file_info.is_dir) //(PVB COM) not for directory
                dst.length = file_info.len;   // clip it if we know the size
            return new Uint8Array(dst);
        }
    }

    //(PVB COM) ATARI DOS file flags
    //see http://ftp.pigwa.net/stuff/collections/nir_dary_cds/Tech%20Info/DOS.HTM (not accurate enough)
    //and for DOS 3 : https://www.atarimax.com/jindroush.atari.org/afsdos3.html (not accurate neither !)
    // SO USE THIS MUST LINK => http://atariki.krap.pl/index.php/Formaty_system%C3%B3w_plik%C3%B3w
    //0x80 value: File (or MyDOS DIRECTORY) deleted for any DOS (all other bits are cleared) (may be recovered if not overriden ?)
    //0x40 bit 6: File exits and in use for any DOS (normal), then bit 7 is clear. Bit cleared for a MyDOS DIRECTORY.
    //0x20 bit 5: File Locked (protected from overwriting and deleting) for any DOS (appears with '*' in directory).
    //0x10 bit 4: bit set only for MyDOS DIRECTORY (bits 6, 2 and 1 then have the value 0)
    //0x08 bit 3: not used
    //0x04 bit 2: is used by MyDOS only, if set means that file has a 16bits sector linking (MyDOS non-DOS2x compatible)
    //0x02 bit 1: is set, file created by DOS2x (if cleared, file created by DOS1). Set also fo a MyDOS file.
    //0x01 bit 0: File Opened for Output for any DOS. Used also by DOS2.5 to indicate that files is stored above sector 719 (and shown with <..>)
    //examples:
    // DOS1: $40=file exists, $60=write-protected file, and $80=file deleted. DOS2: $42=file exists, $62=write-protected file.
    // DOS2.5: $42=existing file available for DOS 2.0;$62= write-protected file available for DOS 2.0;
    //  $03=existing file not available for DOS 2.0;$43=file open for writing and never closed
    // MyDOS: $42 or $46 means an existing file, $62 or $66 - a read-only file, $10 - a directory, $80 - a file or directory deleted
    // DOS3: status of an existing file is $C0, a protected file is $C2, and a deleted file is $80.
    
    // For ATR structure see: http://www.atarimax.com/jindroush.atari.org/afmtatr.html

    class ATR {
        //(PVB ADD) is_atr(d) function to check if data d is an atr file
        static
        is_atr(d) {
            var sig = le16(d, 0); //(PVB COM) signature (2 first bytes)
            if (sig == 0x0296) //(PVB COM) $0296 (sum of 'NICKATARI') [MSB 150; LSB 2]
                return true;
        }
        //(PVB END OF ADD)
        constructor(d, name) {
            //(PVB COM) "d" is the disk image file data; "name" is the filename like "FoO.Ext"
            if (ATX.is_atx(d))
                d = ATX.to_atr(d); // Convert ATX into ATR
            else if (PRO.is_pro(d))
                d = PRO.to_atr(d); // Convert PRO into ATR
            else if (XFD.is_xfd(d))
                d = XFD.to_atr(d); // Convert XFD into ATR
            //(PVB ADD) convert raw data file loaded into the Client, with XFD or ATR extention, but without any known format, into an ATR disk
            else if (!ATR.is_atr(d)) {
                console.log("ATR Constructor() => name '" + name + "' is not ATX, nor PRO, nor XFD, nor ATR !!! => Convert it into a disk with 6 bytes of boot.."); //(PVB CONSOLE HINT)
                var m = d.length;
                if (m > (92160 - 6)) { //128*720 bytes (minus 6 bytes for boot)
                    m = 92160 - 6; //clipped !
                    console.log("ATR Constructor() => '" + name + "' size is above 9260 b1ytes !! => Clip its data to size the ATR disk..."); //(PVB CONSOLE HINT)
                }
                var z = new Uint8Array(92160); //create a new 92160 bytes disk (default size)
                z.set([0, 0x03, 0, 0x07, 0x06, 0x07]); //put a "standard" boot header 3 sectors at $1000
                z.set(d.subarray(0, m), 6); //copie the rest of data (maximum m = 92160 - 6) // remaining data are clipped
                d = XFD.to_atr(z); //add the ATR header
                this.restructured = true; //flag for identifyong the making of the ATR file from scratch data
            }
            //(PVB COM) "else" here this is an ATR file, obviously
            //(PVB END OF ADD)
            //(PVB MOD the size and sector count)
            this.d = d;
            this.name = name;
            this.size = (le16(d, 2) + (d[6] << 16)) << 4;
            this.sector_size = le16(d, 4);
            this.sector_count = (this.size - 128 * 3) / this.sector_size + 3;
            this.dir_sector = 0; //(PVB COM) by default, no directory sector
            if (!this.restructured) {
                //(PVB COM) check bytes for a SpartaDOS compatible disk (see http://atariki.krap.pl/index.php/Format_SpartaDOS )
                if (d[16 + 6] == 0x4C && (d[16 + 32] == 0x11 || d[16 + 32] == 0x20 || d[16 + 32] == 0x21)) { //SpartaDOS: the Jump and the versions
                    if (d[16 + 7] == 0x80) { //byte #7 of the 1st sector contains $80 in a SpartaDOS compatible disk with 128 or 256 bytes/sector
                        console.log("ATR constructor() => has found a SpartaDOS compatible disk!"); //(PVB HINT)
                        this.sparta = new SpartaDOS(this);
                        this.vtoc1_sect = this.sparta.boot.first_bitmap; //(PVB ADD)
                    }
                    else if (d[16 + 7] == 0x40 && d[16 + 31] == 1) //SpartaDOS byte #7 is $40, and 512 byte/sector: compatible and not handle by the tool
                        console.log("ATR constructor() => has found a 512 bytes/sector SpartaDOS disk => NOT SUPPORTED by the tool, normal DOS will be used!"); //(PVB HINT)
                }
            }
            //(PVB ADD) identify DOS type
            this.dosType = this.identify_dos();
            if (this.dosType == 3) this.isDos3 = true; //to simplify logic test in case of specific DOS3
            console.log("ATR constructor() => identify_dos returns ATR.dosType = " + this.dosType); //(PVB HINT)
            console.log("ATR constructor() => ATR construction done !"); //(PVB HINT)
        }

        sector_offset(n) {    // 1 based (first sector is number 1 (and not 0)
            //(PVB COM) sector_offset(n) computes the memory pointeur for sector 'n' into the ATR 'data'
            n--;
            if (n < 3) //(PVB COM) first 3 sectors for boot are always 0x80 bytes
                return 16 + n * 0x80; //(PVB COM) 16 = for ATR header bytes
            return 16 + 3 * 0x80 + (n - 3) * this.sector_size; //(PVB COM) 16 are for ATR header bytes, plus 3 * 0x80 bytes for 3 sectors of boot
        }

        //(PVB ADD) read_sector() function, to read any raw sector from the disk
        read_sector(n) {
            var offset = this.sector_offset(n);
            var d = this.d;
            var sectordata = [];
            if (n < 3)
                sectordata = d.slice(offset, offset + 128);
            else
                sectordata = d.slice(offset, offset + this.sector_size);
            return sectordata;
        }
        
        //(PVB END OF ADD)

        //(PVB MOD) one_dir() improvement, MyDOS subdirectories support, and DOS3 support
        one_dir(n, sector, idf, subdirname) {// one_dir() is called by get_dir_range() and scan_files()
            // (PVB COM) 'n' is the dir entry (1 to 8) into the directory 'sector'; idf is the count of file (file number in the directory)
            // that is also use in DOS file sector control byte; "subdirname" parameter is the name of the parent's MyDOS subdirectory
            //previously // sector = sector || 361;
            var m = 32; //(PVB CONSOLE HINT) limits the consolelog event display for the 32 first directory entry
            var d = this.d;
            var j = this.sector_offset(sector + (n >> 3)) + (n & 7) * 16; //index in the memory for the start of sector n  
            var dirEntry = [];
            var tdos = this.dosType; // to simplify
            if ((tdos != 5) && (is_zero(d, j, 16))) { ///WIP// check consistency of tdos == 5, and this code is already below line 6342
                if (idf < m) console.log(" one_dir() =>Error! File#" + idf + " entry is $00 bytes into DOS TOC!"); //(PVB CONSOLE HINT)
                else console.log(" one_dir() =>Error! Entry is $00 bytes into DOS TOC!");
                return dirEntry; //no dir entry, 16 times $00 bytes found on the dir entry
            } 
            if (tdos == 3) // for DOS 3
                dirEntry = {
                numidf: idf, // (PVB ADD) the idf to count & identify files
                flags: d[j],  //(PVB) Byte 0 : Flag Byte of the DOS3 file: 0xC2 is OK, 0xC1 file exists and is open, 0x80 deleted, 00 no entry, bit 0x02 file is protected
                total: d[j +12], // Byte 12 : Total number of block (1 block = 8 sectors)
                startbloc: d[j +13], // Byte 13 : start block byte.
                start: d[j +13] * 8 + 25, // "start" = Startsector = start block byte * 8 + 25; Starting sector number of the DOS file
                fsize: le16(d, j +14), //size of the file in bytes (last 16 bits)
                name83: toAscii(d, j +1, 11), // Byte 5-15 : 11 char = 8 character filename padded with spaces at end + 3 character filename extension padded with spaces at end
                name: toAscii(d, j +1, 8).trim(), // Byte 1-8 : 8 character filename padded with spaces at end
                ext: toAscii(d, j +9, 3).trim() // Byte 9-11 : 3 character filename extension padded with spaces at end
                };
            else // for ATARI DOS1 & DOS2X and MyDOS
                dirEntry = {
                numidf: idf, // (PVB ADD) the idf to count & identify files
                flags: d[j],  // Byte 0 : Flag Byte of the DOS2 file
                total: le16(d, j +1), // Byte 1-2 : Total number of sectors of DOS file. 
                start: le16(d, j +3), // Byte 3-4 : Starting sector number of the DOS file.
                fsize: 0, // filesize in bytes default value 0 : dirEntry.fsize will be compute with the read_file() result in load_data()
                name83: toAscii(d, j +5, 11), // Byte 5-15 : 11 char = 8 character filename padded with spaces at end + 3 character filename extension padded with spaces at end
                name: toAscii(d, j +5, 8).trim(), // Byte 5-12 : 8 character filename padded with spaces at end
                ext: toAscii(d, j +13, 3).trim(), // Byte 13-15 : 3 character filename extension padded with spaces at end
                dir_name: subdirname ? subdirname : "" //add parent's name if in a subdirectory (for MyDOS)
                };

            if (dirEntry.ext)
                dirEntry.name += '.' + dirEntry.ext; //"name" is like "dup.sys", without space but with ".ext"
            //(PVB MOD) cancelled to change the handling of flags
            //previously //dir.valid = (dir.flags & 0x40) != 0 && !(dir.flags & 0x8C);  // Valid File Flag
            //(dir.flags & 0x80) == 0;
            //(PVB MOD & ADD) Improvement of DOS file detection and validation
            //previously//
            /*dir.valid = dir.valid && (dir.total < this.sector_count) && (dir.start < this.sector_count);
            dir.valid = dir.valid && dir.total && (dir.start > 3);*/

            dirEntry.valid = 2; //1 is valid (readable) and to be listed with error, 0 is not valid, 2 is OK fully valid (no error)

            //following 2 conditions to check are the minimum to get a file from the dir entry: a valid name & a consistant start sector
            var title = (tdos != 3) ? d.slice(j +5, j +16) : d.slice(j +1, j +12); //name in Atacii
            var isName = isAtariNameChar(title, this.dosType == 7); //is that name is valid with atari char text ?
            if (is_zero(d, j, 16)) {
                dirEntry.valid = 0;
                if (idf < m) //(PVB CONSOLE HINT)
                    console.log(" one_dir() =>Error! File#" + idf + ": has only zero into DOS TOC entry!"); //(PVB CONSOLE HINT)
            }
            else if (!isName) {
                dirEntry.valid = 0;
                if (idf < m) //(PVB CONSOLE HINT)
                    console.log(" one_dir() =>Error! File#" + idf + ": has a name with invalid chars!"); //(PVB CONSOLE HINT)
            }
            else if ((dirEntry.start < this.file_start) || (dirEntry.start > this.sector_count)) {
                dirEntry.valid = 0;
                if (idf < m) //(PVB CONSOLE HINT)
                    console.log(" one_dir() =>Error! File#" + idf + ": inconsistent start sector! ($" + hex(dirEntry.start, 3) + ")"); //(PVB CONSOLE HINT)
            }
            if (!dirEntry.valid) return [];

            //dir.total is checked below while reading sectors of the file
            //here filename is valid, dans start sector is OK
            dirEntry.err = ''; // text of error in cas of
            if (d[j] == 0x80) {
                dirEntry.err += " >deleted file ($80 flag)"
                if (idf < m) //(PVB CONSOLE HINT)
                    console.log(" one_dir() =>Info: File#" + idf + ": " + dirEntry.name + " is a deleted file that could be wrong!"); //(PVB CONSOLE HINT)
            }
            else if (tdos > 5 && d[j] & 0x10 && dirEntry.total == 8) { //MyDOS subdirectory handling (flag = 0x10, 8 sectors length)
                dirEntry.is_dir = true;  //it's a MyDOS subdirectory
                dirEntry.sectors = []; //add subdir sectors
                var s = dirEntry.start;
                for (var k = 0; k < 8; k++) dirEntry.sectors[s+k] = { sector: s+k, slen: this.sector_size, snext: 0, fbloc: k }; //sectors init
                if (idf < m) //(PVB CONSOLE HINT)
                        console.log(" one_dir() =>We have found the #" + idf + "'" + dirEntry.name + "' subdirectory!"); //(PVB CONSOLE HINT)
                return dirEntry;
            }
            else {
                if (tdos == 3 && !(d[j] & 0xC0)) {
                    dirEntry.valid = 1; //readable, but wrong ?
                    dirEntry.err += " >DOS3 dir entry not valid (no $0C flag)!"
                    if (idf < m) //(PVB CONSOLE HINT)
                        console.log(" one_dir() =>Error! File#" + idf + ": " + dirEntry.name + " (DOS3) is not existing (no 0xC0 flag)!"); //(PVB CONSOLE HINT)
                }
                if ((d[j] & 0x41) == 0x41) {
                     dirEntry.err += " >non-closed file (open-for-writing flag)!";
                    if (idf < m) //(PVB CONSOLE HINT)
                        console.log(" one_dir() =>Info: File#" + idf + ": " + dirEntry.name + " is a non-closed file that is open for writing, so may be wrong!"); //(PVB CONSOLE HINT)
                }
            }

            if (!dirEntry.valid) return dirEntry; //returns an empty dirEntry if non valid

            // get all sectors associated with this entry & check validity
            dirEntry.sectors = []; //initialisation of the DOS file sector table
            if (tdos != 3) { //for standard DOS (not DOS3) (nota for MyDOS, tdos is 6, 7 or 8)
                var sector = dirEntry.start; //current sector is the first one
                var num = -1; //initialisation of the file number index
                if (dirEntry.total) {
                    console.log(" one_dir() =>File#" + idf + ": DOS1/DOS2x/MyDOS " + dirEntry.name + " reading sectors...");
                    for (var k = 0; k < dirEntry.total; k++) { //up to the total number of block (sector)
                        var end = this.sector_offset(sector) + this.sector_size; //end of file pointer
                        var len = d[end - 1]; //len of data in the sector is set in the last byte of the sector

                        if (tdos == 7 || tdos == 8) { //MyDOS 16 bits next sector
                            var next = d[end-3] * 256 + d[end-2];
                            if ((!dirEntry.flag & 0x04) && k == 0) { //check only for first sector
                                //MyDOS 16bit sector chain flag not set in dir entry  ($04) but we continue as 16 bit chaining is used by default for MyDOS
                                console.log(" one_dir() =>Info! File#" + idf + ": MyDOS 16bits sector chain flag in " + dirEntry.name + " file directory entry not set!");
                            }    
                        }
                        else {
                            var next = ((d[end - 3] & 0x3) << 8) | d[end - 2];
                            if (num == -1)  //first issue...
                                num = d[end - 3] >> 2; //.. set the file number from the MSB byte of the first sector
                            if (num != idf || num != (d[end - 3] >> 2)) { //file number in the MSB index of the next sector is not right or has changed
                                //(PVB TODO) add information according to conditions
                                if (dirEntry.flags == 0x80 && k == 0) {
                                    dirEntry.valid = 1;
                                    if (dirEntry.dir_name) break; //exit Loop if the deleted file is in a MyDOS subdirectory, because this check does not work
                                    dirEntry.err += " >file overwritten by file #" + num +" >file unrecovarable!";
                                    console.log(" one_dir() =>Error! File#" + idf + ": DOS2x/MyDOS " + dirEntry.name + " has been overwritten by file #" + num + " in sector " + sector +"!");
                                    break; //exit loop
                                }
                                else {
                                    dirEntry.valid = 1;
                                    dirEntry.err += " >wrong file id in FMS byte at sect." + sector +" >" + k + " sect. read >file corrupted!";
                                    console.log(" one_dir() =>Error! File#" + idf + ": DOS2x/MyDOS " + dirEntry.name + " has wrong file number #" + num + " in sector " + sector +" after " + k + " sectors!");
                                    break; //exit loop
                                }
                            }
                        }
                        if (tdos != 1) { 
                            var is_good_len = (next == 0) ? (len <= (this.sector_size - 3) && len) : len == (this.sector_size - 3);
                            //is_good_len = true if (end sector && length of data to read is <= (sector size - 3) and not zero) or 
                            // (not end sector and length of data to read is = (sector size - 3))
                            if (!is_good_len) {
                                dirEntry.valid = 1;
                                dirEntry.err += " >wrong length in FMS byte at sect." + sector + " >file corrupted!";
                                console.log(" one_dir() =>Error! File#" + idf + ": DOS2x/MyDOS " + dirEntry.name + " has wrong byte_length (" + len + ") in sector " + sector +"!");
                                break; //exit loop
                            }
                        }
                        else { //else if (tdos == 1) //(PVB TO DO) count the file sector in len if z set
                            if (len & 0x80) { //check Z : if set, it is the last sector of DOS1 file
                                if (next) {
                                    dirEntry.valid = 1;
                                    dirEntry.err += " >DOS1 Z bit set in the FMS byte!";
                                    console.log(" one_dir() =>Error! File#" + idf + ": DOS1 " + dirEntry.name + " has Z bit set in last sector " + sector +"!");
                                    break; //exit loop
                                }
                            }
                            else { //if Z clear, we are not in the last sector of DOS1 file (PVB TO DO) : count the file sector in len...
                                len = this.sector_size - 3; //that is $7F
                                if (!next) {
                                    dirEntry.valid = 1;
                                    dirEntry.err += " >DOS1 Z bit cleared in FMS byte!";
                                    console.log(" one_dir() =>Error! File#" + idf + ": DOS1 " + dirEntry.name + " has Z clear and no next sector in sector " + sector +"!");
                                    break; //exit loop
                                }
                            }
                            len &= 0x7F; //any way clear the bit 8
                        }
                        if (next > this.sector_count) {
                            //next is above last sector of disk
                            dirEntry.valid = 1;
                            dirEntry.err += " >wrong next sector in FMS bytes at sect." + sector + " >file corrupted!";
                            console.log(" one_dir() =>Error ! File#" + idf + ": DOS2x/MyDOS " + dirEntry.name + " has wrong next_sector (" + next + ") in sector " + sector +"!");
                            break; //exit loop
                        }
                        /* //desactivated, accept this at this stage//
                        if (num != (d[end - 3] >> 2)) {
                            //file numbering the MSB index of the next sector has changed
                            dirEntry.valid = false;
                            console.log(" one_dir() =>File#" + idf + ": DOS2x/MyDOS " + dirEntry.name + " has wrong file_number in sector " + sector +"!");
                            break;
                        }*/
                        dirEntry.sectors[sector] = { sector: sector, slen: len, snext: next, fbloc: k }; //save the sector (offset = sector number)
                        
                        if (next == 0) { // check real end of file
                            if (k != dirEntry.total - 1) { // EndOfFile reached before the end of total sector get from the file VTOC directory
                                dirEntry.valid = 1;
                                dirEntry.err += " >no FMS next sector at sect." + sector + " & total to read not reached >file corrupted!";
                                console.log(" one_dir() =>Error! File#" + idf + ": DOS2x " + dirEntry.name + " is truncated: next sector after " + sector + " is zero!");
                            } 
                            break;  //exit loop // EOF?
                        }
                        sector = next;
                    }
                }
                else { // else if (!dirEntry.total) //if size is zero block or zero sector //(PVB CONSOLE HINT)
                    console.log(" one_dir() =>Info: File#" + idf + ": DOS2x/MyDOS " + dirEntry.name + " is zero byte length!");
                }
            }
            else if (tdos == 3) {
                //DOS3 gives the total number of block in dir.total as the file max size
                //file max size = (dirEntry.total * 8 * this.sector_size); //max size = 255KB for Dos 3 = 261120 bytes = $3FC00 bytes
                //fsize in the directory table is the lowest 16 bit (2 bytes) value of the actual file size, so "file max size" is the highest byte of actual file size
                dirEntry.fsize = ((dirEntry.total * 8 * this.sector_size) & 0xF0000) + dirEntry.fsize; //update fsize with fsize added with the file max size
                if (!dirEntry.fsize) {
                    console.log(" one_dir() =>File#" + idf + ": DOS3 " + dirEntry.name + " is not a valid file as zero byte length!");
                }
                else {
                    console.log(" one_dir() =>File#" + idf + ": DOS3 " + dirEntry.name + " reading sectors...");
                    var dos3Table = this.read_sector(24); //initialisation of the file layout table (sector 24)
                    var nextbloc = dos3Table[dirEntry.startbloc]; //number of current bloc, initialised to the start one
                    var sector = dirEntry.start; //current sector is the first one
                    for (var k = 0; k < dirEntry.total; k++) { //up to the total number of bloc
                        if (nextbloc >= 0xFD && (k != dirEntry.total -1)) {
                            dirEntry.valid = 1;
                            dirEntry.err += " >no next block in VTOC at sect." + sector + " & total to read not reached >file corrupted!";
                            console.log(" one_dir() =>File#" + idf + ": DOS3 " + dirEntry.name + "  has wrong next/end block " + nextbloc +"!");
                            break; //exit loop
                        }
                        if (sector > this.sector_count) {
                            //next is above total sector of disk
                            dirEntry.valid = 1;
                            dirEntry.err += " >wrong next block in FMS bytes at sect." + sector + " >file corrupted!";
                            console.log(" one_dir() =>File#" + idf + ": DOS3 " + dirEntry.name + "  has wrong block/target sector " + sector +"!");
                            break; //exit loop
                        }
                        for (var s = 0; s < 8; s++) { //do the 8 sectors of the DOS3 bloc
                            dirEntry.sectors[sector + s] = { sector: sector + s, slen: this.sector_size, snext: -1, fbloc: k }; //save the sector (offset is sector number)
                        }
                        //compute next sector and read next bloc
                        sector = nextbloc * 8 + 25;
                        nextbloc = dos3Table[nextbloc];
                    }
                }
            }
            if (dirEntry.valid != 2)
                dirEntry.sectors = []; //if file entry not valid, no sector is save in the dirEntry
            else
                console.log(" one_dir() =>OK: File#" + idf + ": " + (tdos == 3 ? "DOS3 " : "DOS2x ") + dirEntry.name + " file is valid !!");
            
            return dirEntry;
        }

        // Search the entire disk for sneaky directory entries
        get_dir_range(from, to, subdirname) // get_dir_range() is called by get_dir()
        // (PVB COM) Search in the directory table that is (from, to) sectors ('to' is not included !);
        //(PVB ADD) the "subdirname" parameter in case of a MyDOS subdirectory
        {
            var dirs = [];
            var idf = 0;
            for (var i = from; i < to; i++) {   // (PVB COM) "i" stands for the sector range of the dir table (like the 8 sectors 361-368)
                for (var n = 0; n < 8; n++) {   // (PVB COM) "n" stands for the 8 lines of file entry in each sector of the dir table
                    var dir = this.one_dir(n, i, idf++, subdirname); // (PVB COM) "dir" gets the content of one file entry
                    if (dir.valid) {
                        if (!this.dir_sector)
                            this.dir_sector = i;
                        dirs.push(dir);
                    }
                    if (dir.is_dir) { //(PVB ADD) if this is a MyDOS directory, then recurse
                        dirs = dirs.concat(this.get_dir_range(dir.start, dir.start + 7, dir.name));
                    }
                }
            }
            return dirs;
        }

        //(PVB MOD) DOS3 added for get_dir()
        //(PVB TODO) add other DOS get_dir support
        get_dir() {
            if (this.sparta) {
                console.log("get_dir() => Retreiving the Sparta disk directory...");
                return this.sparta.get_dir();
            }
            var dirs = [];
            if (this.dosType == 3) {
                //try DOS3 disk
                console.log("get_dir() => Retreiving the DOS3 disk directory at 16-23...");
                dirs = this.get_dir_range(16, 24);
                if (dirs.length < 1 ) {
                    //(PVB TODO) find other dirs or try the whole disk ??
                    console.log("get_dir() => No DOS3 directory entry in 16-23! Aborting process !");
                }
            }
            else if (this.dosType > 0 || this.dosType == -1) { //(PVB COM) not for DOS3
                console.log("get_dir() => Retreiving DOS1, DOS2x or MyDOS disk directory at 361-368...");
                dirs = this.get_dir_range(361, 369); //369 not included
                if (dirs.length < 1 && this.dosType < 8) { //(PVB MOD) Not for MyDOS4.5x HD disk
                    console.log("get_dir() => No DOS2x directory found at 361-368.... let's try into the whole disk...");
                    dirs = this.get_dir_range(4, this.sector_count);  // try the whole disk
                }
                if (this.dir_sector == 0) { // if nothing found...
                    console.log("get_dir() => No DOS2x directory entry found on whole disk");
                    this.dir_sector = 361;  // didn't find one, so use default (that is sector 361)
                }
            }
            if (this.dosType != 3 && this.dosType < 7) { //for DOS2x (and not MyDOS 16 bits sector chain) or if no DOS found
                console.log("get_dir() => Try and find files that don't have a real directory entry like the erased ones...");
                //(PVB TODO) Scan files() only if not a DOS2x disk ?
                this.scan_files(dirs);      // try and find files that don't have a real directory entry
            }
            return dirs; //(PVB COM) complete directory table is returned, 'dirs' is empty if no file found
        }

        //(PVB MOD & ADD) Rewrite the scan_files(dirs) function to retrieve and recover lost or hidden files (min 2 sectors !) 
        scan_files(dirs) { //scan_files() is called by get_dir(), only for DOS2x and MyDOS system
            var d = this.d;
            var sSectors = [];
            //(PVB TODO) check the previous utility of "used" ?
            /*var used = [];
            dirs.forEach(dir => dir.sectors.forEach(s => used[s] = dir)); //last directory entry
            dirs.forEach(dir => used[dir.start] = dir); //record each dir entry in an array with its start sector as index */
            var files = [];
            for (var i = 4; i <= this.sector_count ; i++) { //map the sector of the disk
                var end = this.sector_offset(i) + this.sector_size;
                var len = d[end - 1];
                var next = ((d[end - 3] & 0x03) << 8) | (d[end - 2]);   // TODO: 10 bits
                if (len == (this.sector_size - 3) || ((len <= (this.sector_size - 3)) && next == 0))
                    sSectors[i] = { sect: i, len: len, next: next, num: d[end - 3] >> 2 };
                else //means file broken by wrong sector, like an empty BAD sector, filed with zero or inconsistant data
                    sSectors[i] = { sect: i, len: 0, next: 0, num: -1 };
            }
            sSectors.forEach(s => { //add previous sector
                var n = sSectors[s.next];
                if (n) {
                    if (n.num == s.num)
                        n.prev = s.sect;
                    else s.next = 0;
                }                    
            });
            sSectors.forEach(s => {
                if (!s.prev && s.len) { //this is the pilot sector, as the first sector of a file and no prev sector
                    s.total = 0;
                    s.bytes = 0;
                    s.used = 0;
                    s.error = 0;
                    s.fsectors = [];
                    var n = s; //first sector is copied into n, s is kept into the loop
                    do {
                        s.fsectors[n.sect] = {sector: n.sect, slen: n.len, snext: n.next, fbloc: s.total };
                        s.bytes += n.len; //s.bytes = number of bytes in the file
                        s.total++; //s.total = number of sector
                        if (n.next == 0) //end of file, exit loop
                            break;
                        var ns = sSectors[n.next]; //get next sector
                        if (n != s) { //exclude first sector
                            //if next sector is empty, or sector link damaged, or wrong id : need to close current file and set a new one
                            if (!ns || (ns.prev != n.sect) || (s.num != n.num)) { 
                                s.error++; //the retrieved file has an error
                                s.fsectors[n.sect].snext = 0; //so cancel the next sector
                                sSectors[n.sect].next = 0;
                                if (ns && (s.num != n.num)) //reajust "previous" to zero in the next sector only for 'num' mismatching
                                    sSectors[ns.sect].prev = 0;
                                break;
                            }
                        }
                        n = ns; //iterative n is set to next sector
                    } while (n);
                    if (s.total > 1) //at least 2 chained sectors to identify a file !
                        files.push(s); //push the 'fsectors' file sector list in the "pilot" first sector in the file (the one without prev)
                }
            });
            var _correlated;
            function match(sect, num, error, bytes) {
                _correlated = 0;
                for (var i = 0; i < dirs.length; i++) { //(PVB COM) list of recognized filenames in the TOC Dir entry
                    if (dirs[i].start == sect && dirs[i].numidf == num) {
                        _correlated++; //the file is in the TOC Dir entry
                        if (!error && dirs[i].valid == 2) { //the file is valid
                            dirs[i].correlated = true; // valid file correlated !
                            dirs[i].fsize = bytes;
                            console.log("scan_files() =>Info: file #" + num + " '" + dirs[i].name + "' correlated, start at " + sect + ", length is " + bytes + " bytes, " + dirs[i].total + " sectors" );
                            return true; //no need to recover, we match a valid file !
                        }
                        break; //exit loop
                    }
                }
                return false; //to be recovered
            }
            // now we have chains of files, recover those missing dir entries
            var i = 0;
            files.forEach(f => {
                if (!match(f.sect, f.num, f.error, f.bytes)) { //not valid file ?
                    var name = "FILE_" + hex(i) + ".DAT";
                    var name83 = "FILE_" + hex(i++) + " DAT";
                    var ext3 = "DAT";
                    // Reconstruct stomped dirs
                    if (dirs && dirs.length && _correlated) { //file is in TOC Dir entry
                        var nom = dirs[f.num];
                        if (nom && nom.flags & 0x02) { //it's a valid flag (42 or 03 for DOS 2x) file but corrupted
                            name83 = nom.name83; //use the TOC Dir enry name instead of the DAT name
                            name = nom.name;
                            ext3 = nom.ext;
                            i--; //cancel the .DAT name number
                        }
                    }
                    var tdir = { numidf: "=>", sectors: f.fsectors, valid: 2, start: f.sect, total: f.total, fsize: f.bytes, name: name, name83: name83, ext: ext3, flags: 0x00, recovered: true, fnum: f.num };
                    dirs.push(tdir);
                    console.log("scan_files() =>Info: file '" + name + "'' recovered, file id #" + f.num + ", start at " + f.sect + ", length is " + f.bytes + " bytes, " + f.total + " sectors" );
                }
            });
        }

        read_file(f) { //read_file() is called in load_data() and returns an array of byte data of the read file
            //(PVB MOD) simplification of read_file(), it is not the place to check sector chaining, we assume reading only a valid file
            if (this.sparta)
                return this.sparta.read_file(f.start);
            var data = [];
            //var count = f.total; //for DOS2X, count is the total sector number of the file
            //var sector = f.start; //initialize to the first sector
            var d = this.d;
            //previously // f.errors = 0; // see sector chaining in one_dir()
            //(PVB ADD) read the DOS 3 files; fsize is already compute in one_dir()
            if (this.dosType == 3) {
                f.sectors.forEach(s => {
                    var src = this.read_sector(s.sector)
                    for (var i = 0; i < src.length; i++)
                        data.push(src[i]);
                });
                data.splice(f.fsize); //clipped the size of the file to the f.fsize
                //if (f.fsize != data.length) console.log("read_file(): error of DOS 3 file size");
            }
            //(PVB END OF ADD)
            else {
                f.sectors.forEach(s => {
                    var src = this.read_sector(s.sector)
                    for (var i = 0; i < s.slen; i++)
                        data.push(src[i]);
                });
                //f.size already set with DOS2x thanks to scan_files() function, but not for DOS 1...
                f.fsize = data.length; //(PVB ADD) so anyway, force fsize to the read data length
            }
            return new Uint8Array(data);
        }
        //(PVB ADD) the identify_dos() function
        //(PVB TODO) optimize code to avoid repeating the same code & add other DOS support
        identify_dos() {//identify_dos() is called by the constructor in order to set atr.dosType
            //let's assume that return value is (-1) if no DOS found; (0) for Sparta; (1) for DOS1; (2) for DOS2.0; (2.5) for DOS2.5; (3) for DOS3; 
            //(4) for DOS4 (TODO - DOS4, not handled); (6) for MyDOS compatible with DOS2x; (7) for MyDOS with flag 03 (not compatible with DOS2x);
            //(8) for MyDOS4.5x with more than 1440 sector; // TODO - DOS XE not handled - TODO in the SPARTA way with specific Class ?
            if (this.sparta)
                return 0;
            //default
            var idos = -1;
            this.totalBloc = 0;
            this.freeBloc = 0;
            this.vtoc2_sect = 0;
            this.vtoc1_sect = 360;
            this.dir_sector = 361;
            this.file_start = 4;
     
            var vtocSect = this.read_sector(360); //read TOC at sector 360
            var t = le16(vtocSect, 1); //read total bloc
            var s = le16(vtocSect, 3); //read remainning free bloc
            var sc = this.sector_count;
            var str = "";

            function checkZeroIn(vtoc, s, e){ //checkZeroIn() called to check that part of TOC contains $00 (e is not included)
                var x = 0;
                for (var i = s; i < e; i++) {
                    x += vtoc[i];
                }
                return x; //return t = zero if zero
            }
            //check MyDOS...
            //VTOC must start with $02, $03 or higher byte, contain $00 at offset $37, and has a total-of-sector value
            var vc = checkZeroIn(vtocSect, 6, 10);
            var bc = (this.d[16] + this.d[17] + this.d[18] + this.d[19]) == 10;
            if (t == 0x2C4 && vtocSect[0] == 2 && vtocSect[0x37] == 0 && !vc) { //VTOC flag must be 02 for MyDOS compatible with DOS2x
                if (sc == 1040) str += " >720-sector MyDOS disk on a 1040-sector disk";
                idos = 6; //MyDOS 720 sectors / 128B or 256B > "Single" or "Double"
            }
            else if (t == 0x403 && vtocSect[0] >= 3 && vtocSect[0x37] == 0 && !vc) { //VTOC flag >= 03 is for 1040 sector or above, single density
                if (vtocSect[0] == 3 && sc == 720) str += " >1040-sector MyDOS disk clipped into a 720-sector disk";
                this.vtoc2_sect = 359; //at the minimum
                idos = 7; //MyDOS >= 1040 sectors // 128B > "Enhanced" and more
            }
            else if (t == 0x594 && vtocSect[0] >= 3 && vtocSect[0x37] == 0 && !vc) {
                if (sc <= 1040 && vtocSect[0] == 3) str += " >1440-sector MyDOS disk clipped into a smaller sector disk";
                if (vtocSect[0] > 3) this.vtoc2_sect = 359;
                idos = 7; //MyDOS >= 1440 sectors // 256B > Double Side / Double Density
            }
            else if (t > 0x594 && s <= t && vtocSect[0] > 3 && vtocSect[0x37] == 0 && !vc) {
            //else if (t > 0x594 && s <= t && t <= sc && vtocSect[0] > 3 && vtocSect[0x37] == 0 && vtocSect[0x38] == 0x7F) {
                if (sc <= t) str += " >MyDOS4.5x disk clipped into a smaller sector disk";
                this.vtoc2_sect = this.sector_size == 256 ? (361 - vtocSect[0] + 2) : (361 - (vtocSect[0] - 2) * 2); //compute the 1st VTOC sector, it works for 256 byte sector
                idos = 8; //MyDOS4.5x > 1440 sectors // 128 or 256B
            }
            if (idos >= 6) { //MyDOS exit
                if (this.d[16] != 0x4D) str += " >'M' byte signature is missing in the MyDOS boot sector"; //info
                this.totalBloc = t;
                this.freeBloc = s;
                if (str) this.dirErrorStr = str;
                return idos;
            }
            //check DOS 2x... //(PVB TODO) improve DOS detection and support loaders other than DOS (with special boot)
            //May be load the first one_dir to valid the DOS 2x DOS disk
            //VTOC must start with $01 or $02 byte, contain $00 at offset $37 (?), and has a total-of-sector value
            if ((vtocSect[0] == 0x01) && t == 0x2C5 && vtocSect[0x37] == 0) { //TODO check if we let vtocSect ?
                if (sc > 720) str += " >720-sector DOS1 disk on a 1040-sector disk";
                this.file_start = 2;
                idos = 1; //DOS 1
            }
            else if ((vtocSect[0] == 0x02) && t == 0x2C3 && (bc || !vtocSect[0x37]) && !vc) { //TODO check?
                if (sc == 1040) str += " >720-sector DOS2x disk on a 1040-sector disk";
                idos = 2; //DOS2.0S or DOS2.0D
            }
            else if (vtocSect[0] == 0x02 && (t == 0x3F2 || t == 0x3F3 || t == 0x3E9) && vtocSect[0x37] == 0 && !vc) { //TODO check 3F3 & 3E9 loaders ?
                if (sc == 720) {
                    str = " >1040-sector DOS2.5 disk clipped into a 720-sector disk";
                    str += " >VTOC2 is missing, free blocks value is wrong";
                }
                else if (sc = 1040) {
                    if (is_zero(this.d, this.sector_offset(1024), this.sector_size))
                        str += " >1040-sector disk VTOC2 erased, end of disk may be corrupted";
                    s = s + le16(this.d, (this.sector_offset(1024) + 0x7A));
                }
                this.vtoc2_sect = 1024;
                idos = 2.5; //DOS 2.5 for enhanced
            }
            if (idos > 0) {
                this.totalBloc = t;
                this.freeBloc = s;
                if (checkZeroIn(vtocSect, 101, 128)) str += " >Error in DOS TOC that must end with $00 value bytes"; //info
                if (str) this.dirErrorStr = str;
                return idos;
            }
            //check DOS 3...
            //Directory must start with 14x $00 value bytes, contain $A5 signature, and has the total-of-block byte
            this.vtoc1_sect = 24;
            this.vtoc2_sect = 0;
            this.dir_sector = 16;
            var vdir = this.read_sector(16);
            t = vdir[0x0E];
            if (!checkZeroIn(vdir, 0, 14) && (vdir[0x0F] == 0xA5) && (t == 0x57 || t == 0x7F)) {
                if (t == 0x57 && sc == 1040)
                    str += " >720-sector DOS3 disk on a 1040-sector disk";
                if (t == 0x7F && sc == 720)
                    str += " >1040-sector DOS3 disk clipped into a 720-sector disk";
                this.totalBloc = t;
                vtocSect = this.read_sector(24);
                this.freeBloc = vtocSect.filter(arrayElement => arrayElement == 0xFE).length;
                if (str) this.dirErrorStr = str;
                this.file_start = 25;
                idos = 3;
                return idos; //DOS 3
            }
            //(PVB TODO) handle DOS XE and others
            this.dirErrorStr = " >VTOC error: unknown DOS system or disk image file has a boot loader!";
            this.vtoc1_sect = 0;
            this.dir_sector = 0;
            return idos; //no DOS found
        }
        //(PVB END OF ADD)
    }

    //===================================================================================================
    // arc files

    function dearc_3(srcd, srclen, dstlen)    // RLE - after altirra
    {
        var dst = 0;
        var src = 0;
        var dstd = new Uint8Array(dstlen);

        let last = 0;
        while (dstlen) {
            let c = srcd[src++];
            if (c == 0x90) {
                if (!srclen--)
                    return null;
                let d = srcd[src++];
                if (d == 0) {
                    prevoutput = last;
                    if (!dstlen--)
                        return null;
                    dstd[dst++] = 0x90;
                } else {
                    let count = d - 1;
                    if (dstlen < count)
                        return null;
                    dstlen -= count;
                    while (count--)
                        dstd[dst++] = last;
                }
            } else {
                last = c;
                if (!dstlen--)
                    return null;
                dstd[dst++] = c;
            }
        }
        return dstd;
    }

    function dearc_8(srcd, srclen, dstlen)    // after altirra
    {
        var dst = 0;
        var src = 0;
        var n = 256;
        var last = 0;
        var byte2 = false;
        var bits = 9;
        var accum = 0;
        var accumbits = 0;
        var lastCode = 0;
        var codesRead = 0;
        var dstd = new Uint8Array(dstlen);

        var prev_link = new Int16Array(4096);
        var first_char = new Uint8Array(4096);
        var last_char = new Uint8Array(4096);
        var tmp = new Uint8Array(4096);
        for (var i = 0; i < 256; i++) {
            prev_link[i] = -1;
            first_char[i] = last_char[i] = i;
        }

        if (srcd[src++] != 0xC) // longest code length?
            return null;

        while (dstlen) {
            let code = 0;
            for (let i = 0; i < bits; ++i) {
                if (!accumbits) {
                    if (!srclen--)
                        return null;
                    accum = srcd[src++];
                    accumbits = 8;
                }

                if (accum & 1)
                    code += (1 << bits);

                accum >>= 1;
                --accumbits;
                code >>= 1;
            }

            ++codesRead;
            if (code > n)
                return null;

            if (code == 256) {
                let align = ((-codesRead & 7) * bits) >> 3;
                if (srclen < align)
                    return null;
                srclen -= align;
                src += align;

                // reset code table
                n = 256;
                bits = 9;
                lastCode = 0;
                accumbits = 0;
                accum = 0;
                codesRead = 0;
                continue;
            }

            if (n < 4096) {
                first_char[n] = first_char[lastCode];
                if (code == n)
                    last_char[n] = first_char[n];
                else
                    last_char[n] = first_char[code];
                prev_link[n] = lastCode;

                ++n;
                if (n >= (1 << bits) && bits < 12)
                    ++bits;
            }

            var tmpstart = 4096;
            for (var link = code; link >= 0; link = prev_link[link])
                tmp[--tmpstart] = last_char[link];

            while (tmpstart != 4096) {
                let c = tmp[tmpstart++]
                if (byte2) {
                    if (c == 0) {
                        last = 0x90;
                        if (!dstlen--)
                            return null;
                        dstd[dst++] = 0x90;
                    } else {
                        let count = c - 1;
                        if (dstlen < count)
                            return null;
                        dstlen -= count;
                        while (count--)
                            dstd[dst++] = last;
                    }
                    byte2 = false;
                } else {
                    if (c == 0x90)
                        byte2 = true;
                    else {
                        last = c;
                        if (!dstlen--)
                            return false;
                        dstd[dst++] = c;
                    }
                }
            }
            lastCode = code;
        }
        return dstd;
    }

    function arc_extract(id, pos) {
        var file = get_file(id);
        function extract(pos) {
            var f = file.arc[pos];
            var d = file.data.slice(pos, pos + f.compressed_size);
            switch (f.method) {
                case 3: d = dearc_3(d, f.compressed_size, f.original_size); break;
                case 8: d = dearc_8(d, f.compressed_size, f.original_size); break;
            }
            load_one(f.name, get_ext(f.name, d, false, false), d, "", "isFile"); //(PVB MOD) add arguments to load_one()
        }
        if (pos == -1)
            file.arc.forEach(a => extract(a.pos));
        else
            extract(pos);
        refresh_containers();
    }

    function show_arc(f) {
        var d = f.data;
        var files = [];
        var txt = [];
        var sel = [];
        var i;

        var _methods = [
            "End of archive marker",
            "unpacked (obsolete) - ARC 1.0 ?",
            "unpacked - ARC 3.1",
            "packed (RLE encoding)",
            "squeezed (after packing)",
            "crunched (obsolete) - ARC 4.0",
            "crunched (after packing) (obsolete) - ARC 4.1",
            "crunched (after packing, using faster hash algorithm) - ARC 4.6",
            "crunched (after packing, using dynamic LZW variations) - ARC 5.0",
            "Squashed c/o Phil Katz (no packing) (var. on crunching)"];

        var i = 0;
        f.arc = [];
        var count = 0;
        while (i < d.length) {
            if (d[i + 0] != 0x1A)
                break;
            var method = d[i + 1];
            if (!method)
                break;  // end of archive is 0x1A 0x00

            var name = '';
            for (var j = 0; d[i + 2 + j] && j < 12; j++)
                name += String.fromCharCode(d[i + 2 + j]);

            var file = {
                method: method,
                name: name,
                compressed_size: le32(d, i + 15),
                date: le32(d, i + 19),
                crc: le16(d, i + 23),
                original_size: le32(d, i + 25),
                pos: i + 29
            }
            f.arc[file.pos] = file;
            //(PVB MOD) add the display of html hyperlinks
            sel.push(`; <a href=#${file.name}>${file.name}</a><button style="float:right" type="button" onclick='arc_extract(${f.id},${file.pos})'>Extract</button>`);
            sel.push(`; ${file.original_size} bytes (${file.compressed_size} compressed)`);
            sel.push("");

            txt.push('; --------------------------------------------------------------------------------'); //(PVB MOD) add a separation line)
            txt.push('; <span id="'+ file.name + '">' + file.name + " raw data: </span>");
            txt.push('; ' + _methods[method] + ', ' + file.compressed_size + ' -> ' + file.original_size);
            txt.push('; <a href="#backtoarc">(back)</a>');
            txt.push(''); 
            txt.push(hex_dump(d, i + 29, file.compressed_size, 4));
            txt.push('');

            i += 29 + file.compressed_size;
            count++;
        }
        sel.unshift(`; <span id="backtoarc">${f.name} archive contains ${count} files: </span><button type="button" style="float:right" onclick='arc_extract(${f.id},-1)'>Extract All</button>\n\n`);
        sel.push("");

        render_file(f);
        _h("#show", sel.join("\n") + txt.join("\n"));
    }
    
    //===================================================================================================
    //(PVB ADD) ROM Image management and ROM dump display
    function show_rom(f) {
        var r = f.rom;
        var d = r.romData; //ROM with the CART header
        var bankMap = r.romMap;
        var sc = d.length - 16;
        var nb = []; //temp Array
        var txt = []; //string of text to display
        var romBank = []; //restructured banks of the rom
        var aname = []; //bytes in the A5200 ROM for the name and date, that will be transformed into string
        var str = ""; //tmp
        var i = 16;  //memory pointer
        var n = 0  //number of banks with same characteristic that are switched
        var k = 0; //number of bank * 2
        var l = 0; //bank counter
        //initialization of a5200eq and _bShowA5200 Equates is now in load() and apply_rommap(), that are called just before show_rom())
        r.rom_flag = 0xFF; //set default
        r.rom_init = 0; //set default
        while (n < bankMap.length) { //for every map
            var m = bankMap[n+2]; // number of bank
            for (var j = 0; j < m; j++) { //for each identical bank
                nb[k] = bankMap[n] * 0x100; //len of memory
                nb[k+1] = bankMap[n+1] * 0x100; //start address
                nb[k+2] = nb[k+1] + nb[k] - 1; //end address
                romBank.push({start: nb[k+1], end: nb[k+2], len: nb[k], offset: i}); 
                if (((r.romType == "21" || r.romType == "59" || r.romType == "53") && (nb[k+2] == 0x9FFF)) //Right Slot Cartridge or Low bank 8 KB Cartridge
                        || (nb[k+2] == 0xBFFF)) { //Normal Slot Cartridge
                    r.rom_flag = d[r.romData.length - 3]; //CARTFG => Cartridge ROM, normaly $04; For A5200: char date or $FF (see below)
                    r.rom_init = le16(d, r.romData.length - 2);  //CARTAD => initialization of start vector, same for A5200
                    if (r.romMachine == "5200") { //check if it is an A5200 Cartridge
                        //for the A5200 CART: $BFE8-$BFFB are the 20 char of title name; $BFFC-$BFFD for the (c) date
                        //see https://www.atarimax.com/freenet/freenet_material/5.8-BitComputersSupportArea/7.TechnicalResourceCenter/showarticle.php?51
                        aname = d.slice(r.romData.length - 24, r.romData.length - 2);
                        r.rom_coldstart = 0; // no CARTCS for A5200 cartridges
                    }
                    else {
                        r.rom_coldstart = le16(d, r.romData.length - 6); //CARTCS => cold start for 800/XL/XE Cartridges
                    }
                }
                if (nb[k+2] == 0xFFFF) r.rom_init = 0xFC00; // for the 2K A5200 ROM
                l++; //increment bank coiunter
                i += nb[k]; //adjust the memory pointer
                k += 3; //number of bank * 2 
            }
            n+=3;
        }
        r.romBankMap  = romBank;
        //r.romBankList = nb; //(PVB TODO) check if this is relevant to save the romBankList nb into the ROM array r
 
        if (!bankMap || bankMap.length == 0)
            txt.push(`; <b>ROM Image is ${r.romKBSize}KB ($${hdx(sc)} bytes) in total - No memory Mapping available - Please test above</b>`);
        else {
            txt.push(`; <b>ROM Image is ${r.romKBSize}KB ($${hdx(sc)} bytes) in total in ${l} banks of memory</b>`);
            if (r.romMachine == "5200") {
                str = "Atari 5200 ROM ";
                txt.push(`; ${str}<b>Initialisation Start Vector is $${hex(r.rom_init,4)}</b>`);
                //(PVB COM) Extracting A5200 rom name and date...
                let j = aname.length;
                while (j--) { //convert the char display
                    if (aname[j] > 0x7F) //(PVB TODO / experiment => check how the char above $7F are displayed)
                        aname[j] = 0;
                    if (aname[j] < 0x3F)
                        aname[j] += 0x20;
                    else 
                        aname[j] -= 0x20;
                }
                if (r.rom_flag != 0xFF) {
                    aname = toAscii(aname, 0, aname.length); //(PVB) for A5200 rom displayed name and date
                    txt.push(`; ${str}displayed name at OS boot is "` + aname.substring(0, 20) + ` (c) ATARI 19` + aname.substring(20, 22) + `"`);
                }
                else
                    txt.push(`; ${str}has no displayed name at OS boot, CARTFG = 0xFF`);
            }
            else {
                str = "Atari 800/XL/XE ROM ";
                txt.push(`; ${str}<b>Initialisation Vector CARTAD is $${hex(r.rom_init,4)}</b>`);
                txt.push(`; ${str}<b>Cold Start Vector CARTCS is $${hex(r.rom_coldstart,4)}</b>`);
                txt.push(`; ${str}<b>Cartridge Flag CARTFG is $${hex(r.rom_flag,2)}</b>`);
            }
        }
        l = 0;
        txt.push('\n; <b>ROM Bank Map:</b>');
        for (var j = 0; j < nb.length; j+=3) {
            txt.push(`; <a id="BKTOBANK${l}" href="#FWTOBANK${l}">Bank nbr ${l}</a>; size ${(nb[j]/1024)}KB; at memory $${hex(nb[j+1],4)}:${hex(nb[j+2],4)}`);
            l++;
        };
        l = 0;
        r.romBankMap.forEach(b => {
            txt.push(`\n` + _hr);
            str = `<span id="FWTOBANK`+ l + `"><strong>; HEX DUMP of Bank nbr ` + l + `; size: ` + b.len + ` ($` + hdx(b.len) + `) bytes = ` + (b.len/1024) + `KB`;
            str += `</strong> <a href="#BKTOBANK` + l + `">(back)</a></span><em class="bankcode" onclick="show_bank(` + l + `)">Toggle Disassembly/HexDump View</em>`;
            txt.push(str);
            txt.push(`; Bank set to memory $` + hex(b.start,4) + ` : $` + hex(b.end,4));
            str = `;`;
            if (l > 0)
                str += ` <a href="#FWTOBANK` + (l-1) + `">(previous)</a> `;
            if (l < r.romBankMap.length - 1 )
                str += ` <a href="#FWTOBANK` + (l+1) + `">(next)</a> `;
            txt.push(str + "\n" + _hr);
            txt.push(`<div id="BANK_${l}" style="display:block">` + `\n` + hex_dump(d, b.offset, b.len, (b.start + l)) + `</div>`);
            l++;
            });

        render_file(f);
        _h("#show", txt.join("\n"));
    }
    //(PVB END OF ADD)

    //===================================================================================================
    // dump atr raw data

    //(PVB MOD) improvement of the show_atr() function
    //handle DOS3, add ATR disk characteristics, mod display of boot sector, add DOS directory, mod display of sectors & blocks...
    function show_atr(f, rawmode) {
        //(PVB COM) show the ATR is_disk : 'ATR', ATX, PRO & XFD
        //rawmode is true with DSK file where the sectors are just listed
        var atr = f.atr;
        var d = atr.d; //d includes the 16 bytes of the ATR header !!
        var txt = [];
        var sparta = atr.sparta; //(PVB MOD) declaration here

        // just the raw sectors
        //(PVB COM) if rawmode => atr.sector_size is used for the size if sector, d is the data memory buffer to display,
        // the dump text is put in the txt variable, and display on the right after render_file (top) et #show (bottom with txt)
        if (rawmode) {
            var n = 0;
            for (; ;) {
                var size = n < 3 ? 128 : atr.sector_size;
                var offset = atr.sector_offset(n + 1);
                if (offset >= (atr.size + 16))
                    break;
                var zero = is_zero(d, offset, size);
                // (PVB MOD) add the hexa number sector, and count sectors from 1 and not zero (there is no sector zero for the atari SIO)
                var sect = n + 1;
                txt.push("; Sector " + hex(sect, 3) + " (" + sect + ")" + (zero ? " (" + size + " zeros)" : ""));
                //(previously) txt.push("; Sector " + n + (zero ? " (" + size + " zeros)":""));
                if (!zero) // (PVB COM) if the sector is not empty then we display the dump
                    txt.push(hex_dump(d, offset, size, 4));
                txt.push("");
                n++;
            }
            render_file(f);
            _h("#show", txt.join("\n"));
            return;
        }
        function pad_hex(h) { // pad_hex(n) is used to pad the value of the boot_record entries
            //(PVB COM) remplace the hex(n) with hex(n,4) if n is greater than 0xFF
            return h > 0xFF ? hex(h, 4) : '  ' + hex(h);
        }
        //(PVB ADD) pad_dec() function
        function pad_dec(x, n) { // pad_dec(n) is used to pad the value general
            x = "" + x; //convert x number into a string 
            return x.padStart(n, ' ');
        }
        //(PVB ADD) pad_dir(s, n) function
        function pad_dir(s, n){ //function pad_dir(s, n) is used to pad the display of the Directory (add space char after string)
            while (s.length < n)
                s = s + ' ';
            return s;
        }
        //(PVB ADD) pad_dtime(x) function
        function pad_dtime(x, t) {
            var c = t ? ":" : "/";
            var s = String(x & 0xFF).padStart(2,"0") + c + String((x >> 8) & 0xFF).padStart(2,"0") + c + String((x >> 16) & 0xFF).padStart(2,"0");
            return s;
        }
        //(PVB COM) no rawmode => display the atari disk : boot flags & disassembly, directory, VTOC, sectors dump, etc...
        // source https://www.atariarchives.org/mapping/appendix17.php : DOS 2.5 loads its boot sector at address $700
        var _br = {  //$700 = standard DOS BOOT address
            BFLG: d[16],         //700: Boot flag; always equals 0.
            BRCNT: d[17],        //701: Number of sectors in the disk boot, -usually $03
            BLDADDR: le16(d, 18),//702: Boot load address; where DOS is loaded into memory; -usually $700 for DOS disk
            BINTAD: le16(d, 20), //704: DOS initialization address; -usually $1540
            BCONT: le16(d, 23),  //707: $4C jmp address for DOS2x, that is "$706  4C 14 07 ; JMP $0714"
            // (PVB COM) end of normal boot sector. Next is the DOS2x continuing structure:
            SABYTE: d[25],       //709: Maximum number of concurrently open files -usually $03
            DRVBYT: d[26],       //70A: Drive allocation byte; one bit per drive -usually $03
            SAFBFW: d[27],       //70B: -usually $00
            SASA: le16(d, 28),   //70C: Buffer allocation address for drives and files -usually $1A7C
            DFSFLG: d[30],       //70E: Reads zero if there is no DOS.SYS on disk, nonzero if present -usually $01
            DFLINK: le16(d, 31), //70F: Points to first sector of the DOS.SYS file (LSB first) -usually sector $04
            BLDISP: d[33],       //711: Number of displacement bytes to sector link bytes (last sector three bytes) = $7D (125)
            DFLADDR: le16(d, 34),//712: Address of the FMS (D:) handler table; -usually $7CB for DOS2x
            // $714 XBCONT  boot program continues at usually $714 as indicated in BCONT
        };
        if (d[22] != 0x4C) //(PVB ADD) if no jump $4C then br.CONT does not exist
            _br.BCONT = 0;

        /*(PVB MOD) cancel the available() function ///WIP// What is the available() function purpose ?
        function available(n) {
            return d[vtoc + 10 + (n >> 3)] & (0x80 >> (n & 3));
        }*/
        //(PVB COM) Checking the validity of TOC => code is now /has been move in identity_dos() function in ATR class
        //(PVB ADD) check and identify the sector size of disk
        var density = "";
        //var formatStrError = ""; //(PVB ADD) ///WIP// use of formatStrError to report error
        var ts = atr.sector_count; //(PVB ADD)
        if (ts <= 720) {
            // 720 sectors => Density 128 B/sect, ATARI 810 drive => for DOS1 & DOS2.0S, compatible all DOS;
            //             => Density 256 B/sect, ATARI 815 drive => for DOS2.0D, compatible with OSS DOS XL, DOS XE, MyDOS, Sparta
            density = atr.sector_size == 128 ? "Single Density" : "Double Density";
        }
        else if (ts > 720 && ts <= 1040) {
            // 1040 sectors => Density 128 B/sect, ATARI 1050 drive => for DOS3 and DOS2.5, compatible all DOS except DOS1 & DOS2.0S
            density = "1050 Enhanced Density (Medium Density)";
        }
        else if (ts > 1040 && ts <= 1440) {
            // 2*720 = 1440 sectors => Density 256 B/sect, ATARI XF551 drive => for DOSXE, compatible with MyDOS (?), Sparta
            density = "Double Sided / Double Density";
            //(PVB TODO) Support DOS XE...
            //if (!atr.dosType != 6) //(PVB TODO) 6 was for MyDOS => update if condition is for DOS XE
            //    formatStrError += "; Disk is a 1440 sectors DOS disk that can also be a DOS XE disk - not supported yet";
        }
        else if (ts > 1440 && atr.dosType == 8) { //(PVB MOD) MyDOS4.5x
            density = "MyDOS4.5x HD disk format";
        }
        else if (sparta) { //or atr.dosType == 0 for sparta
            density = "SpartaDOS disk format";
        }
        else { //(PVB MOD) unknow format
            density = "Unknown format disk with " + ts + " Sectors of " + atr.sector_size + " bytes";
            console.log("show_atr() file " + atr.name + " has a wrong unknown sector_count: " + ts);
        }
        
        txt.push(`; <b>Image has ${ts} ($${hdx(ts)}) sectors of ${atr.sector_size} bytes - ` + density + "</b>"); //(PVB MOD)
        //(PVB ADD) SpartaDOS dosType management
        //if (formatStrError) txt.push(formatStrError); ///WIP//
        if (atr.dosType == 0) { //Sparta
            if (atr.vtoc1_sect) txt.push("; Jump to SpartaDOS <a id='BOOT' href='#VTOC'>Disk Bitmap</a> (VTOC)");
        }
        else if (atr.dosType > 0) { //not for Sparta for which dosType == 0
            var t1 = "disk has been identified";
            var t2 = "1 block is 1 sector";
            switch (atr.dosType) {
                case 1: 
                case 2:
                case 2.5:
                    txt.push(`; DOS${atr.dosType} ${t1}, ${t2}`);
                    break;
                case 3: txt.push(`; DOS3 ${t1}, 1 block is 8 sectors`); break;
                case 6: txt.push(`; MyDOS ${t1} (compatible with DOS2), ${t2}`); break;
                case 7: txt.push(`; MyDOS ${t1} (not DOS2 compatible), ${t2}`); break;
                case 8: txt.push(`; MyDOS4.5x HD ${t1} (more than 1440 sectors), ${t2}`); break;
            }
            if (atr.dirErrorStr) txt.push(`; WARNING${atr.dirErrorStr}`);
            if (atr.freeBloc || atr.totalBloc) {
                t1 = "; DOS disk has " + atr.freeBloc + " ($" + hdx(atr.freeBloc) + ") free blocks,";
                t1 += " among a total of " + atr.totalBloc + " ($" + hdx(atr.totalBloc) + ") blocks";
                txt.push(t1);
            }
            if (atr.vtoc1_sect) txt.push("; Jump to <a id='BOOT' href='#VTOC'>VTOC</a>");
            if (atr.vtoc2_sect) txt.push("; Jump to <a id='BOOT' href='#VTOC2'>VTOC2</a>");
            if (atr.dir_sector) txt.push("; Jump to <a href='#DIR'>Directory</a>");

        }
        else if (atr.dosType < 0)
            txt.push(`; WARNING${atr.dirErrorStr}`);

        txt.push("");
        //(PVB EN OF ADD)

        // Display boot sectors, disassemble them
        txt.push(";<b> Boot sector record:</b>"); //(PVB) update text
        var k = Object.keys(_br);
        //(PVB MOD & ADD)
        var bi = '', bic = '';
        for (var i = 0; i < (sparta ? 5 : k.length); i++) {
            txt.push("; " + bi + pad_hex(_br[k[i]]) + " " + k[i] + bic);
            //(PVB ADD) display more information about boot
            if (i == 3 && !sparta) {//(PVB COM) 3rd value => check the jump
                if (d[22] == 0x4C) //(PVB COM) test of the JUMP $4C to BCOUNT
                    txt.push("; Boot execution start with a JUMP to BCONT=$" + hex(_br[k[4]],4));
                else {
                    txt.push("; Boot execution start at BLDADDR+6=$" + hex(_br[k[2]]+6,4));
                    bi ="<i>"; //(PVB COM) set text in italic because it is not mandatory for a non DOS disk
                    bic ="</i>";
                }
                if (atr.dosType < 1 || atr.dosType == 3) break;
                txt.push("; " + bi + "<b>Additional DOS boot info:</b>" + bic);
            } //(PVB END OF ADD)
        }
        if (sparta) {
            txt.push("");
            txt.push("; <b>SpartaDOS</b>");
            var br = sparta.boot;
            var k = Object.keys(br);
            for (var i = 0; i < k.length; i++) {
                if (k[i] == 'volume_name')
                    txt.push(`;      ${k[i]} '${br[k[i]]}'`);
                else
                    txt.push("; " + pad_hex(br[k[i]]) + " " + k[i]);
            }
            //(PVB ADD) SpartaDOS version
            var v ="";
            if (br.version == 0x11) v = "SpartaDOS 1.1";
            else if (br.version == 0x20) v = "SpartaDOS 2.x, 3.x, or SpartaDOS X 4.1x/4.2x";
            else if (br.version == 0x21) v = "SpartaDOS X >= 4.39 (version 2.1 filesystem)";
            else v = "an unknown version";
            txt.push(`;\n; SpartaDOS version is $${hex(br.version,2)} that is ${v}`);
        }
        txt.push(";");

        //(PVB ADD) Prepare data for the Disk Sector Dump and display the file directory list
        // Scan files/sectors
        //TODO Broken links, deleted files (PVB COM)=> this should be now OK
        //(PVB MOD) cancel the use of get_dir() in this fucntion & add the restructured feature
        //previously //var dirs = atr.get_dir();
        var dirs = [];
        var blocsectors = []; //array for display file and its block / sector in the sector listing
        //(PVB ADD) display the directory of DOS files
        txt.push("");
        if (f.dosdir && f.dosdir.length) { //OK, there are files, list them and add "save all valid button"
            if (atr.dosType == 0) //if spartaDOS
                txt.push(`; The following SpartaDOS files has been found in the <i>"${atr.name}"</i> disk image`);
            else { //atr.dosType > 0 for other DOS
                var btmp = `<button style="float:right" type="button" title="=extract all the files from disk image (use with care)" onclick="save_as_dsk('ALL')">Download all valid files</button>`;
                txt.push(`; <i>"${atr.name}"</i> has a directory with the following DOS files: ${btmp}`);
                //txt.push(`; The following DOS2x/MyDOS files has been found in the <i>"${atr.name}"</i> disk image`);
            }
        }
        else //no DIR found
            txt.push(`; <i>"${atr.name}"</i> has no identified DOS files\n`);
        
        var strList = "";
        if (!atr.restructured && f.dosdir.length) {
            txt.push("; <b>Directory on disk " + (atr.isDos3 ? "(1 block = 8 sectors)" : "(1 block = 1 sector)") + ":</b>");
            txt.push("; FileId Flag Name          StartSector NbrBlocks   FileSize bytes  Info");
            //        ; #1     $80  12345678.123  $000(0000)  $000(0000)  $12345(123456)
            dirs = f.dosdir;
            //previously// dirs.forEach(dir => dir.sectors.forEach(s => { sectors[s.sector] = { dir: dir, sector: s } }));
            //(PVB END OF ADD)
            //(PVB MOD) add the directory listing
            dirs.forEach(fe => { //for each file entry from the dos directory
                var dt = "";
                var isdir = (atr.dosType > 5 && fe.flags & 0x10) || ((fe.flags & 0x20) && sparta);
                fe.sectors.forEach(sect => {
                    blocsectors[sect.sector] = {dirName: fe.name, dirTotal: fe.total, dirOffset: sect.fbloc}
                });
                if (sparta && fe.valid > 1) { //(PVB ADD) SpartaDOS file info
                    //Special for SpartaDOS, the file first sector is the file sector map 
                    fe.maps.forEach(sect => {
                        blocsectors[sect.map] = {dirName: fe.name, dirTotal: fe.total_map, dirOffset: sect.fbloc, map:true}
                    });
                    dt = " created on [" + pad_dtime(fe.date, false) + "-" + pad_dtime(fe.time, true) + "]";
                }
                if (isdir) strList += "<b>"; //Directory diplayed in bold
                strList += ";" + (fe.numidf == '=>' ? pad_dir(("(#"+ fe.fnum + ")"),6) : pad_dir((" #"+ fe.numidf),8));
                strList += (fe.numidf == '=>' ? "=> --  " : ("$" + pad_dir(hex(fe.flags,2),4))) + pad_dir(fe.name, 13);
                strList += (" $"+ hex(fe.start,3) + pad_dir((" (" + fe.start + ")"), 7)); //start sector
                strList += (" $"+ hex(fe.total,3) + pad_dir((" (" + fe.total + ")"), 7)); //total blocks
                strList += (" $"+ hex(fe.fsize,5) + pad_dir((" (" + fe.fsize + ")"), 9)); //file size
                if (fe.err) strList += fe.err; else strList += dt;
                if (sparta && fe.numidf == 0) strList += "[ROOT MAIN DIRECTORY]"; //first entry for SpartaDOS is MAIN
                else { //if not "Sparta first entry"
                    if (isdir) strList += "[DIR]";  // show "DIR" text if isdir
                    if (fe.dir_name) strList += "[Parent is " + fe.dir_name + "]"; //show parent "dir_name" if not empty
                }
                //check cases identifying an empty file, whatever DOS type (0 bytes directory is OK)
                if (fe.valid != 1 && (!fe.fsize || !fe.sectors.length) && !isdir) strList += " =>empty entry"; 
                //if file number is "=>" then it is an hidden/ canceled file that may be recovered
                strList += (fe.numidf == '=>') ? (" =>may be recovered ?\n" ) : "\n";
                if (isdir) strList += "</b>";
            });
            txt.push(strList + ";");
        }
        else {
            console.log("show_atr() ATR has no DIR");
        }

        //(PVB COM) Display the disassembly of boot sectors
        var size = atr.sector_offset(_br.BRCNT + 1);    // 0 based for data to load
        var boot = d.slice(16, size); //(PVB COM) copy boot sector data, minus 16 first bytes (ATR header)
        //(PVB MOD & ADD)
        var entries = [_br.BINTAD];
        //(PVB COM) check boot sector validity
        //cont = is the address after the JMP, minus the boot load address (usualy $700)
        //if cont is negative, we keep cont for boot loading address; otherwise cont is the address after the JUMP
        //org = _br.BLDADDR = boot load address ; entry = cont
        if(_br.BCONT && (_br.BCONT -_br.BLDADDR) > 9)
            entries.push(_br.BCONT);

        txt.push(xex_dump(_br.BRCNT, boot, 0, boot.length, "BOOT", _br.BLDADDR, entries));
        txt.push('\n' + _hr);
        txt.push('; <b>Disk Boot sector hexdump</b>');
        txt.push(_hr + '\n');

        //(PVB COM) Display the sector of the ATR disk image file
        var n = 0; //(PVB COM) n is the sector counter
        var ns = 1;
        var bb = 0;
        for (; ;) { //(PVB COM) endless loop, stop when offset index is greater than the ATR size
            var size = n < 3 ? 128 : atr.sector_size;
            var offset = atr.sector_offset(n + 1);
            if (offset >= (atr.size + 16))
                break; //(PVB COM) ens of loop, last sector has been reached !
            
            var zero = is_zero(d, offset, size);

            switch (++n) {
                case atr.vtoc1_sect:
                    if (!sparta) txt.push("; <span id='VTOC'>VTOC Volume Table of Contents <a href='#BOOT'>(back)</a></span>");
                    else txt.push("; <span id='VTOC'>SpartaDOS Bitmap fist sector (VTOC)<a href='#BOOT'>(back)</a></span>");
                    break;
                case atr.dir_sector: txt.push("; <span id='DIR'>Directory <a href='#BOOT'>(back)</a></span>"); break;
                case atr.vtoc2_sect:
                    txt.push("; <span id='VTOC2'>VTOC2 Volume Table of Contents 2<a href='#BOOT'>(back)</a></span>"); break;
            }
            var bsn = blocsectors[n]; // .sectors correspond au chainage des secteurs d'un fichier DOS valide
            var sstr = "";
            if (bsn) { //the sector belongs to a file (or file sector map for Sparta)
                var sb = bsn.dirOffset + 1; //dirOffset = number of the sector or block in the file
                //(PVB MOD) if sb == 0; this is the file sector_map of a spartaDOS file
                sstr += " [" + bsn.dirName;
                if (bsn.map) sstr += " - File Sector Map"; //for SpartaDOS only
                sstr += atr.dosType == 3 ? " - Block" : " - Sector";
                if (sb) sstr += " $" + hdx(sb) + "(" + sb + ") of $" + hdx(bsn.dirTotal) + "(" + bsn.dirTotal + ")]";
                if (atr.dosType == 3) {
                    bb = ((n - 0x19) >> 3) + 1;
                    if (ns == 9 && bsn.dirName) ns = 1;
                    sstr = sstr + " <i>[DOS3 block #" + bb + "/sect." + ns++ +"]</i>";
                }
            }
            //previously // var sstr = s ? ` (${s.dir.name} ${(s.sector.offset+1)} of ${s.dir.total})` : '';
            //previously // txt.push("; Sector " + n + (zero ? " (" + size + " zeros)":"") + sstr);
            //(PVB MOD) display sectors with counting from 1 and not 0
            txt.push('; Sector $' + hex(n, 3) + ' (' + n + ');' + (zero ? ' (' + size + ' zeros)' : '') + sstr);
            if (!zero)
                txt.push(hex_dump(d, offset, size, 4));
            txt.push('');
            if (n == _br.BRCNT) { // for the last sector of the boot
                txt.push(';<i>End of Disk Boot sector hexdump \><a href="#top">Back to top</a></i>\n');
                txt.push(_hr);
                txt.push('; <b>Disk sector hexdump</b>');
                txt.push(_hr);
                txt.push('');
            }
        }
        txt.push(';<i>End of Disk sector hexdump \><a href="#top">Back to top</a></i>');

        render_file(f);
        _h("#show", txt.join('\n'));
    }

    //(PVB ADD) functions retrieve_file_data(f), show_hexdump(f), and show_extract(f)
    //called by show(id) in case of _shown.extract_launched is true
    //or called by toggle_hex() to display file Hex Dump
    function retrieve_file_data(f) {
        var d;
        if (f.type == "isDisk") d = f.atr.d.slice(16, f.atr.d.length); //data of an "isDisk" without the ATR 16-bytes header
        else if (f.type == "isRomdump" && f.rom.isCart) d = f.data.slice(16, f.data.length); //retrieve data of an "isRomdump", without the CART header
        else d = f.data; //else retrieve data of an "isFile" or "isRaw" or "isRomdump"
        return d;
    }
    function show_hexdump(f) {
        render_file(f);
        var d = retrieve_file_data(f);
        var str = '; Hexdump view of "' + f.name + '"" file data';
        if (f.start && f.total) str += '\n; [Start sector: $' + hdx(f.start) + '; ' + f.total + ' blocks or sectors]'; //only if is an Atari DOS file
        str += '\n\n' + hex_dump(d, 0, d.length, f.type == "isDisk" ? f.atr.sector_size : 0) + '\n;<i>End of Hexdump \><a href="#top">Back to top</a></i>';
        _h("#show", str);
    }
    function show_extract(f) { //display the extract menu and the hex dump
        //(PVB TODO) to limits the extract possibility according to f.ext or f.type
        if (f.type == "isTxtImg" || f.type == "isFnt" || f.type == "isArc") { //shall not be possible as "E" is disable for these file type
            console.log("Show_extract() cancelled because isTxt, isFnt, isArc");
            return; //no extract on a text, picture, font or Arc file
        }
        if (!f.extract_launched) {//no launch-extract has been launched yet, so just display hex_dump and not disassembly
            show_hexdump(f);
        }
        else { //an extract has been launched, so display disassembly
            var d = retrieve_file_data(f);
            console.log("show_extract() => Display the disassembly of the Extract"); //(PVB CONSOLE HINT)
            if (f.type == "isDisk") {
                var ss = f.extracted_disk.start_sect; 
                var es = f.extracted_disk.end_sect;
                var so = f.extracted_disk.start_sect_off;
                var ad = f.extracted_disk.start_add;
                var sta = (ss < 4) ? (so + (ss - 1) * 128) : (384 + so + (ss - 4) * f.atr.sector_size);
                var sto = (es < 4) ? (es * 128 - 1) : (384 + (es - 3) * f.atr.sector_size - 1);
                if (sta < sto && sto <= d.length) { //(PVB COM) protection in case of extract_disass() has done wrong
                    var de = d.slice(sta, sto + 1);
                    render_file(f);
                    _h("#show", xex_dump("Disk extracted data", de, 0, de.length, "EXTRACT", ad));
                    f.extractedData = de;
                }
                else
                    alert("show_extract() ==> Something went wrong, extracted data error! ");  //(PVB COM) display an error in case of selection of range has done wrong
            }
            else {
                var so = f.extracted_file.start_offset; 
                var eo = f.extracted_file.end_offset;
                var ad = f.extracted_file.start_add;
                if (so <= eo && eo < d.length) { //(PVB COM) protection in case of extract_disass() has done wrong
                    var de = d.slice(so, eo + 1);
                    render_file(f);
                    _h("#show", xex_dump("File extracted data", de, 0, de.length, "EXTRACT", ad));
                    f.extractedData = de;
                }
                else
                    alert("show_extract() ==> Something went wrong, extracted data error!");  //(PVB COM) display an error in case of selection of range has done wrong
            }
        }
        return;
    }

    function update_a5200eq_option(f) {
        if (f) { // then this is a new file displayed, so update _bShowA5200Equates according to f.a5200eq
            _bShowA5200Equates = f.a5200eq ? 1 : 0;
        }
        //update a5200 equates display option
        var chkdof = document.getElementById("cShowA5200Eq"); //get the display option diplay Id
        if (chkdof) chkdof.className = _bShowA5200Equates == 1 ? "hilite" : ""; //if Id, then update it
        _checks['cShowA5200Eq'] = _bShowA5200Equates; //update _checks table
    }

    //(PVB END OF ADD)

    //(PVB MOD) improvement of the show(id) function
    function show(id) { //(PVB COM) show(id) is call on click event on file canva container to display the file on page right
        //id is the number of file in the container files, last available value is in the global variable _id
        //show(id) is also use the re-display the same file when clicking on tools (E extract, H Hexdump...) and buttons
        try {
            var f = get_file(id);
            if (_shown) { //a file is already displayed
                if (id != _shown.id) { //we have changed to another file !
                    ///WIP// here: action if click on a different file
                    reset_ext(); //if changed type in the previous file, cancel it (same as click on Reset Type button)
                    reset_hexdump(); //if hexdump display in previous file, cancel it
                    ///WIP// if (_shown.extract) reset_extract(); //same as click on Cancel Extract button
                    update_a5200eq_option(f); //(PVB ADD) update the A5200 equates disassembly option in menu
                    console.log("show(id) => we have changed to another file !");
                }
                //else // we have the same file selected: action not useful, because show(id) can be called several times for displaying same file !!
            }
            var isTypeChanged = false; ///WIP// futur use
            console.log("show(id) => Trying to show id: " + id + ", Name: '" + f.name + "'");
            if (f.type == "spacer") { //in case of "spacer" set the click to the next id that must be the ATR disk
                f = get_file(++id);
                console.log("show(id) => Get next id: " + id + ", Name: '" + f.name + "', file type: " + f.type); //(PVB CONSOLE HINT)
            }
            if (f.data.length == 0){ //(PVB COM) This should not occur
                alert("Nothing to show ! The selected file  " + id + ", Name: '" + f.name + "', file type: " + f.type + " is empty !"); //(PVB ADD) (PVB CONSOLE HINT)
                return;
            }

            //(PVB MOD) use of get_type() that is already in f.type instead of e = _exts[f.ext];
            if (f.original_ext && f.original_ext != f.ext) { //we have changed the ext type !
                var ntype = get_type(f.ext, false); //get type of new ext, false for not to consider "isFile" for DOS file
                console.log("show(id) => New extension request! id: " + id + ", Name: '" + f.name + "', new ext: " + f.ext + ", file type: " + ntype); //(PVB CONSOLE HINT)
                if (f.type != ntype) { //we have changed the file type !
                    console.log("  > notice this has changed the file type that was: '" + f.type + "'");
                    isTypeChanged = true; ///WIP// futur use
                }
            }

            _shown = f; //(PVB COM) save the current selected file into the _shown global variable
            
            update_a5200eq_option(false); //set the A5200 equates disassembly option in menu

            if (f.extract_menu_request && (f.type != "isRomdump")) { // rom extract is managed below
                show_extract(f);
                return;
            }
            if (f.forceHexDump && ntype !="isRaw") { //no forced hexdump for "isRaw" (dat), it is a normal dump above
                //(PVB TODO) do special hexdumps for Rom Banks 
                show_hexdump(f);
                return;
            }
            if (f.ext == "bas") {
                show_bas(f);
                return;
            }
            if (f.ext == "m65") {
                show_m65(f);
                return;
            }
            if (f.ext == "fnt" || f.ext == "chr") {
                show_fnt(f);
                return;
            }
            if (f.ext == "arc") {
                show_arc(f);
                return;
            }
            //(PVB ADD) ROM Dump
            //if (e && e.is_romdump){
            //Warning f.type is not set after changing an extension type, so a RomDump will still be a romdump, even if extension is changed
            if (f.type == "isRomdump") {
                if (f.extract_menu_request) {
                    show_extract(f); //(PVB TODO) do special extract within the selected bank for ROM
                    return;
                }
                if (f.ext != "dat") { 
                    show_rom(f); 
                    return;
                } //else ROM is displayed as DAT as below
            }
            //if (e && e.is_disk) {
            //Warning f.type is not set after changing an extension type, so an isDisk will still be an is Disk, even if extension is changed
            if (f.type == "isDisk") { //for the atari disk like XFD, ATR...
                if (ntype != "isRaw") {
                    show_atr(f, f.ext == "dsk"); //(PVB COM) Rawmode in show_atr() if ext == "dsk"
                    return;
                } //else the isRaw will be displayed as below 
            }
            //other files
            var e = f.ext == '???' ? _exts["dat"] : _exts[f.ext]; //(PVB ADD) mandatory : if extension is unknown (???), then force .dat
            if (e && e.is_img) {
                show_img(f);
                return;
            }
            if (e && e.is_txt) {
                show_txt(f);
                return;
            }
            console.log("show(id) => ...render_file (f) which name is: " + f.name + ", ext: " + f.ext + ", type: " + f.type); //(PVB CONSOLE HINT)

            render_file(f); //(PVB COM) display title and type selection list on page top right in #main

            if (e && e.is_code) { //(PVB COM) when it si "is_code" (and not a ROM or an Atari disk) => disassemble it !
                console.log("show(id) => xex_dump() of '" + f.name + "'");//(PVB CONSOLE HINT)
                //display of disassembly code in the <pre id="show"
                _h("#show", xex_dump(f.name, f.data, 0, f.data.length, (e.has_header ? "HEAD" : "BIN"))); //(PVB COM) BIN has no header
                return;
            }

            //(PVB COM) here we have a special file like "???" or "DAT", so display an Hex Dump of the file
            console.log("show(id) => ??? or DAT file HEX_dump() of '" + f.name + "' (with extension: '" + f.ext + "') as " + e.name);//(PVB CONSOLE HINT)
            var str = '; Hexdump of '; //(PVB ADD) hint on hexdump display
            if (f.is_dir) str += 'directory file "' + f.name + '"';
            else str += 'data in file "' + f.name + '" which extension ' + (f.ext == '???' ? 'type is unknown and shown as DAT' : (f.original_ext ? "is forced to DAT" : "is DAT"));
            if (f.start && f.total) str += '\n; [Start sector: $' + hdx(f.start) + '; ' + f.total + ' blocks or sectors]'; //only if is an Atari DOS file
            _h("#show", str + '\n\n' + hex_dump(f.data, 0, f.data.length) + '\n\n;<i>End of Hexdump \><a href="#top">Back to top</a></i>'); //(PVB COM) default hex_dump() as for a DAT file
        }
        catch (err) {
            console.log(err);
            /*previously//show_as("dat"); //(PVB COM) No need to keep this action, since no error should now occur thanks to the tool upgrade*/
            //so warn to kindly report to development team (i.e. myself, pvbestinfoo!)
            var str = '[! ERROR while trying to display file Id #' + id + ' "' + f.name + '"!]\n[See HTML Console log for details & Please report the bug to development team]';
            _h('#show', '<span style="color:red;">' + str + '</span>');
        }
    }

    //(PVB ADD) the reset_hexdump() function
    function reset_hexdump () {
        if (_shown.forceHexDump) _shown.forceHexDump = 0;
    }
    
    function show_as(e) {
        if (_shown) {   //(PVB COM) _shown is the 'file' shown on right page
            if (!_shown.original_ext) {
                _shown.original_ext = _shown.ext; //save original ext
                reset_hexdump(); //cancel Hex Dump display if type changing
            }
            _shown.ext = e;
            refresh();    // select one
        }
    }

    //(PVB ADD) the reset_ext() function
    function reset_ext() { //called by reset_type_button() and in show(id)
        if (_shown.original_ext) { //yes there was a previous type
            _shown.ext = _shown.original_ext; //restore type
            delete _shown.original_ext; //delete saved type
        }
    }
    //(PVB ADD) the set_new_ext() function
    function set_new_ext() {
        if (_shown.original_ext) { //yes there was a previous type
            delete _shown.original_ext; //delete saved type to replace it
        refresh(); //to redisplay and update buttons
        } 
    }
    //(PVB ADD) the reset_type_button() function
    function reset_type_button() { //called by HTML event: onclick "Reset file type" button
        reset_ext();
        reset_hexdump();
        //reset_search(); ///WIP//
        //reset_extract(); ///WIP//
        refresh(); //re-display the file with previous extension in the "main" HTML page
    }

    //(PVB COM) toggle_hex() is used to force display of the file hex dump
    function toggle_hex() { //called by HTML event: onclick "H" tool
        /*//previously//
        if (!_shown) return;
        if (_shown.ext == "dat") show_as(_shown.original_ext);
        else show_as("dat");*/
        if (!_shown.forceHexDump === undefined)
            _shown.forceHexDump = 1; //invert flag
        else
            _shown.forceHexDump ^= 1;
        refresh(); //then re-display the file with forced Hexdump in the "main" HTML page
    }

    //(PVB ADD) toggle_disoption() is used to manage the "disoption" menu flag
    var _bShowDisOption = 0; //variable to memorize the choice
    function toggle_disoption(swtchon) { ///WIP// to simplify the toggle_disoption
        if (!_q("#disoption")) { //in case of #disoption is not in the HTML doc
            console.log("INFO: toggle_disoption has been canceled");
            return; 
        }
        if (swtchon) {
            _bShowDisOption = 1;
            toggle_on("#disoption");
        }
        else {
            _bShowDisOption ^= 1;
            toggle("#disoption");
        }
    }
    //(PVB ADD) toggle_extract() is used to display/hide the Extract menu (click on "E") and set/reset the f.extract_menu_request flag
    function toggle_extract() {
        if (!_shown.isExtractable) return; //if file not extractable, then do nothing
        if (!_shown.extract_menu_request === undefined) _shown.extract_menu_request = 1; //invert flag
        else _shown.extract_menu_request ^= 1;
        console.log("INFO: toggle_extact flag is: " + (_shown.extract_menu_request ? "ON" : "OFF"));
        reset_hexdump();
        refresh(); //then re-display the file in the "main" HTML page
    }
    //(PVB ADD) toggle_search() is used to display/hide the Search menu and set/reset the f.searchrequest flag
    function toggle_search() {  ///WIP//
        if (_shown.isSearchable) {
            if (_shown.searchrequest === undefined) { //first time
                _shown.searchrequest = 1; //activate search
                _shown.dataOld = _shown.data; //save data before modification
                _shown.offst = 0;
            }
            else { //request exists
                delete _shown.searchrequest;
                _shown.data = _shown.dataOld;
                delete _shown.dataOld;
                delete _shown.offst;
            }
            refresh();
        }
    }
    //(PVB END OF ADD)

    function refresh() {
        show(_shown.id);
    }

    function close_container(id) { //close_container(id) is called when user click on the cross to close file on page left
        for (var i = 0; i < _containers.length; i++) {
            if (_containers[i].id == id) {
                _containers.splice(i, 1);
                break;
            }
        }
        //previously// render_state(_containers); //instead of// refresh_containers();//PVB COM) it's better to comme back to first file when other file is cancelled
        refresh_containers(true); //(PVB ADD) set to true in case of _containers closing to refresh properly displayed file
    }

    //(PVB MOD) improvement of load_one(): handle ROM file, display of size in KB or B
    function load_one(name, ext, a, imgTag, t) { //(PVB COM) load_one() is called by load_data() when the disk image file is not a disk with several DOS files
        //(PVB ADD) handling the ROM case with the ROM constructor
        var r;
        console.log("load_one() loads " + name + " that is a '" + t + "' into the container"); //(PVB HINT)
        if (t == "isRomdump") {
            r = new ROM(a, name);
        }
        //(PVB ADD) handling the computation of the image file size in KB or B
        var strSize = '';
        if (a.length < 1024) {
            strSize = a.length + "B ";
        }
        else {
            n = (a.length & 0x3FF) ? (a.length >> 10) + 1  : a.length >> 10 ;
            strSize = n + "KB";
        }
        //(PVB end of ADD)
        //(PVB MOD) //Previously // var f = { name: name, ext: ext, data: a, id: _id++, total: ((a.length + 127) >> 7, img: img };
        var f = { name: name, ext: ext, type: t, data: a, id: _id++, total: strSize, imgTag: imgTag };
        //(PVB ADD)
        if (r && t == "isRomdump") {
            f.rom = r;
            if (r.romMachine == '5200') { //initialize the a5200eq here because it's not done show(id) nor in show_rom()
                f.a5200eq = true;
                _bShowA5200Equates = 1;
            }
        }
        //(PVB end of ADD)
        var i = name.lastIndexOf(".");
        var ext83 = ext;
        if (i != -1) {
            ext83 = name.substr(i + 1);
            name = name.substr(0, i);
        }
        if (i > 8 || ext83.length > 3){ //(PVB MOD)
            f.name83 = name.substr(0, 5); //(PVB MOD)
            f.name83 += "..."; //(PVB MOD)
        }
        else{ //(PVB MOD)
            f.name83 = name.substr(0, 8);
            while (f.name83.length < 8)
                f.name83 += ' ';
        }
        f.name83 += ext83.toUpperCase().substr(ext83.length - 3, 3);
        _containers.unshift({ name: f.name, ext: ext, type: "container", data: a, files: [f], id: _container_id++ }); //(PVB MOD) single file into container
        return f;  //(PVB COM) the return of "f" is required with flush_images() function via the load_data() that calls the load_one()
    }

    //(PVB MOD) improvement of load_data()
    function load_data(name, a, imgTag) { //(PVB COM) load_data() is called by load() and flush_images() to load the OS/Windows Image file into memory
        //(PVB COM) name = full filaname of the disk image file like "Foo.XFD"; a =  data of the OS/Windows file;
        // imgTag = the image type/mime when the Client loads an image without file extension
        console.log("load_data() Loading '" + name + "' with imgTag " + imgTag + "..."); //(PVB HINT)
        var ext = get_ext(name, a, imgTag, false); //(PVB COM) get the filename extension
        //(PVB MOD) the new function get_type() to remplace "var e = _exts[ext]; "
        var t = get_type(ext, false); //false for not to consider "isFile" for DOS file
        //(PVB COM) if not an "isDisk", there is no DOS files in a directory to retrieve, so it is a single file to open with load_one()
        if (t != "isDisk") { //(PVB COM) //previously // if (!e || !e.is_disk)
            return load_one(name, ext, a, imgTag, t);
        }
        console.log("load_data() loads the 'isDisk' into an ATR file..."); //(PVB HINT)
        //(PVB MOD) improvement of the files array
        var atr = new ATR(a, name);
        if (!atr) {
            console.log("load_data() => ATR Constructor error - file " + name + " cannot be converted into ATR");
            return null;
        } 
        var files = []; //"files" array is the list of files to be displayed in the blue directory on page left by render_state(m)
        if (!atr.restructured) { //(PVB ADD) if "restructured" no need to seek for a directory, no file on restructured ATR disk
            var dirs = atr.get_dir();
            dirs.forEach(f => { //purpose here is to get type of each Atari DOS file, and if OK, to set it in the blue directory 
                if (f.valid == 2 && f.sectors.length) { //if not valid, or no sectors (empty file) the file is not displayable, so exit to next "f"
                    var file = { name: f.name, name83: f.name83, id: _id++, start: f.start, total: f.total, flags: f.flags, recovered: f.recovered, is_dir: f.is_dir};
                    file.data = atr.read_file(f);
                    //(PVB COM) initialisation of the file size in the directory: "dirs.fsize" is done in read_file()
                    /* chaining check in one_dir makes the error check, so "f.errors" does not exist and has no use anymore
                    if (f.errors) { 
                        console.log("Load_data() for ATR : Error reading DOS file " + f.name);
                        console.log(f);
                    }*/
                    file.dosType = atr.dosType; //copy dosType in the file, DOS type found into the ATR disk is an important information to know
                    file.ext = f.is_dir ? "???" : get_ext(file.name, file.data, false, true); //actual ext is from get_ext() (and not from filename ext)
                    if (!f.ext || (f.ext.toLowerCase() != file.ext)) file.forced_ext = true; //if the ext is forced to have a correct display of the file
                    console.log(" ...get_ext() returns '" + file.ext + "' extension for " + file.name + " Atari DOS file!");
                    //if ext has been forced to bin, set the isFile not to confuse it with RomDump, otherwise get the type of file from get_type()
                    file.type = (file.ext == 'bin') ? "isFile" : get_type(file.ext, true); //true for "isFile" for DOS file
                    files.push(file);
                }
            });
            console.log("load_data() ATR file " + name + " has a DOS directory with " + files.length + " valid DOS files"); //(PVB HINT)
        }
        else {
            console.log("load_data() file " + name + " ATR has been restructured, no DOS directory applicable"); //(PVB HINT)
        }
        //(PVB COM) files = table of valid ATARI DOS files found into the ATR disk; so files.length is the number of files
        if (files.length) {
            //(PVB COM) if files where found, add a spacer (empty line) under the directory list as a file, that will be displayed in blue on left
            //(PVB MOD) the "spacer" type: name83 is empty, ext is empty. 
            files.push({ name83: "", name: "", ext: "", type: "spacer", data: [], id: _id++});
        }
        //(PVB MOD) add the name of the ATR disk file as the last file in the list
        //.name 83 : is used to display the number of sector on ATR disk, .name is the name of the ATR File (foO.XFD)
        //.type is set to the type of file, which is a "isDisk", .data : is set to the data of the ATR disk
        //.atr and .dosdir are added to save the atr construction data, and the valid DOS directory found
        files.push({ name83: (atr.sector_count + "-sector disk"), name: name, ext: ext, type: "isDisk", data: a, id: _id++, atr: atr, dosdir: dirs });
        _containers.unshift({ name: name, length: a.length, data: a, ext: ext, type: "container", files: files, id: _container_id++ }); //(PVB MOD) files into container
        console.log("load_data() has loaded " + name + " (and its DOS files) into the container"); //(PVB HINT)
    }

    //===================================================================================================
    // https://www.atarimagazines.com/software/software.html

    var _images = [];

    function flush_images() {
        _images.forEach(f => {
            var b = '';
            for (var i = 0; i < f.data.length; i++)
                b += String.fromCharCode(f.data[i]);
            var url = `data:${f.file.type};base64,${btoa(b)}`;

            var img = document.createElement('img');
            img.src = url;
            img.hidden = true;
            img.onload = (evt) => {
                load_data(f.file.name, f.data, img).edit_img = 1;
                refresh_containers();
                document.body.removeChild(img);
            }
            document.body.appendChild(img);
        });
        _images = [];
    }

    function refresh_containers(close) { //(PVB COM) refresh_containers() is used to select the first file on the list on page left to be shown on the right!
        render_state(_containers);
        if (_containers.length) { //there is a _containers, so file to display
            //(PVB MOD) add the *opened file remaining displayed* in case of a "close" file container occurs (X icon click) 
            var exit = false;
            if (_shown && close) // if an opened file is displayed, and close _containers requested 
                _containers.forEach(c => c.files.forEach(i => { if (i.id == _shown.id) exit = true })); //if the file is still in the _containers, exit
            //else display the root (=last file) of the first file of the _containers list (=the new loaded) - case by default
            if (!exit) show(_containers[0].files[(_containers[0].files.length - 1)].id);    // select on
            //(PVB MOD)//Previously//show(_containers[0].files[0].id); display the first file of the first container of the _containers list
        }
    }

    // #153382 - BG 0x94

    function open() {
        _q("#fe").click();
    }
    
    function load() { // (PVB COM) load() is the HTML Javascript main function
        drop_init(_q("#toc"),
            (file, ab) => { //(PVB COM) file = client loaded file; name = name of the client loaded file, and properties
                //ab = ArrayBuffer for the file data (byteLenght = size of the file)
                if (file.type.indexOf("image") != -1) //check file MIME type, if is is an image picture file
                    _images.push({ file: file, data: new Uint8Array(ab) }); //if so, file is push in _images
                else //it is not an image picture file
                    load_data(file.name, new Uint8Array(ab)) //file data is loaded by the load_data() function
            },
            () => {
                flush_images();
                refresh_containers();
            }
        );
        _fcanvas = get_font(_font);

        document.body.onkeyup = function (e) {
        }

        document.onselectionchange = selection_change; //(PVB COM) watch where is the mouse pointer, and if text is selected by the carret

        document.body.onkeydown = function (e) {
            if (e.ctrlKey && e.shiftKey) {
                switch (e.key) {
                    case 'o':
                    case 'O':
                        open();
                        break;  // open a file....
                    case 'h':
                    case 'H':
                        toggle_hex();
                        break;  // toggle hex display
                    case 'k':
                    case 'K':
                        toggle_kb();
                        break;  // toggle keyboard
                }
            }
        };
        render_state(_containers);
    }

    //(PVB ADD) the toggle_on() function to force display (instead of switching it in toggle() function)
    ///WIP// to simplify & merge the toggle & toggle_on function ?
    function toggle_on(eid) { //toggle_on() is used by toggle_disoption() to force dsiplay of the option menu
        var e = _q(eid);
        if (e) e.style.display = "block"; //force to set display block on
    }
    function toggle(eid) { //toggle(eid) is used by disassemble2()/as_data() for data block and toggle_disoption() for option menu
        var e = _q(eid);
        if (e) e.style.display = e.style.display == 'none' ? "block" : "none";
    }

    //(PVB ADD) show_bank(id) function is called by show_rom(f)
    //Note : the button [Toggle Disassembly/HexDump] set in show_rom(f) calls the show_bank(id) function to toggle disassembly / hex dump
    function show_bank(id) {
        var r = _shown.rom;
        var eid ="#FWTOBANK" + id;
        var s = _q(eid);
        var str = s.innerHTML;
        var eid ="#BANK_" + id;
        if (str.lastIndexOf("HEX DUMP") > 0)
        {
            s.innerHTML = str.replace("HEX DUMP", "DISASSEMBLY");
            var entries = [r.rom_init, r.rom_coldstart];
            _h(eid, xex_dump("ROM Cartridge", r.romData, r.romBankMap[id].offset, r.romBankMap[id].len, "ROM_" + hex(id,2), r.romBankMap[id].start, entries));
        }
        else
        {
            s.innerHTML = str.replace("DISASSEMBLY", "HEX DUMP");
            _h(eid, "\n" + hex_dump(r.romData, r.romBankMap[id].offset, r.romBankMap[id].len, (r.romBankMap[id].start + id)));
        }
    }
    //(PVB END OF ADD)

    //(PVB MOD) improvement of function ext_option() add the enabling/disabling list fields when required
    function ext_option(f) { //(PVB COM) ext_option(f) function is called by render_file(f) for the selection list of ext types 
        //(PVB ADD) The enable table of extension for the selection list of ext types
        const _entable = { //list of f.type, normaly set by get_type()
            "isArc" :     [0,0,0,0,0,1,1, 0, 0,0,0,0,0,0,0,0,0,0, 0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0, 0,0,0,0,0,0,0,0,0],
            "isDisk" :    [1,1,1,1,1,1,0, 0, 0,0,0,0,0,0,0,0,0,0, 0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0, 0,0,0,0,0,0,0,0,0],
            "isRaw" :     [1,1,1,1,0,1,1, 0, 1,1,1,1,1,1,1,1,1,1, 0, 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, 0, 1,1,1,1,1,1,1,1,1],
            "isFile" :    [0,0,0,0,0,1,0, 0, 1,1,1,1,1,1,1,1,1,1, 0, 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, 0, 1,1,1,1,1,0,0,0,0],
            "isTxtImg" :  [0,0,0,0,0,1,0, 0, 1,1,1,1,1,1,1,1,1,1, 0, 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, 0, 1,1,1,1,1,0,0,0,0],
            "isRomdump" : [0,0,0,0,0,1,0, 0, 0,0,0,0,0,0,0,0,0,0, 0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0, 0,0,0,0,0,1,1,1,1]
        };
        var e = f.ext == '???' ? "dat" : f.ext; //(PVB MOD) force extension "???"" to be a "DAT" in the list
        var s = `<div style='display:inline-block'><label>Ext Type :<select onchange="show_as(this.value)" title="...you can try to change type" name="ext_type">`;
        //(PVB MOD) Add display of extension in the list
        //previously// Object.keys(_exts).forEach(ext => s += `<option ${ext[0] == '-' ? "disabled" : ""} value='${ext}' ${ext == f.ext ? 'selected' : ''}>${_exts[ext].name} ${ext[0] == '-' ? "" : " (" + ext + ")"}</option>`);
        var i = 0;
        Object.keys(_exts).forEach(ext => s += `<option ${_entable[f.type][i++] ? "" : "disabled"} value='${ext}' id='id_${ext}' ${ext == e ? 'selected' : ''}>${_exts[ext].name} ${ext[0] == '-' ? "" : " (" + ext + ")"}</option>`);
        s += `</select></label></div>`;
        return s;
    }

    //(PVB ADD) rom_option(f) function is called by render_file(f) for the selection list of ROM types
    function rom_option(f) {
        var s = `<label>Rom Type Selection: <select id="rommapid" onchange="apply_rommap(${f.id})">`;
        var k = f.rom.romKBSize;
        var t = f.rom.romTypeTxt;
        Object.keys(_romtypes).forEach(r =>
            s += `<option ${((r[5] == '#') || (_romtypes[r].size != k)) ? "disabled" : ""} value='${r}' ${(r == t) ? "selected" : ""}>
                ${r + ": " + _romtypes[r].name + " [" + _romtypes[r].machine + "]"}</option>`);
        s += `</select></label>`;
        return s;
    }
    //(PVB END OF ADD)

    function finfo(f) { //(PVB COM) finfo(f) function is called by render_state(m)
        var t = _exts[f.ext] ? _exts[f.ext].name : "'" + f.ext + "' file";
        return `<b>${f.name}</b><div style="font-size:small">${t} (${f.data.length} bytes)</div>`;
    }

    function redraw_palette() {
        _h(".palette", palette(_palette));
    }

    function pick_click(c, i) {
        _palette[c] = i;
        _reload_palette = 0;    // make sure our changes take
        refresh();
        redraw_palette();
        _reload_palette = 1;
    }

    var atari2css = (i) => '#' + hex(atari_palette_rgb[i], 6);
    function palette(colors) {
        function atari256(c) {
            var s = [];
            for (var i = 0; i < 256; i++)
                s.push(`<div class='acolor' title='${hex(i)}' onclick='pick_click(${c},${i})' style='background:${atari2css(i)}'></div>`);
            return s.join("");
        }
        var s = [];
        for (var c = 0; c < colors.length; c++) {
            s.push(
                `<div class='dropdown'>
                <div class='acolor' title='${hex(colors[c])}' style='background:${atari2css(colors[c])}'>
                    <div class='dropdown-content'>${atari256(c)}</div>
                </div>
            </div>`
            );
        }
        return s.join("");
    }

    function pick_mono(cr) {
        _mono_cr = cr;
        _radios["scheme"].value = 0;    // mono
        refresh();
    }

    function refresh_image_controls(f) {
        function monochrome() {
            var s = '';
            for (var i = 0; i < 16; i++) {
                var c = (i << 4) | 8;
                s += `<div class='acolor' title='${hex(c)}' onclick='pick_mono(${c >> 4})' style='background:${atari2css(c)}'></div>`;
            }
            return s;
        }
        _h("#image_controls", `
    <div class='exts' style="padding:8px">
        <div><b>dither</b><span class='radio'>${radio_init('dither', ['atkinson', 'floyd-steinberg', 'noise', 'ordered', 'none'])}</span><div><br />
        <div><b>scheme</b><span class='radio'>${radio_init('scheme', ['monochrome', 'r:g', 'random', 'kmeans', 'octree', 'median'])}</span><div><br />
        <div><b>monochrome</b><span style='padding-left:12px'>${monochrome()}<span><div><br />
        <div><b>distance</b><span class='radio'>${radio_init('distance', ['rgb', 'yiq', 'y'])}</span><div><br />
    </div>`);
    }

    function render_state(m) { //render_state(m) is mainly called by the main load() function, for containers 'm' displayed on page left, after loaded a file on the Client
        //(PVB COM) rendering = display the content at the left side of the HTML page (#menu_container) + init the right side if no file loaded
        var h;
        if (m.length == 0) {
            h = `<div style="text-align:center;color:#AAA"><h2>Drag Files Here</h2><h2>or</h2></div>`;
            _h("#tabs", "");
            _shown = null; //reset the content of the _shown global variable
        } else //(PVB COM) display the file name, the type, and the size on the left, above the file list (this is the container)
            h = m.map(container =>
                `<div>
            <span class='close-icon' onclick="close_container(${container.id})"></span>
            <div class='infof'>${finfo(container)}</div>
            <ul id="menu">
            ${container.files.map(file =>
                    `<li onclick="show(${file.id})">
                    <div><canvas id="canvas${file.id}"></canvas></div>
                </li>`
                ).join("")}
            </ul>
        </div>`
            ).join("");
        _h("#menu_container", h);

        //(PVB MOD) info(f) function improvement, DOS 3 support
        function info(f) {//info(f) is called by render_state(m), to display file characteristics on top left above file display
        //(PVB COM) f = DOS file from the Atari DOS file table
        //in case of single file, function load_one() initializes f.total with the KB or B size, like "17KB" for exemple
        //in case of mutiple files, load_data()->get_dir() initializes each file with DOS-number-of-blocks in f.total 
            var sLine = '';
            //(PVB COM) sLine format is "1234567890123456789012"
            //(PVB COM)             for ".*<FILENAMEext>..XXX.."
            var nFile = f.name83; // DOS filename (or number of sector for disk size if the container file is the "isDisk")
            //(PVB ADD) the different tyoe of DOS
            var isDos3 = f.dosType == 3;
            var isSparta = f.dosType == 0;
            var isStdDos = !isDos3 && !isSparta;
            //(PVB MOD)
            if (f.total) { //if the variable total exists and not equal to zero, display f.total in KB, B or in Secteurs size
                sLine += f.total; //(PVB COM) we start the string line from the end where the size in KB or B is displayed
                if (!isNaN(f.total)) { //padding of the DOS file size on 3 digit numbers with 0 at beginning...
                    while (sLine.length < 3)
                        sLine = '0' + sLine; //add 0 at the beginning
                    sLine += "  "; //add 2 spaces at the end
                    sLine = " " + sLine; //add 1 space at the beginning
                }
                else {  //(PVB MOD) padding the file size in B or KB to 6 total char, with space at the beginning
                    while (sLine.length < 6)
                        sLine= " " + sLine; //add space at the beginning
                }
            }
            else { //(PVB COM) there is no f.total: it is the spacer line or the total number of sector of disk to display
                //note : if f.total is 0, it means an empty file and this file is not listed in the "files" array to be displayed (see load_data())
                sLine = "   " + nFile; //nFile is empty, or nFile is the total sector on the disk
                while (sLine.length < 22) // we pad it at 22 chars
                    sLine = sLine + ' '; // padding with space
                return sLine;   // and directly display it
            }
            //(PVB MOD) nFile = f.names83, contains the DOS filename, we pad it on 11 chars
            while (nFile.length < 11)
                nFile += ' ';
            //(PVB MOD) Add the DOS flag management according to DOS type
            var locked = " ";
            if ((isDos3 && (f.flags & 0x02)) || isStdDos && (f.flags & 0x20) || isSparta && (f.flags & 0x01))
                locked = "*"; // '*filen.ame' for locked DOS file (non erasable)
            //(PVB MOD) Add the DOS "Opened File" from 1st bit and display it as in DOS2.5 with <> chars, like "<filename>"
            if (!isSparta && (f.flags == 0x80) || isSparta && (f.flags & 0x10)) {  //deleted file
                return " " + " " + "[" + nFile + "] " + sLine; // '[filen.ame]' for erased DOS file
            }
            else if (isStdDos && (f.flags & 0x01)) {
                return " " + locked + "<" + nFile + "> " + sLine; // '<filen.ame>' indicates an open DOS file for DOS2, or a file stored above sector 720 for DOS2.5
            }
            else if (f.dosType > 5 && (f.flags & 0x10)) {
                return " " + locked + ":" + nFile + "  " + sLine; // MyDOS directory
            }
            else {
                return " " + locked + " " + nFile + "  " + sLine; // normal DOS file
            }
        }
        //(PVB END OF MOD)

        m.forEach(container => {
            container.files.forEach(file => draw_line(`#canvas${file.id}`, info(file), file.recovered, file.is_dir));
        });

        // if no containers (no opened file), then show supported file types and extensions 
        if (m.length == 0) {
            var s = `<div class='exts'>`;
            Object.keys(_exts).forEach(ext => s += ext[0] == '-' ?
                `<div><b></b><strong>${_exts[ext].name}</strong><div>` :
                `<div><b>${ext}</b>${_exts[ext].name}<div>`
            );
            s += `</div>`;
            _h('#tabs', s);
            reset_tools(); //(PVB ADD) disable tool bouttons as no file is displayed
        }
        else set_tool("H", true); //(PVB ADD) enable "H" boutton as a file is displayed
    }
  
    //(PVB ADD) render_extract(f, isDisk) function is for rendering extract menu only, called by render_file(f) function
    function render_extract(f, isDisk) {
        var str = `pattern='[0-9a-fA-F]{1,6}' placeholder='0...FFFF' title='Address in valid hex code 0...FFFF'`;
        var strdh = `pattern='[$0-9a-fA-F]{1,4}' title='Enter dec number, or hex number starting with $'`;
        var addmenu = `
    <div class='extract'><form id='hexmenu' onsubmit='return extract_disass(${isDisk ? f.atr.sector_size : ("0," + f.data.length)});'><fieldset>
        <legend><b>Extract data from ${isDisk ? "disk" : "file"} and disassemble Menu: </b></legend>
        <div style='display:flex;flex-direction:row;justify-content:space-between;align-items:flex-start;'>`;
        if (isDisk) {
            if (!f.extracted_disk) f.extracted_disk = _extracted_disk;
            addmenu += `<div>
            <label for='start_sect'>Start sector: </label>
            <input size='5' type='text' id='start_sect' name='start_sect' ${strdh} value='${f.extracted_disk.start_sect}'>
            <label for='end_sect'> =&gt to end sector: </label>
            <input size='5' type='text' id='end_sect' name='start_sect' ${strdh} value='${f.extracted_disk.end_sect}'>
                <span> <em>(use $ for hexa number)</em> [Valid values from 1 to $${hdx(f.atr.sector_count)} (${f.atr.sector_count})]</span><br />
            <label for='start_sect_off'>Offset Byte in start sector: </label>
            <input size='3' type='text' id='start_sect_off' name='start_sect_off' ${strdh} value='${f.extracted_disk.start_sect_off}'>
                <span> <em>(use $ for hexa number)</em> [Valid value from 0 to $${hdx(f.atr.sector_size - 1)} (${f.atr.sector_size - 1})]</span>
            </div>`;
        }
        else { //this is not a file with Sectors, but raw data 
            if (!f.extracted_file) {
                f.extracted_file = _extracted_file;
                f.extracted_file.end_offset = f.data.length-1; //to initialize value
            }
            addmenu += `<div>
            <label for='start_offset'>Start Offset at (hexa): $</label>
            <input size='6' type='text' id='start_offset' name='start_offset' ${str}
                value='${hdx(f.extracted_file.start_offset)}'><span> <em>(Min $0) </em></span><br />
            <label for='end_offset'>End Offset at (hexa): $</label>
            <input size='6' type='text' id='end_offset' name='end_offset' ${str} 
                value='${hdx(f.extracted_file.end_offset)}'><span> <em>(Max $${hex(f.data.length-1, 6)}) </em></Span><br />
            </div>`;
        }
        addmenu += `
            <div>
            <input class='buttonstyled' type='button' id='save_extract' value='Download extracted data' onclick='save_as_extract()' ${f.extract_launched ? '' : 'disabled'}>
            <br />
            <input class='buttonstyled' type='button' id='cancel_extract' value='CANCEL extracted data' onclick='extract_reset()' ${f.extract_launched ? '' : 'disabled'}>
            </div> 
        </div>   
        <div>
            <label for='start_add'>Disassembly start at (hexa): $</label>
            <input size='4' type='text' id='start_add' name='start_add' ${str}
                value='${isDisk ? hdx(f.extracted_disk.start_add) : hdx(f.extracted_file.start_add)}'>
                <span> [Valid value from $0 to max $FFF9]</Span>
        </div>
        <div style='display:flex;flex-direction: row;justify-content: space-between;align-items: center;'>
            <input class='buttonstyled' type='submit' value='EXTRACT & DISASSEMBLE'>
            <div id='extractinfo' class='extractinfo' style='color:#F00'></div>
        </div>
    </fieldset></form></div>`;
        return addmenu;
    }
    //(PVB END OF ADD)

    //(PVB ADD) showDisOption() function is for rendering disassembly option menu only, called by render_file(f) function
    function showDisOption() {//showDisOption() is called by render_file() for disassembly and dump display options
        // _dof: display option iniialization, used to redraw check buttons
        var _dof = [
            ["cShowAtasciiChar", _bShowAtasciiChar, "Show ATASCII code DUMP"],
            ["cShowDispChar", _bShowDispChar, "Show ANTIC internal display code DUMP"],
            ["cShowROMBank", _bShowROMBank, "ROM: Show addresses with Rom bank number [n00..FF] index"],
            ["cShowDisLinks", _bShowDisLinks, "DIS: Show disassembly destination address in hyperlinks"],
            ["cShowDisBRK", _bShowDisBRK, "DIS: Accept code disassembly with up to 2 BRK instructions"],
            ["cShowA5200Eq", _bShowA5200Equates,"DIS: Use Atari 5200 OS equates instead of 800/XL/XE equates"],
            ["cShowDisFlags", _bShowDisFlags, "DIS: Show disassembly code flags (webpage js info for dev.)"]
        ];
        var tmpstr = `<div class='doblock'>`;
        tmpstr += `<form id='disoptionform'><fieldset><legend><b>Dump & Disassembly options: </b></legend>`;
        //(PVB TODO) check to add "${_bShowAtasciiChar ? "disabled" : ""}" for disabling Option Buttons according to displayed cases
        //(like disable ROM bank display button if no rom is displayed...)
        tmpstr += '<div>'
        for (var i = 0; i < _dof.length; i++) {
            _checks[_dof[i][0]] = _dof[i][1];
            if (i != 1) tmpstr += `<div class="radio">`; //in order to put first and second button (char display) on the same line
            tmpstr += check_init(_dof[i][0], _dof[i][2]);
            if (i != 0) tmpstr += '</div>'; //in order to put first and second button on the same line
            //previously for one line/one button//tmpstr += '<div class="radio">' + check_init(_dof[i][0], _dof[i][2]) + '</div>';
        }
        tmpstr += '</div>';
        tmpstr += `</fieldset></form>`;
        tmpstr += `
            <div class='dobgrp'><input class='buttonstyled' type='button' value='Save listing as .txt' title='=Client text file, as displayed' onclick='save_disassembly(0)' />
            <input class='buttonstyled' type='button' value='Save listing as .html (without html style)' title='=simple HTML, no CSS, no Atari char' onclick='save_disassembly(1)' />
            <input class='buttonstyled' type='button' value='Save listing as .html (Atari font included)' title='=with CSS style, keeping Atari char if displayed' onclick='save_disassembly(2)' /></div>
            </div>`;
        tmpstr += `<div class='doradgrp'><fieldset><legend><b>Listing display font options: </b></legend><span class='radio'>`;
        tmpstr += `${radio_init('atarichlist', ['Normal Dump with Atari Font', 'Dump with monospace webfont', 'Display all with Atari Font'])}</span></fieldset><div>`;
        tmpstr += '</div>';

        _h("#disoption", tmpstr); //set the display option menu in the screen buffer
        toggle_disoption(true); //and force display of the display option menu

        //adjust the display of the different font listing 
        var preShow = _g("show"); //only for "pre #show"
        var stylesheet = document.styleSheets[0];
        var preData = [...stylesheet.cssRules].find(
            (r) => r.selectorText === "pre data",
        );
        if (_bShowAtariFont) { //all in Atari font
            preShow.style.cssText += "color: #005; background-color: #EEE; font-size: 12px; line-height: 14px; font-family: 'Atari'";

            preData.style.fontFamily = "'Atari'";
            preData.style.fontSize = "12px";
            preData.style.fontWeight = "normal";

        } //else thanks to refresh() "pre #show" has no specific type, CSS style of "pre" applied
        else if (_bShowWebChar ) { //"pre data" with standard Monospace web font for data and hex dump
            preShow.style.fontSize = "13px"; //adjust pre font
            preShow.style.lineHeight = "14px";

            preData.style.fontFamily = "'Noto Sans Mono', monospace";
            preData.style.fontSize = "12px";
            preData.style.fontWeight = "bolder";

        }
        else { //default "pre data" with Atari font for data and normal font for hex dump
            preShow.style.fontSize = "13px"; //adjust pre font
            preShow.style.lineHeight = "13px";

            preData.style.fontFamily = "'Atari'";
            preData.style.fontSize = "10px";
            preData.style.fontWeight = "normal";
        }
    }
    //(PVB END OF ADD)

    //(PVB MOD & ADD) add improvement for the addition of Extract, disassembly and ROM menus
    function render_file(f) { //render_file(f) is called by functions like show_rom(), show_atr ()...
        //(PVB COM) rendering = display the content at the right side of the HTML page (id #tabs DIV container)
        // on top : Class .info
        // on bottom : DIV #file

        var isCode = (_exts[f.ext] ? _exts[f.ext].is_code : false) || false;
        var isTxt = (_exts[f.ext] ? _exts[f.ext].is_txt : false) || false; //(PVB ADD) to force true or false, and not undefined
        var isImg = _exts[f.ext] ? _exts[f.ext].is_img : false;
        var isFnt = _exts[f.ext] ? _exts[f.ext].is_fontset : false; //(PVB ADD AND MOD) //previously // f.ext == 'fnt' //
        
        f.isSearchable = isImg || isFnt || false; //allow the "search picture and font" flag into file flag  

        var isNwExt = (f.original_ext && f.original_ext != f.ext) ? true : false;
        var pre = !isTxt && !isImg && !isFnt;
        
        var isRomdump = f.type == "isRomdump";
        var isDisk = f.type == "isDisk";

        f.isExtractable = pre && (f.type != "isArc"); //allow the "extract file data" flag into file flag

        //Special case to force and hexdump the file
        if (f.forceHexDump) {
            pre = true;
            isTxt = false;
            isImg= false;
            isFnt= false;
        }

        var controls = `<div class='radio' title='contextual display options (number of columns, colors...)'>`;
        var buttons = ''; //buttons string is for file saving
        var button2 = ''; //button2 string is when extension has changed
        var addmenu = ''; //(PVB ADD)
        var tmptxt = ''; //(PVB ADD)
        var hexsizetxt = "($" + hdx(f.data.length) + ") bytes";
        //(PVB ADD) compute and display checksum
        var chksum = '';
        if (isDisk) var c = calChkSum(f.atr.d, 16);
        else if (isRomdump) c = calChkSum(f.rom.romData, 16);
        else c = calChkSum(f.data, 0);
        chksum = " [chksum $" + hdx (c) + "] ";

        if (isTxt || isFnt) {
            controls += `
                ${f.ext == 'bas' ? check_init('indent', 'Indent') : ""}
                ${isFnt ? check_init('multicolor', 'Multicolor') : ""}
                ${radio_init('layout', ['38', '40', '80', 'Wide'])}`;
        }
        //(PVB MOD) Buttons are valid for text only, not img, not font 
        if (isTxt) {
            buttons += `<button type="button" title="=convert & save code listing into Client UTF text" onclick="save(2)">Save as UTF text</button>`;
            buttons += `<button type="button" title="=take a PNG screenshot of the code listing" onclick="save_as_png()">Save as PNG Image</button>`;
            buttons += `<button type="button" title="=save (modified) code listing into Atari LST text file" onclick="save(1)">Save as Atari LST</button>`;
        }
        if (isFnt || (isImg && is_palettable(f.ext))) { //previously //if (f.ext == 'fnt') || ...
            controls += `<div class='palette'>${palette(_palette)}</div>`;
        }
        //(PVB ADD) Rom Management Menu
        if (isRomdump) {
            if (f.rom.oldRomType === undefined) //First iteration - no orignal CART type saved
            {
                if (f.rom.romType === 0) {
                    tmptxt = `<strong>Info:</strong> ROM image file has no CARTridge identification header: <strong>` + f.rom.romName; 
                    tmptxt += `</strong><br />You can choose a relevant mapping type from the list (which displays the best possible matches) and download the new CART file.`;
                }
                else {
                    tmptxt = `<strong>Info: "` + f.rom.romName + `"</strong> type has been identified in the ROM image file CARTridge header.`;
                    tmptxt += `<br />No need to change its mapping type from the list, but you can try.`;
                }
            }
            else { //Second iteration - there is an original CART type saved
                if (f.rom.oldRomType > 0)
                    tmptxt = `<strong>Reminder:</strong> Original ROM image file CARTridge type was: <strong>"` + f.rom.oldRomName + `"</strong>`;
                else
                    tmptxt = `<strong>Reminder:</strong> ROM image file has no CARTridge header.<br />You can choose a relevant mapping type from the list, and download the new CART file.`;
            }
            addmenu = `
            <div class='rommap'>
                <div id='rominfoid' class='rominfoid'>${tmptxt}</div>
                <fieldset>
                <legend><b>ROM Memory Bank mapping type selection (75 first types):</b> <a href='https://github.com/atari800/atari800/blob/master/DOC/cart.txt' target='_blank'>(see information link here)</a>
                </legend>
                <div style='display:inline-block;overflow:auto;'>${rom_option(f)}</div>
                <div style='padding-top:4px;'><i>Please note that Emulationstation/ emulators may not support last rom types above 60 - so try it !</i></div>
                </fielset>
            </div>`;
            tmpromsize = f.data.length >> 10;
            hexsizetxt += " = " + tmpromsize + "KB ROM ";
        }
        //(PVB end of ADD)

        //(PVB ADD) ///WIP// render the Extract Menu if requested by clicking the tool E
        if (f.isExtractable) {
            set_tool("E", true);
            if (f.extract_menu_request) addmenu += render_extract(f, isDisk);
        } 
        else { 
            set_tool("E", false);
        }

        //(PVB ADD) ROM or CART saving buttons
        if (isRomdump) { //special buttons to save new CART header in a ".car" file...
            if (f.rom.isCart) //...if it is a CART 
                buttons += ` <button type='button' title='=without CART header' onclick='save_wo_header()'>Download raw ROM</button>`;
            buttons += ` <button type='button' title='=adding the CART header' onclick='save_as_cart()' ${((!f.rom.isCart && f.rom.romType) || (f.rom.isCart && f.rom.oldRomType)) ? '' : 'disabled'}>`;
            buttons += `Download new CART</button>`;
        }
        else { //Atari file, ATR or XFD saving buttons
            if (!isDisk) //no used to save original file as this is the disk image file that has been loaded
                buttons += `<button type='button' title='=extract it if from disk image, or re-save original file' onclick='save(0)'>Download original Atari file</button>`; 
            //(PVB ADD) Add a Save Buttons for saving XFD/ATX/PRO/DSK into ATR, and ATR/ATX/PRO/DSK into XFD
            //(PVB COM) We know that we have in memory a disk file always converted in ATR
            if (isDisk && f.ext !="atr") { 
                //so we can save it into ATR if it was an XFD for instance
                buttons += `<button type='button' title='=convert to ATR disk image (with ATR header)' onclick='save_as_dsk("ATR")'>Download ATR file</button>`; 
            }
            if (isDisk && f.ext !="xfd") {
                //so we can save it into XFD if we remove ATR 16-bytes header
                buttons += `<button type='button' title='=convert to XFD disk image (no ATR header)' onclick='save_as_dsk("XFD")'>Download XFD file</button>`; 
            }
        }
        //(PVB ADD) changed extension text and reset type button
        button2 = `<div  style='overflow:auto;padding-top:6px;'> `;
        //if (!isDisk && isNwExt) { //(exclude isDisk because no new type for a disk image file)
        if (isNwExt) {
            //if new ext requested from the list then add "save and reset extension" buttons
            button2 += `File extension type has been changed to '${f.ext}' from the Ext Type list...
                <div style='display:inline-block;float:right'>
                    <button type='button' title='download file with new extension' onclick='save_as_new()'>Download new file</button>
                    <button type='button' title='set new type for the file' onclick='set_new_ext()'>Set new type</button>
                    <button type='button' title='cancel type change' onclick='reset_type_button()'>Reset type</button>
                </div>
            </div>`;
        }
        else if (f.forced_ext) //if ext was forced by get_ext(), no need to add "save and reset extension" buttons
            button2 += `<em>INFO: File extension modified to '${f.ext == '???' ? 'DAT' : f.ext}' to display the closest file type</em></div>`;
        else button2 = '';
        //(PVB end of ADD)
        
        controls += `</div>`;

        _h("#tabs",
        `<div class='info'>
            <div style='overflow:auto;padding-bottom:4px;'><b>${f.name}</b>
                <div style='display:inline-block;float:right'>${buttons}</div>
            </div>
            <div> ${ext_option(f)} ${f.data.length} ${hexsizetxt} ${chksum}
                <div style='display:inline-block;float:right'>${controls}</div>
            </div>
        ${button2}
        </div>
        ${addmenu}
        <div id='search_controls'></div>
        <div id='file'>
            <div>
                ${pre ? `<pre id='disoption'></pre><pre id='show'></pre>` : ''}
                ${isImg || isFnt ? `<canvas id='show' title='Right click to save pic'></canvas>` : ''}
                ${isTxt ? `<div contenteditable='true' spellcheck='false' class='atari' id='atari_text'></div>` : ''}
            </div>
            <div id='image_controls'></div>
        </div>`
        );

        if (f.edit_img)
            refresh_image_controls(f);

        //(PVB ADD) ///WIP// render the Option Menu if requested by clicking the tool "P"
        if (pre) {
            set_tool("P", true);
            showDisOption(); //disassembly and dump display option is initialized, and displayed, according to flags as global variables.
        }
        else {
            set_tool("P", false);
        }
        //(PVB ADD) ///WIP// render the Search Menu if requested by clicking the tool "S"
        if (f.isSearchable) {
            set_tool("S", true);
            if (f.searchrequest) _h('#search_controls',
            `<fieldset><legend>Search Menu:</legend><div><button type='button' onclick='s_c(4)'>+$1000</button> <button type='button' onclick='s_c(3)'>+$100</button>
            <button type='button' onclick='s_c(2)'>+$10</button> <button type='button' onclick='s_c(1)'>+$1</button></div>
            <div><button type='button' onclick='s_c(-4)'>-$1000</button> <button type='button' onclick='s_c(-3)'>-$100</button>
            <button type='button' onclick='s_c(-2)'>-$10</button> <button type='button' onclick='s_c(-1)'>-$1</button></div>
            <button type='button' onclick='s_c(0)'>Reset Search</button><span> Search Offset in Datafile: $${hdx(_shown.offst)}<br /></fieldset>`);
        }
        else set_tool("S", false);
    }

    var _keyboard;
    function render_kb(vis) {
        var kb = _q(".keyboard");
        if (!_keyboard) {
            var s = `<div>`;
            for (var y = 0; y < 16; y++) {
                s += '<div>';
                for (var x = 0; x < 16; x++)
                    s += '<span title="$' + hex(y*16+x) + '">' + String.fromCharCode(x + y * 16 + 0xE000) + '</span>'; //(PVB ADD) the title = display the hexa code
                s += '</div>';
            }
            kb.innerHTML = s;
            kb.onclick = e => keyboard(e.target.innerText);
            _keyboard = kb;
        }

        //vis = vis && _q("#atari_text");
        kb.style.display = vis ? "block" : "none";
        keyboard();
    }

    function toggle_kb() {
        render_kb(_q(".keyboard").style.display != "block");
    }
    function set_tool(name, v) {
        set_class(_q("#" + name), "dimmed", !v);
    }
    //(PVB ADD) Reset tools function to disable / dim all tools
    function reset_tools() {
        var tl = ['H', 'P', 'E', 'S', 'M'];
        tl.forEach(t => _q("#" + t).classList.add("dimmed"));
    }

    //(PVB MOD) Add the P for Print & Display Option, E for Extract and S for Search menus, M for Modify
    function floater(evt) {
        var t = evt.target.innerText;
        if (t == String.fromCharCode(0xE000))
            toggle_kb();
        else if (t == "I")
            invert_selection();
        else if (t == "D")
            disassemble_selection();
        else if (t == "O")
            open();
        else if (!_shown) //if no file shown then do nothing for following buttons
            return;
        else if (t == "H")
            toggle_hex();
        //(PVB ADD) the 'P' menu for Display and Print Option Menu
        else if (t == "P") 
            toggle_disoption(false);
        //(PVB ADD) the 'E' menu for Extract Menu
        else if (t == "E") 
            toggle_extract();
        //(PVB ADD) the 'S' menu for Search Menu
        else if (t == "S")
            toggle_search();
        //(PVB ADD) the 'M' menu for Modify Menu
        else if (t == "M")
            modify_file();
        //(PVB end of ADD)
    }

    //(PVB ADD) (PVB TODO) modify_file() function called by Tool click
    function modify_file() {
        alert("not implemented yet!");
    }
    //(PVB ADD) function s_c() ///WIP// Search function development in progress
    function s_c(v) {
        if (_shown.dataOld) {
            var sact = v == 0 ? 0 : (Math.sign(v) * Math.pow(16, Math.abs(v)-1));
            console.log(v + "; " + sact);
            var datalen = _shown.dataOld.length;
            if (Math.abs(sact) >= datalen) return;
            if (sact == 0) {
                _shown.data = _shown.dataOld;
                _shown.offst = 0;
            } 
            var datatmp = new Uint8Array(datalen);
            _shown.offst += sact;
            if (_shown.offst >= datalen) _shown.offst -= datalen ;
            if (_shown.offst < 0) _shown.offst = datalen + sact;
            if (sact > 0) {
                datatmp.set(_shown.data.slice(sact, datalen), 0);
                datatmp.set(_shown.data.slice(0, sact), (datalen-sact));
            }
            else {
                datatmp.set(_shown.data.slice((datalen+sact), datalen), 0);
                datatmp.set(_shown.data.slice(0, (datalen+sact)), (-sact));
            }
            _shown.data = datatmp;
            refresh();
        }
    }

    //(PVB ADD) function get_hex(val) purpose is to convert the input text into the corresponding hex number
    function get_hex(val) {
        if (!val)
            val = 0;
        val = "0x" + val;
        return Number(val);
    }
    function get_hex_or_dec(val) {
        const reDec = /[^0-9]/g;
        const reHex = /[^0-9A-Fa-f]/g;
        if (!val)
            return 0;
        if (val.lastIndexOf("$") == -1) { //no $, then it's a decimal
            if(!reDec.test(val))
                return Number(val);
            else return -1; //invalid
        }
        else if (val.lastIndexOf("$") == 0) { //this is hexa, starting with $ (if more than one $ then return value si greater than 0)
            val = val.replace("$","0"); //replace the first $
            if (reHex.test(val)) //hexa check fault (not usefull since we can trust the regex filter from the input field)
                    return -1; //invalid
            val = "0x" + val; // convert value from hexa with 0x...
            return Number(val);
        }
        else return -1; //invalid
    }
    //(PVB end of ADD)

    //(PVB ADD) function extract_disass(sectSize, maxSize) is called by HTML event when clicking on "Extract & Disassemble" button
    //f.extract_launched // f.isExtractable // f.extract_menu_request
    function extract_disass(sectSize, maxSize) { 
        var ad = get_hex(_g("start_add").value);
        var txtArea = _g("extractinfo");
        var txt = "";
        if (ad < 0 || ad > 0xFFF9)
            txt += " ! Error: check Disassembly Start field (no code after $FFF9)!";
        if (sectSize) { //(PVB COM) for the "disk" extract menu
            //previously//var ss = document.getElementById("start_sect").valueAsNumber;
            var ss = get_hex_or_dec(_g("start_sect").value);
            var so = get_hex_or_dec(_g("start_sect_off").value);
            var es = get_hex_or_dec(_g("end_sect").value);
            if (ss <= 0 || so < 0 || es <= 0)
                txt += " >Error: wrong input for Start, End Sector or Offset value (use $ for hex)!";
            else {
                if (ss > es)
                    txt += " >Error: Start Sector greater than End Sector!";
                if (sectSize > 128 && ss < es && ss < 4 && so > 127)
                    txt += " >Error: wrong Offset value (max $7F (127) for 3 first sectors)!";
                if (ss < es && ss > 3 && so > (sectSize - 1))
                    txt += " >Error: Offset value greater than Sector Size!"; 
                if ((ss == es && ss < 4 && so > 125) || (ss == es && ss > 3 && so > (sectSize - 3)))
                    txt += " >Error: check Offset value (need at least 3 bytes for 1 sector disassembly)!";
            }
            if (txt !== "") {
                txtArea.innerText = txt;
                console.log("extract_disass() =>Wrong number ! start_add:" + ad + ", start_sect:" + ss + ", end_sect:" + es + ", start_sect_off:" + so);
                return false;
            }     
            _shown.extracted_disk = {start_sect: ss, start_sect_off: so, end_sect: es, start_add: ad };
        }
        else { //(PVB COM) for the "file" extract menu
            var so = get_hex(_g("start_offset").value);
            var eo = get_hex(_g("end_offset").value);
            if (so >= maxSize || eo >= maxSize || so > eo || so < 0 || eo < 0)
                txt += " ! Error: check Start and End Offset!";
            if (txt !== "") {
                txtArea.innerText = txt;
                console.log("extract_disass() =>Wrong number ! start_add:" + ad + ", start_offset:" + so + ", end_offset:" + eo);
                return false;
            }     
            _shown.extracted_file = {start_offset: so, end_offset: eo, start_add: ad };
        }
        if (_shown) {
            _shown.extract_launched = true;
            console.log("extract_disass() =>_shown:"); //(PVB CONSOLE HINT)
            console.log(_shown); //(PVB CONSOLE HINT)
        }
        refresh();
        return false; //false in order to keep focus on the form with input fields
    }
    //(PVB end of ADD)

    //(PVB ADD) extract_reset() function is called by HTML event when clicking on "ReShow Full Hex Dump"
    function extract_reset() {
        if (_shown.extract_launched) {
            _shown.extract_launched = false;
            delete _shown.extractedData;
            delete _shown.extracted_disk;
            delete _shown.extracted_file;
            refresh();
        }
        return;
    }
    //(PVB end of ADD)

    //(PVB ADD) apply_rommap(id) function is called by HTML event when changing the "ROM Memory Bank mapping type selection"
    function apply_rommap(id) {
        var selectRomType = _g("rommapid").value; //return the selected choice from the list like "Type_03"
        var f = get_file(id);
        var rf = f.rom;
        console.log("apply_rommap() =>Value:"); //(PVB CONSOLE HINT)
        // (PVB COM) note : not possible to change information text in the present apply_rommap() function. The following does not work:
        //txtArea = document.getElementById("rominfoid") and txtArea.innerText = 'REMINDER : Original CART type was ' + rf.romTypeTxt +` (` + rf.romName + `)`;
        //because refresh() is called to display the new selected type, cancelling info => So info text is updated in render_file().
        if (rf.oldRomType === undefined) { //on vient de faire une demande de changer le type
            rf.oldRomType = rf.romType; // sauvegarde de la valeur CART
            rf.oldRomName = rf.romTypeTxt + ": " + rf.romName; // sauvegarde du type + nom original
        }
        rf.romTypeTxt = selectRomType;
        rf.romType = Number(selectRomType.slice(5));
        if (!isNaN(rf.romType)) {//protection of convertion
            rf.romData[7] = rf.romType;
        }
        rf.romName = _romtypes[selectRomType].name;
        rf.romMachine = _romtypes[selectRomType].machine;
        rf.romMap = _romtypes[selectRomType].memmap;

        //in case of changing the rommap type, then update a5200eq and _bShowA5200Equates flags according to romMachine
        if (rf.romMachine == "5200") {
            rf.a5200eq = true;
            _bShowA5200Equates = 1;
        }
        else {
            if (rf.a5200eq) delete rf.a5200eq;
            _bShowA5200Equates = 0;
        }

        console.log(" ...oldRomType = " + rf.oldRomType); //(PVB CONSOLE HINT)
        console.log(" ...selectRomType = " + selectRomType); //(PVB CONSOLE HINT)
        /* this is a code for bank re-ordering.... used for Bounty Bob A5200 ROM
        if (rf.romType == 77) {
            var tmpData = new Uint8Array(rf.romData.length);
            for (var i=0; i < 16; i++)
                tmpData[i] = rf.romData[i];
            for (var i=0; i < 0x2000; i++)
                tmpData[i + 0x8010] = rf.romData[0x10 + i];
            for (var i=0; i < 0x8000; i++)
                tmpData[i + 0x10] = rf.romData[0x2010 + i];
            tmpData[7] = 7;
            rf.tmpData = tmpData;
        }*/
        ///WIP// RESET EXT if EXT has been changed!!
        ///WIP// reset_ext and reset_hexa
        reset_ext();
        reset_hexdump();
        refresh();
        return;
    }
    //(PVB end of ADD)
   
    function draggable(el, name) {
        //(PVB COM) name est par exemple "Donkey Kong.rom disassembly"; el = div.floated.disassembly
        var x0, y0;
        el.querySelector('.draggable').innerText = name;
        el.onmousedown = (e) => {
            e.preventDefault();
            x0 = e.clientX;
            y0 = e.clientY;
            document.onmouseup = () => {
                document.onmouseup = null;
                document.onmousemove = null;
            }
            document.onmousemove = (e) => {
                e.preventDefault();
                var x = x0 - e.clientX;
                var y = y0 - e.clientY;
                x0 = e.clientX;
                y0 = e.clientY;
                el.style.left = (el.offsetLeft - x) + "px";
                el.style.top = (el.offsetTop - y) + "px";
            }
        }
    }

</script>
<head>
    <style>
        /* remove comment to activate google "Noto Sans Mono" font */
        /*@import url('https://fonts.googleapis.com/css2?family=Noto+Sans+Mono&display=swap');*/
    </style>
</head>
<body>
    <div class="floater atari keyboard"></div>
    <div class="floater disassembly" hidden>
        <span class='close-icon' onclick='this.parentElement.hidden = true'></span>
        <div class='draggable'>
        </div>
        <pre id='disassembly'></pre>
    </div>
    <div class="floater atari tools" onclick='floater(event)' id="tools">
        <span title='ATASCII Keyboard'>&#xE000</span><br />
        <span title='Open File'>O</span><br />
        <span id="H" class='dimmed' title='Toggle Hex View (force Hex Dump)'>H</span><br />
        <span id="I" class='dimmed' title='Invert Char Selection'>I</span><br />
        <span id="D" class='dimmed' title='Disassemble Char Selection'>D</span><br />
        <span id="P" class='dimmed' title='Hide/Show Global Display & Print Options Menu'>P</span><br />
        <span id="E" class='dimmed' title='Show/Hide File Extract & Disassemble Menu'>E</span><br />
        <span id="S" class='dimmed' title='Show/Hide File Picture or Font Search Menu'>S</span><br />
        <span id="M" class='dimmed' title='Modify Hex Code of Current file'>M</span><br />
    </div>
    <header>
        <h2>Atari 8-bit Rom Image File Explorer</h2>
        <div style="font-family: 'Atari';font-size: small;color: #666;padding-bottom: 8px;">For Atari <a href="https://en.wikipedia.org/wiki/Atari_5200">5200</a> and Atari <a href="https://en.wikipedia.org/wiki/Atari_8-bit_family">400/800/XL/XE & XEGS</a></div>
    </header>
    <div style="display:flex;flex-direction:row">

        <nav style="min-width:352px; max-width:352px; margin-right:8px;" id="toc">
            <div id="menu_container"></div>
            <p style="text-align:center;color:#999;font-weight:300">
                <span class='open' onclick='_q("#fe").click()'>Open</span><br />
                Bug report, Support, Info & Manual ?<br />click here: <a href="https://github.com/pvbestinfoo/Atari_8-Bit_Rom_Image_File_Explorer">github.com/pvbestinfoo/Atari_8-Bit_Rom_Image_File_Explorer</a><br />
                <br /><i>Based upon ATR Image Explorer here:<br />
                <a href="https://github.com/rossumur/esp_8_bit">https://github.com/rossumur/esp_8_bit</a></i><br /><br />
                <i><b>Ctrl+O</b> opens File Dialog</i><br />
                <i><b>Ctrl+H</b> toggles Hex View</i><br />
                <i><b>Shift+Click</b> opens Keyboard in Editor</i><br />
                
            </p>
            <div style="font-size: xx-small;color: #99C;text-align: center;">NOVEMBER 2024 VERSION</div>
            <input type="file" id="fe" multiple style="display:none" aria-label="Drag files here">
        </nav>

        <main style="border:solid 1px #CCC">
            <div id="tabs"></div>
        </main>
    </div>
    <script>load()</script>
</body>
</html>