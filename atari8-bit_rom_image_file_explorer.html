<!DOCTYPE html>
<html lang="en">
<title>Atari 8-bit rom image file explorer</title>
<style>
    @font-face {
        font-family: 'Atari';
        src: url(data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAADLEAA0AAAAArcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABHREVGAAAyrAAAABYAAAAWABEBYk9TLzIAABeMAAAAUgAAAGBiXnzJY21hcAAAF+AAAAA2AAAARADy4XdjdnQgAAAYGAAAAAQAAAAEACICiGdhc3AAADKkAAAACAAAAAj//wADZ2x5ZgAAATAAABIHAABXivhCQvdoZWFkAAAW1AAAADMAAAA2FVu3/2hoZWEAABdwAAAAGgAAACQIfQNhaG10eAAAFwgAAABmAAADgGOAYCJsb2NhAAATWAAAA3kAAAN65cnP6G1heHAAABM4AAAAHwAAACABzACxbmFtZQAAGBwAABTzAAA+qbGNiBVwb3N0AAAtEAAABZIAAA5qQUfDxnja7VvniiTJEc7M6r5hGZZRaSiWYzmWumY4jgMJrmj0555DDyBz8t7bTXnvvffuZHflpVe4R9ArSE/QVaXMcBkZVT17cCAQ9PSaya7KyMiMiC9clQvuUef8k+EZ17gz96J73r34qftnG/fvJ+89tP3XU/ebkH5195r89TZ/ff/sIX946r7P3w9t3z42tLtH/Qv+8+yz4ZnxpY+Gp908++hciI174UP+ZS6NXfSxwfHLYZx+Ng7Gr8DrzqXrMY1fqcb5+tM8Tvfn669yQN9Hov9qR+vR/a/h++n6a2m9SOu9jq4zP6+H+W5O9Hwev6HwG/L4jU72A9ffZPh7sxm/xYzfasZvM+O3m/E7zPidZvwuM363Gb/HjN9b+A/5/N5X9gvj9+NYzv8D5Xzg+geFHp7/XUM/mvGHzPjDZvwRM/6oGX/MjD9uxp8w40+a8afM+NNm/Bkz/qwZf07pWx5/3lz/ghl/0Yy/ZMZfNuOvmPFXzfhrZvx1M/6G4e+b5vq3zPjbZvwdYy/fNde/Z+zn+2QPvN4Piv26rA8/TL96D9rVxIQgzvfd0PX7nU9f352zHqUfWQN06kdmzR8XHYPrPzHXf+rq+T9TOpuv/xyvz6yzvzDzfyn34x5+xTZA158x9//a3P+bcuZA/7eGn9+Z8e8NP38w43vm/vtm/EfDz5/M9T+b8V8Mf3811/9m1v+7uf4PlCGu5y6ce9zvd+1uP6RP3/Vt38QpSzGh4ux8VoY8mFCTZpB8ovLPTIWQAqi8JM3cZ20YukSt69O8NB0IJXIBiAAbnv1DnuWHfG+at2th9cblu9J9d33iscm/ReCAVst66W6lwa6Dzx4+MBf+bmCdiJNgJRllxfR5B9m3oO628Nm4CXaa/Ez6LY+cTyvjfWm5LdwDZ7GBXbtsAenalmmEOMY8Gz4x3zGLhWxplZDWmOAuvBV2hMjsMqWtuitEuIfuAD5ulz3Dp2+Hffn0vO/Z8X5DtfMYa1rbfr8rnxblRp+NK1Si/hFSilYLtIb6s3GHeibNCjDLq1OdXNKM4BYU26Ebap4URRFypuhFTl4o+kwyyyn9X66F6low8w5gT144cYrLfK3II6gdhLKDIPp57i6B6q4l2Xs4obyLKVsDqloWNBwqGAr8Ozk8J9RS1AuvdDSAhoaIOgh3VPx75/VJnhcdLzQmUj8vv2V9Z3zIc66yRZJNNdny2Xy9lr235yNS9MpufGU3tKuF7WWrY354b9ZGD475Fp5BFo2VBazlI9FQJzjS/KB2jPr2uM93dOqTMDBxHoB7/r/YlMxGDAP6hJ9DPrOMYNmGssFkXn2xGz0P7BgsECg0ZL+EI45AeKJ5iJmXxefuGbN3HWI2mi0CTGV31WxcNc3bZxrEMUwGRpFnNTtwfA85A+8WkIo1N7gRgghBdrnTw77yXZMjjIVlshqQtdx2d0jnetjVAL6o79CbJD3MCyb94kPlAwLHYpEKeVLSvS077mnH5OfgQzvPEhZjnJxfIF/eEUuucQ+7R3B3W4XIgsdo8cBJcBo88RtfcTwCFHHG43buMfTHhMpoh8N+R7oFO0l/h3RLt2HvOBFF/mcSV6C3ERxhC2ZTgors+8A7mqgAtWvXgo5MUTQDNsbenLTjgqQ4gARBs0KUUKLsGSwcMzSQDmpzX+lkj1oNOyS5Uyzi6b+FbxEdPy862pL2zaSneR7RmTEKwkwwa2sPvOfziDMGPV5iFcbZfaI2pl89nSTmiflaRhA6SW3lXe21i440lVsNVZCC+kB7uVXjsUfjaLMqFGyenXj+LJkJlGx2NeKcg0x7IgA78YQ2IJ+xuvs23C38onRIAwFvRoroZqe8gxZJRQv3QBa+Q0kDpYF9jJh0swwdqjO5yCiGeNGyxQ2JbD4P8amsd0DSVdxcam4E9xUXUxLo5Erk6I9zQFFrB5LpW5EIICnBFYe+pHNCpWXdaGUfpBczct0AfsyEGAqBLpNW3FYcFHQYrtIvihOxVFy+DukmNINQ0S1oORBaJsrb9E9DM+BkgyOalZACVx60p2i1p0jzsxdOd1JNIt3J9ir2B3RnF/l+tESuWpBm7sT/EUahLqH3XY1etSZBbsRc7gEr0LJHPPV0dpLd6NibI11cnaLmxlWB94opHDnjyrI8SX92xapmZ7zIWGlyq1B6AC1Cu0YBQUAQ0DpRcAsdznhAmQTsBTVHRy/4W6XCjUIUsYR2qX9jDLHSPTZs0rsVi8SddCKRgm8zu/xA2WisUFLimpb2gUkh6CxZEcmmYZOa3BIdOQZsSRsmiDSDIwnr+2+A5yIEydGih2ikASzPIFbHeiKnvLPdnqWEUO0ZtivpnnNc2q76sbzGXHsbRvh+L3vIJ4330RLmfo2EBQHJckJ1QrfY7oAfsbtWbG4mf8KRGGXvKk4AOlveF/KXT3eMKrsHvWwht29Jnpjhzi4KHCIqs7NYnnWZiyenuZtBnr72sxfWzyo010ie1Wlyeu4NdxO0D32JzIR0DTWXljSxaTlRsN2ydtq7nGgs5pcjZxpMK/5I7zplnmLLERlhUyZOOONcsULUUPFrcAqeUJ9TGV0J4PkqN2BdzdYAMGDuY71GDcifrAMhHsuP2qP5EeZ8VnvyHESDFvLudqE9eW7jMKKtz4B4GyR7T2epMdGTHrElolTnldwuz13nPUiuNS/ixbS+RAOl2kPxFit80K5Xxe1njGKISZi3Ns7Yfac86E5XWorvNCUfHeefFZRB/GIvg4G1VOh6lgJHkVV1SRaqvDTmBo6rL3kdqi4YTVW6ofJulQITXYqdgtQ3brLXpGwjWyxENyMl28XcKZNa2PqVtXUsLNC0hpOV4i8c1lW0D2icChQRyhbr8P0pm4R1kEPUNixvjlUEx7tDv8RogrEbmLCrA7dSldDVYIzFSpbc8HF4ShRLOSNwlRnX7TnLhpVLFABmFmLJ3pcRQOXrSgUFjpVdXY4vqUqf/tzEyO2yh2wz2WsQtw7+NKfWuBRFm5S7n1PER0jX8CwsDIGVBWcRQXm9nnMW8SmkwBntJrZH5vMGZlHIIcrcoyMZS0U7cA2q+Lwea9mCWZ4XIix3qmJ3o5xdOblA0Fjp/nPzcqiNnjWSJPxgL+cqL2dmbsGrFL2YtVJ4p5Si3pmnLL7amQc3XJ+CeK+99V5FA6e6bLASoSEilC6IBvnIzQx79gXjR3EQ2i/Bnc/Rn1F1rGgGYF0+uw7ryeLPKDjgaIi9E1FUK9/mOF8yF66v7OpqZdSx36K6QtJs4ZyLpctOJlxbk6DN1FKSqkLxb8a7LWqXzlQ+h33fVtXWrMFSb3W23wOdGK4RR1WPrqTfiu1p+244E2LDYz8IEu13VR46hJWT81yJvCi1oFb8rfhZCEjW+jSAxumksEeG80qXRfSg9EYk6JbKZellnemeAPVLSEwj/Jt7GwcA+Q1V7BtVYcf8GE4vKKo3Sq03Vz6BTqISFD3Itg0fW5nDfIyRuYn4xQH6ZGWtbV5rW3E/xlzZnxD0lzNu2s4Zd2P4w1lpk7Y7yu/038GVDL6ieKW6Z/vMS9WrYiqzUKSfgyPSGOdYvWAORS8aSZqbquum+0LpswHvvilxcK2dxKW0zRqFgIriVjotAfsok3PX3hGc6twF2w9qXKn0wrWrxbUlZdwNUdY6BlWTlNWofhahaa7YguA30FKbMWagfuyIiiQIZ3XJq+7YGCdSuwDzQJVCpbVVP4p6hqTh+fgr/b4oVuErayNLM1bH6s7dEaF1QbbXMgT0ezpFdtyJdeclWoW+57K3iX1Pv+hri0U/ACcyjTWc8HF95vqe+cTEuKkn3Nie8BGM0WiBuIKcbLCGwPd32EPGbFR/oI/sKTGapCwJGCIoWq98SedPrpMTS5aBuHAwGKlwxXUaPZclwI0JgpeCW2Ykeipfx4UNEBUpeg7UCiRKugmo+DGaryhxGbPvekrV9L6kIWhIqZOubX5Vj7aUweQghPWIaoJ5twFag6ueCvUehV6f1YZqcxCmbitruXR33A7RosQ6oo/Sa7pK1zdcHEeKlOAcJIo5UExEiepIf2moTuEO8koioSoixVtK8zyXcaTZEbA+tHE2bqjR5BHXl3O8KoUB9RDIpZzRqGpv8lQIw2D1mAjlj+X8bkAmd+WegMib+PcpvvFYpcLsZ0cwlP5egefbcNuFW4QHjrQ9fjtLU3nOqQ8AbdTpusVZ3mvRFxH5cevkomRiSbSYOpBprNpBaxR8SwX9FsNbXrl0MDNWBqldKBoXWf6+V11r7aGw52V6maANqp8ZJGQ+yO+rXoAQZGERBYE8FyDqJ0G20F1pAbzgPuIDq1ALvD2T9fgsR0a45ySrA2Vz+t6HC82l/pZodhHL8pc1QlxwfKw94y5LYYd6aryk9MNZjpMg5dGTzmRaOQGuoKI2YaG/nntHIzSZDykBh3cFqaPue7KK2r7RCu2deoiBPQAmRkrrMSKQTtLGRqK1175UHoFgDB8/SHGunCNVBwhFgGIxh3X/0hL8tfxwoIpdcpQFjrhwWD3U4Y5wyDRF4uJ90B+wtL2iiWWh+jw78S+d7LhVmkjGTiozEe5j7azG51v4DAtzx1IfiMOGDqBIR1qz3BhVnEYGy8l5401vGY0HV7MjV9P0+15rPBQkPXMMTz9VZd1r/HRly17cLYTX1qrP0V4KtuDsgi8E/prKMc9JHdyur7NqyDcW1eLNdfpcoofcj9QYllPYiP5qqjOgO9Vzh6v9XvUUIjMSHsBJkZnBApBZ4axAgXfisMvPAne7CqW4SFA8HzcWJ8fQgupGDvC4bVGMC/ZaaS3HuaRPh9KKha8ri7ioaQ74iNuKJUB3aGkFoysWsB4Bd1gmXeRE4gtVbqS6xgsfUu8cHuN7wmOlRbicSgt+QwHgSP3Ao56DcK9IgwAPZUGbrGbfrDz8vi84hFV3dIeI6+sxUEuhh9EEfA5gZB/jpZN5JM8sKfZahHGgvvOIwdjx/YOEhAJMcOI7H7B+7SvmykkEaITYM7i9Egd2VLTvqniwNIN1VBg96Z7NOotMRJYlAhgrLCNdQndCT3VCtY413vQgK1c9xSMybRWpTkVJag8Y7RP/jbHDlRip7RexEVlfkO8qOjfpqWykAxLSVKQB5hnkkRl/VEaD5gdch5YRYkrUMorl0arrYpehLWdlkcY7YfFAeR09AheP4UyJNdCyqvjFk5+dqvAl8pN3mt55hVuttmxHYS70v9fmHMl/s9RHVMEjesPncE2lAdsUk7NZvWhyCz1cfr45EzumyZj6jdfFgliQUc115VtKe52SB91bl57SdfuE6G11n1NkUljROJaV6McdKSIUm1cxtYnUbZZzXqFgqxBwKug3HuFBv5TBoYjCLvFCh6gT+bX16TEAqbhMBX4befpp2WnYUddeop8icx35VOWuZbZ6htXeVmJSqvoe3NE8YVceJ1rUoWLRWK/qBjVGtSWi31H7L1vtVRUXe9JTE8QsqT0A8aTxWaIWaB8YxCOfxg9lFa+M72GU4IzKt0d5wCgv70Z4mJ3ZCj15AInOdSeDqJtyO5MxBDEUOelpRballlke4m1rPY9WQ7APGNQ7Ph1nDchOJzU6jHL4cSfOQSLGiRKBHa2Q12gZqabnOPKRuKXOFlqRU+fxdah2p2uVUkVCpMbkKh7Lg7B/DLH9jHKa2WkHBIGlh7hVZ/f9auzCj8ErBPDs9tdiSbuX2alqWIgWBTrVb+yX0YvEgSJd7VdXY1mRSBUpiOWhA3p+EQs3PqqKu1gOPXshujXSo+5FsfDP6BZ6hTR2rKGlE0LaORYajWS7C928qbK/VkXE5SQmdP7uaIVeRSBdbysoZCghmhKPO9p/kEccBh2dF9kKHslzhityZa9r/C3IlZ6RjM8jLuHS/pG4pC1xydBCHbodqriEo8eN0J0EGR9UU+OXWClXrzIH/aDEWsHO2BK8C8MbJoxDs5n5Ka6J6gfByY4313R9quikqiWuBycP8rbcRDVZPrjFhbtdq/uaDl9EQkditR1qM8VrsianXpKeIqjMWvKXK3WigXvR5SEK1eNemS3lZlXP8er9KHV2p/feTu+9nd57O733dnrv7fTe2+m9t9N7b6f33k7vvZ3eezu993Z67+303tv/9r2307trp3fXTu+und5dO7279n/37trxt8/+CzHL0d0AeNpjYGRgYNzDEMHAyaDBwMrAxIAAegyMDIwAIkkBfwB42i3CbWwTZQAA4Pd9767X3l3vrnfttb1ee+3d9b4aN9OAArqRjMkEXdBpMhwyzMQxcUpCJpo5DDYbU1gkzkkcX8FJUTeykNVMRjDCIkwBMxkzsoVIsjCDGzGkEc2mWfSHeR4AgPu/LFgFKsB6UAPqQAPYDnaCVpAD+0A3OAT6QD8YAmfBKLgMJsA0mAFzoAgWIYIUFKAMNejCLFwFK+B6WAPrYAPcDnfCVpiD+2A3PAT7YD8cgmfhKLwMJ+A0nIFzsAgXEUIUEpCMNLQMPYoq0ZPoWfQ82oqaUQtqQ+2oC/WgI+gEOoW+ROfQt+gqmkQ30W10F/2B/sFwTMUsrAKrx/ZgPVgfVsDGsBvYEm7gq/FqvAnfhbfj3fhxfBC/jt/GiwRDaMSDRDlRQzQSLUQHcYI4T9wk/vbI/yn1POZp8Rz1XCEhyZEOuYZ8lewkPyZPkgXyOrng5b0PeTd7d3uPeS94f/FRvlJfpW+zL+c76Dvnm6EApVFrqUbqXeo4NUxdo+ZoREfpMrqabqY76Tw9Sv/K+BiHKWOeYpqZ/cwgc4WZZ5b8cX+p/2l/vb/Nf9h/xj/un2dp1mKr2C3sW2wPW2DH2Fl2kYtwy7karonr5D7lznCT3H1e4R/hn+Pf5Pfyn/Aj/AS/GAgH0oHywKZAS+Bo4GLgVuCe4BWigiusENYKtcI7Qq8wKEwKRRGIrJgR14m14g6xRxwWp8SloBHMBjcEXwl+FvwpRIeqQy+G2kMnQz+H/pI4SZdWSi9IXVK/dCPsCZeEa8N7wvnwVMQTMSKVkdci70UKkVtRIloSrYvmol9Ev4vOyl7ZkR+Xt8ndcr88LhdjUmxlbGvs/dhw7MfYvMIpy5QtSrtySrmk3I2T8ZJ4RbwpfiA+FL8Wv59QEqsTLyU6Ep8nxhK/q5Raoj6h7lA/UAvquPpnUk4+nNyUzCVPJyeTCyk1tTy1MfVG6mBqIHUhdU+LalXabm2/lte+0X7TMT2oa3qpvkF/Xe/Sh/QpfcGQjTKjzthrDBjnjSljKS2kV6Tr023pY+nR9IyJm4qZNavNRvNt8yNzxPzevGNhVsoqtxqsDitvjVhXrTs2abt2lb3NbrV77QH7B3vaXnAk5wFnnfOy0+Hkna+dKafoBty0u8bd6O5yP3RPu5fc2QzMSJls5plMa6Y381Xm4r8Nk/eAAAAAeNpjYGRgYABilfjLq+L5bb4yzWdhAIHrl2+lgelrM+cwMPxvYGFgbgByOcCSDABd9gwhAHja3ZJdDoAgDINb5SSetEd3kx9dshj1RWOXMVjIRwoUYEFTsaQgKz6K6it6CmnYLhDQ8xjkwKnzyj7nExykGUdNLZv8pK3ureDqZffR01X3nUAhU951brybH+grr3fj52oFzDWB5QAAeNpjYGRgYKn+HwMkGUAASDIyoAIWADjHAekAAHjaY2BhYWCcwMDKwMA0k+kMAwNDP4RmfM1gzMjJARRg4GSAAUYGJODs4afAcICB98F/lur/MQwMLNUMSxIYGPbf/w40q4G5AahEgYERAIuiD/gAAHjaY2BgYGJgYGAGYhEgyQimWRgMgDQHEILkeBnqHvz//x/MUnjAAGR+/f9YIQmsFgwACyoMRAAAACICiHjaxVrbjiPHeW6tZMUqywICGI53kYvCADF2gB7O7kq25AUcmMPh7BDikCOSs+u9EprNItnePrkPM6LfJ3mLBLnJIyQPkFfIVe7yn6oPPOyM5ATSajjF6qr//H//X9XjOM6TD/7R+cCh/x59Cx88/sD5DL7x+JHzN48iGX/ovHhUyPgj5+8e/bOMf+J8+OhfZPyx88tH/ybjnzqfPvpPGX/SGP/M+eLRf8n4U+dXH/5Sxj//2+cfdmT8mfPkF98Cxw8++gSY/esvNjL+wPn7x1/K+JHz2eOpjD90Fo89GX/kdB7/u4x/4nz8+L9l/LHjPv4fGf/U+dWTf5DxJ43xz5z1k9/L+FPn2ZN/kvHPj+ZP/kPGnzlf/P7LcVmEQWxy3UvSTRas1oV+6h/rF8+ef+XqaWFujT5L8jsThvrpuijS/OXpqb9OfH+zTuZxMu/4SXSs40QnxdpktNd8l2Ymz81CJ5kOojQMzEKpXma8AubmG31rMvkovNDEOJuaJA2Njrx4wx8b42W59lZJR0+CNOWNa89/Z2A6TPJCF4kGljoK8iLXyVIXQWQ6oEYYGl8YeZm/Dm5pwRJkWZZFmRm9MrHJvCJI4ryjlZoYPwlCfeflukShga6fxCAesbgeveroQeStzJW3Cvx3MJe8I8bwRHvxQmdgoww2ujDKg7/gAAxEIpcprUjKIi0L2HCll0EItr5bB/5aXydF5vkGicWWJWwKYmA7ff1KVqFcSzt9kcTFRZKtTJMuLIiShcliUDIuUIsgXunrTbFOYv2i8yUuQIHzZFnceWiAsDR6nYQLXBcAAXBukawMetDVd1lQFCAR2C8yOzHwhx45/zKZj5L5MUhFoaKBkwf/r5DileefoZG6QdbpY0SdAY9u4WXBxKzK0MuaJPRL3V7jalkFTz5/dvK7E6R/YMnzzjP75Ft6crKHg43aVVCsS4rX0+bjU0vhhCmgifNDkf7XJImr7kACED032S04FBnpkRcZfUScvwIZjjpKzdZBzg+n1mEwEQa+iTE8yxhcTf6cDoZ6nIKnaPGQF7j6NUQjxLZ+3nneYWKyF8n4SRpgbpgwuXMpiGDSC/NEe7deEHpzSEIS09MX3W+0V7xUqBDok/tZkBZ5Jw/CDkTg6fhiqJQ6+eH/KZL/uj/SF+PRTA8Hvf5o2m+Kr0/0i9/qCzPPSg/A4sWzZ1/+VQzV9aTfvTob9sEskAUJ6E3AAV927KifgoLHGq0PeZcDuEBcFWCcJAsXd8HCqAW4PUzSCAAMqfgAPN48QWCBcMBM1GmW/AmwKHeJRJmmCWLKWp76CIigqTJLACfGMM/3FiYKfPIM4PKqBPCCrxA/URkHRWBy9hoQBOq3IAd4apkZAgSVoBbLDGIKxHyHyckYwrgQeRtwvM7XoNSCfR8hEQIXnXpZAbiYr4OUA5UAPaeABPtcDBEmkjuGkioamTJIA4RLAsG8KBcBDgCTgmXAnBRwBE2yYF4ixKHA4QZxKUwAMBifNmTsOCkAqEKCb5iMchPeGsBpEEIRMxeE9cOSsAsLBWRDcMtGR6XhuQ9IBOLMIVNCFMREc7NY4GhLDBDsFMoCseOgB3oVSop9wdZrr6BHmaSuisHCeSUuVY35riQktFgIrV0/z121Tu6wbpC0SAQEzkxovDrFkSMX1WKTGowOsTobIzN/LoPMUPhRcbOegDkP/GlxopH/iwSkRmZemoYbBWvJgIlfEhVfKjTXj6KSPSG4CbKmAhAW5/2LwWgwG4xHU3XUwqsjkGGJdVpKdG4oQ7j2VVqyg+u+Q12CH0z2ND/eJzsa0IedWYgNQvYO3ZdDUvlrNEdA0a04MrDSlRkUVmLoQiAE4GDBL/aEqEz5B6oc7YJyUwe0Ers8T40vQc3MtbcsGI6VX9WGHAiTY0AXpD6G6SD2Qott2/bxuWdB1AMztaEfMj9NYkMxlKtm9G7bT1f2Q55XNvv28NxKmwgwh7qlBSVVkbjwNDQFfHEV5kc5BxAqSpzQJycWLKi7Q4RJoGbANMXrUhSqhOYZtW0CFxn6ay+mjgHiN/I40mAaYdJGYNsYKLuKzZ028W2QJTHaGJXtltDrZLsq5sEqxhwzyMbgCJJ6BfgY4bgw/joOfC9U2PKAF4E9J1wKVBJSDfuyyuLirpZMwP66P7kaTKeQCPrXujcenUtSXJsMmlMqZhCfQNeAcsAdG16XQRvrBsDxyrhWaGGdzAtIYrCC8rBmV5Zt8aZNJdZ8BN2NSysBeA0RJNgTGN64LejjGpJjv9JEaci76is1CnmTrarZQkRgYbMGWSZYGdBlYK1FQJ31S6WeH+uRCRjBdlwZJ5mNmAA8H8A+QNsSIqQOHhcSWleRAxu2gxqS2xY1KRlAy4RLcMqL4/fv3GtQS82Wju9TL9ytgmE8QAd0iMIQAmdy5YQW4dboGisAjgHhuKY38I4wHmCPa5kFtoUWeyL6FLDnxIMCCnlhviss2q1LOD+dAJQvqJlbwwBzIsnQmCRBCoKmWYDdTARCQmbUyyNTwKiAniIw4SInNXEfMgASc7AndGKM5K3yneTG7pH6CygfAFjfBuauRiuI1gy88zmERrLjlMM+gW30pIXTCnGaywWIk+O5E6wHhwR7gklbCSiZZyXxkwzqeYoBC1m2jaJSVGAFeF+gOcaWJcXjbIXcYMaIDIISY4lAkMbTL59qZRUqjRXzi2PqCGIRW7TdA+BScjXjWmNtKw+xk4MMlu7Bnl3BuVGCKW7iRQLnUqTlLfBsGVAZ3ahts8PS73yTUjrDATtO7iD2V0asJPAH62o51D6ZOYRbQmecJtw9bLtH1e4B2/yGbbOFbxUcAakanNx9JchVUZmTJZopC36AJgkct9tSMAjSJjZhq7pu92DNvNSHei/10N5LH+i9VN17bVeZGVaZURdLS/tUNzeAmEi8hGBAlW6TADr6ZbMgW9Sx6Iy9q0JpIN+xlRtMe8Pu4Ko/UbPLPp/HpuOL2ZvupK8HU309Gb8enPfP4aQ6he9Hrn4zmF2Ob2YaVky6o9lbOCDo7uit/nowOndV/49w0ppO9XiiB1fXw0H/3NWDUW94cz4YvdJnsG80xhPf1WAGRGdj2iqkBn3Yd6FAlt4lfO2eDYaD2VtXXwxmI6R5AUS7+ro7mQ16N8PuRF/fTK7HcHDsjs6B7GgwupgAl/5VfzRTIFVvfP12Mnh1OXNh0wwmXT2bdM/7V93J1y5KOAaVJ5qWdEBKoKH7r/togcvucKjhqapo6Mvx8BxWn/VB+i6cJFkckJ7s5+rz7lX3VX9a08VlrIGqLYAbXvVH/Ul36Orpdb83wAGYbjDp92ZkKzA3KD8kCaGnmPa/uYEJWKeEBfjgsk8sQOYu/N/D0NCk8Qg0RDqz8WRWifJmMO27ujsZTEEEdTEZg7joQtiBTr8BE6K/RiIvugXndgMCVuFuxQqe97tDIDhFMXbWdg5fHjhjp3QKJ3QCJ3aMkzva6TmJkzobJ4O5lbOGp9p56vjOMfx+4TxznjtfOS6Mp/DEOLfwo50z2JM7dzAO4R+ux30F0Mmdl84p/PNhJoFPHyjjaA788LMDM4kTEXWc0fBTwAoD/Gu+xvkOaGUkYQ6fC1qHKwLYm5L8OKvgX4/WeSQdrpsDR01yZlujAlaF8C2u1qbwOyF6qFUEz2NaWY82RDsjS3lgnwQ00M4E+Ke0u+a4hue+84644eqQbFQQ34Q+18IloPmcdFrSE9TKEGX0Rkjy+FsaoRRo1QA0qiksxS5L8mtJttAgpyH/ZmSXANbEsBrpo8UmRD2BefTdHaxBSmVlaZbXp11svVqLa2fkvCJKA7IScrqi3wFpz+sSGbHGvEeTTZF+JnGUCUdX5nKg8ZdqhiOotnIJo5pGQvqm9MkcrsgKAdkuJ73WJNOanmOUZeQhU0kW72jJnAKKkIRi/jVJ3qRl7bXcWX1BtAr6nZFlDsnLFCKYXRDnWDwZi1dLskUMNFD2Dcmb0KoXYPsvKwrWwjlFUkGy2QgIgYqhuMSIWlT0ApGAMxclR0ltDrqkYUarCrHRXHLCPAAH/gARXGf+JeX8iD6PxVY1qmjRyZPPVSXjFXnqrIqkLjzJQPN+hVFnokeXshrlxahegc4hfT8khQZ80u+l41J+N2nxns9B6hPnd/Bj5f9+VJ6D/M929nzb2HPyQB22sXZFlNawr8bX04O7T3dkOGnJcFHF4ffF9B+rkriAaXdiA7Z6TrF8KxlqNdJgAY/iWDtHDZ2/EjscAU3Exxlle97aOd3JsEBQPiBMiSv0LCnjuZ7Z/JwCWg7h95jQLG5RHrYooH1eCzYGkh8YOc9JtlqyNl8rjU8eCKq6YagK3RFVi0SB1LKQUANHt/ATUMzNpRLW1vRI1q7zDY0L8ImqPMT+yYFrRvWwoBqTE62OYOAp6HwBOir6d/Kj/FMN+19D9I9IpzH8npH9BxC5ODuFz0PW10AHo/i3tNeApTLwtCedBUb3M8DlH09DBZpNQP4uYOcZ6NSXaOFakIi/646Dn9wfj5iR7MFj6UFM1Qvk0rkwXhUSOeh3rDcYQ5gHij5vJRZTyj/mxLL40vFg9CVVx8LosKykwm4wcf4kfVFOEW2lKKlLSKo+Zb211686RPapgm9L6ZyafRjWHI+kjcgGdc6EUplK6bz4KeNPRBkf0KwRyew+lpBlvxV7cE4tSaa6Q1BkGyOdQCY4xdZ8V1XOZh/S7BewE9tIxmtCbvbUopX3USVJ3bmgdB7ZIZa4X1MuNxG17tDzBkJy/FxQXnE3gUjT7Ep2sbEpM9uGJS4bnWBOfexCUMyt+qSAurumTkp0ZJ8gBs2pv7K82MKhdM+2J+cOo9k/bRqRHZO23FGFje6bV0YkZ0gW5H6aLaEamrliWZ86sLrvsicKrg0BoW4d6dbTufS+nnRehj65poSVRVCSOX1bVHPvtwZb7FROC7V2TaRn+XZ7yXb8LsQanvSRvCvbqroK5jmG8z3Wrc8a8wfZpLZ0O4ZsbO/bn1NfsKaotOeN2rZWErZwRl41FBW7Vdzq2DypFjCT0l7GjnasNyMDaf+ZkCMjv1n0q09u2znB6zzJz+1+Yn/9X8BOtrXVzCNUxOhXQreOQOynyoYs/tYZunn+KPbYPWl0NwGN93uA0eIcqtEFVNkR/MzgZ0y1VkG/dbi/OhI7LKvzdPsUndOZxVq/ee7b9WUzg/fddyjqj0PR4SnsO36w3W0E+sIzE7yJaPyuyr5cKhVit42OoIHdqoUZ9kxX0pnftDR0BRECyeB2/9XMibaX6/rHXjl6UKd8yA82lppZnlNG+FtI3dQcvy8pyur4UdK1ts8NuUhcZwz7xco+ltUBSRDu9G33xY/fumexvR5H0/u6fq75Ka0wDRzKqc/Zj733xZ/eE39Wz6ud2vcwPd9fbSLpc+q7pUWjUiEFV/aGlGf8xKUuJRN/zqUTKkhTu/eE+uR2Z1Hf3dkeJpFzBq+u8XW55aFdSzfXqHujwK009KlixY07BsbfiOxSYxqvtt3kNga+LzKs3RXJe0dVOqaqmdEuG8fWs12y25o4PcSLOWkaV3XMVNqYao4r9Ur6x6iaLyjO19Sn+mQpVd3ycC4m8llXuFRkSRpes/dluzHezq7DdurIWaUP6HMFtWBKZ7Mxncl+TdmB4/OtSnFNsvDNaX0yY/xkeY14jnW3N7xuq9O25w3ujldy2m5buq013jMUUok5FhR17xaxtmP2sN41p7I659tOdyN9CdN05a6tlrDu9trd8IYy8lDX1zyH5NX9yqFemuvd7tP6RiE/qK3aqy1jhD2xbUfIUvA3oQ6Us4xjayFnKb6zfknx8pwq8oi6jWYPdn9WxhLZbYwJJOcD4ce9bSkYsg95XKnQeg/mMIf7kDoX77VPau1TBsuFvlpKprwgzX84z4dH6LZs26eO/6/zhXvPCcPQuXzdyBBVoRBnZvPMybcIt1UF2a603B0H0lXV5/T9/V3dx+dCsT6XbXdsC5K1GZ+29ymEzwn5jqOKMfk7OQk0e7s19Wy440S68kXjZm4tM7ZOoL1tZNY2SMWiKelu72YisSTXjH3UI6r2PFfIPUVA8biQdyqB2CpuacBSzCU++U6s2ZMfPn0nYtk2n/b5l3v5QDrrW1p5t7e3KqWf5dz5XFAjeUCm/JA8KUV2u+dwP62qfrp5ugjl/aZ938mxx28Stt/BpO+pgO2at20Tn7zD5/O0QliuZff1ou2TCtPg3G93zXF1y5JWb2d3e26OxqgRIdbGcXUvz510Wt0nxAc6DOtpe8b8gqxq7wjiLWu3ffuwDrx9ytWtfm0/3cP10N7JcQ1u3z1sv3flzI1ojak6vQXxzaWPyaRnt+8tg8ZpFPHxvmh3JeYQ6dJGdeY32DFVZcb9VSvCd7s/prfPHurBdm6i8GFLZ61q0rx7uC971N7s4bj5TStu3t+/7XZHLNW+zsl98CkIK2tEUVDHxKEqy/kQyB3H5oG3FM1OsObUjMLDZ9f77sEO1Uv9ve+91P/5vZf+nvdeau+9131nmVl1lhlB5NpTy/ve1c3l7y+iSvJSkMF66Zb+OoPv6JcHT8jbvc5272zvXVVlG67v9lYOT189ZwhSD0B+1AKlvqS3YPX7sSnd8s+cN7BuQs9wn6b3TWPAlQHd753LO9WpPD+iqHtD57hLWHdDtJjGBD6R9lt5g6DpO377mqx4TjnRd/4o77SmRHUMY02SXtM7uz6t07QDtbghjfgvTc6E3wh22Xd8VyQLSzqD+ZprW6oBcWTJlNilBzrw0y7QHhA9lN8lS+F4VMl5IZJ2yUZIeUZvGG/I0hOavYHf17CO3zh2SWeWdkQ6XMBz1qVPEiBnJbbq0VvMt7TiFcg1IymuKfZ4pUsaoj7ntB+5fk2zLNlYvDyhnsVS6YgtWQ78G4nXQg9jAPUf0rse3qv2yKHJ00PiOiEv9MX2XXkn2bQO276OP5TvnN5fdknv6V55LbWmD9TeGLAcXpEWfbLHUP7+AO8fekRpWMUQ7pzQ/KwRVxzd7Plhw4Y9uZvoO98A175ETpfedLe14DxA+Wst2M5d+exVqKEbPh6JD3uVR8cUS7tWeUMZ16dVXfLHVKygKJLGYl2bhczDZvqNROG4kqxtX5stdt1DEIJpWd6q5cFzeks9FAmnlTXup9v5IX958L9prALcAHjaXdVTFGaHFYbh/e2xbdvY//H4/AdjeyasU6RM3aa2baW2mdq2bdtK25W8V90331r75rl8ze3Gu2GuXfe/kf3f6fobv24jbKSNstE2xsbaOBtvE2yiTbLJNsWm2jSbbjNsps2y2TbH5to8m28LbKEtssW2xJbaMltuK2ylrbLVtsbW2jpbbxtso22yzbbFtlrYwBJLLbPcCiutsm223XbYTttlu22P1Ta0xlrrrLe9ts/22wE7aIfssB2xo3bMjtsJO2mn7LSdsbN2zs7bBbtol9ildpldblfYlXKN0EiN0miN0ViN03hN0ERN0mRN0VRN03TN0EzN0mzN0VzN03wt0EIt0mIt0VIt03Kt0Eqt0mqt0Vqt03pt0EZt0mZt0VaFBkqUKlOuQqUqbdN27dBO7dJu7VGtoRq16tRrr/Zpvw7ooA7psI7oqI7puE7opE7ptM7orM7pvC7ooi7RpbpMl+sKXamb6ea6hW6pW+nWuo2u0m11O91ed9DVuqPupDvrLrqr7qZrdHfdQ/fUvXRv3Uf31f10f12rB+iBepAerIfooXqYHq5H6JF6lB6tx+ixepweryfoiXqSnqyn6Kl6mp6uZ+iZepaerefouXqenq8X6IV6ka7Ti/USvVQv08v1Cr1Sr9Kr9Rq9Vq/T6/UGvVFv0pv1Fr1Vb9Pb9Q69U+/S9Xq33qP36n16vz6gD+pD+rA+oo/qY/q4PqFP6lP6tD6jz+pz+ry+oC/qS/qyvqKv6mv6ur6hb+pb+ra+o+/qe/q+fqAf6kf6sX6in+pn+rl+oV/qV/q1fqPf6nf6vf6gP+pP+rP+or/qb/q7/qF/6l/6t27Qf9xc7j7CR/ooH+1jfKyP8/E+wSf6JJ/sU3yqT/PpPsNn+iyf7XN8rs/z+b7AF/oiX+xLfKkv8+W+wlf6Kl/ta3ytr/P1vsE3+ibf7Ft8q4cPPPHUM8+98NIr3+bbfYfv9F2+2/d47UNvvPXOe9/r+3y/H/CDfsgP+xE/6sf8uJ/wk37KT/sZP+vn/Lxf8Itjrrn6qm7r1q1ssAM2YVM2Y3O2YEu2Ymt2yDZsy3Zsf9MGfuAHfuAHfuAHfuAHfuAHfuAHfuAHfuAP8Af4A/wB/gB/gD/AH+AP8Af4A/wB/gB/gD/AH+An+Al+gp/gJ/gJfoKf4Cf4CX6Cn+An+Al+gp/gp/gpfoqf4qf4KX6Kn+Kn+Cl+ip/ip/gpfoqf4mf4GX6Gn+Fn+Bl+hp/hZ/gZfoaf4Wf4GX6Gn+Hn+Dl+jp/j5/g5fo6f4+f4OX6On+Pn+Dl+jp/jF/gFfoFf4Bf4BX6BX+AX+AV+gV/gF/gFfoFf4Jf4JX6JX+KX+CV+iV/il/glfolf4pf4JX6JX+JX+BV+hV/hV/gVfoVf4Vf4FX6FX+FX+BV+hV/h1/g1fo1f49f4NX6NX+PX+DV+jV/j1/g1fo1f4w/xh/hD/CH+EH+IP8Qf4g/xh/hD/CH+EH+IP8Qf4jf4DX6D3+A3+A1+g9/gN/gNfoPf4Df4DX6D3+C3+C1+i9/it/gtfovf4rf4LX6L3+K3+C1+i9/id/gdfoff4Xf4HX6H3+F3+B1+h9/hd/gdfoff4ff4PX6P3+P3+D1+j9/j9/g9fo/f4/f4PX6P39/kB90Luhd0L+he0L2ge0H3gu4F3Qu6F3Qv6F7QvaB7QfeC7gXdC7oXdC/oXtC9oHtB94LuBd0Luhd0L+he0L2ge0H3gu4F3Qu6F3Qv6F7QvaB7QfeC7gXdC7oXdC/oXtC9oHtB94LuBd0Luhd0L+he0L2ge0H3gu4F3Qu6F3Qv6F7QvaB7QfeC3gW9C3oX9C7oXdC7oHdB74LeBb0Lehf0Luhd0Lugd0Hvgt4FvQt6F/Qu6F3Qu6B3Qe+C3gW9i6L5L8nBqngAAAAAAAH//wACAAEAAAAMAAAAAAAAAAIAAQABAWEAAQAA) format('woff');
        font-weight: normal;
        font-style: normal;
    }

    body {
        background-color: #F8F8F8;
        font-family: "Open Sans", "Helvetica Neue", Helvetica;
        padding: 20px;
        display: flex;
        flex-direction: column;
    }

    canvas {
        border: none;
        padding: 0px;
        margin: 0px;
        transform-origin: 0px 2px;
    }

    nav {
        border: solid 1px #CCC;
        background: #CCF;
    }

    ul {
        list-style-type: none;
        border: none;
        margin: 0px;
        padding: 0px;
    }

    li {
        font-size: x-small;
    }

    li:hover {
        background-color: yellow;
        filter: brightness(200%);
    }

    li .recovered {
        filter: brightness(75%);
    }

    li .isdir {
        filter: brightness(125%);
    }

    h1, h2, h3, h4, h5, h6 {
        font-weight: 300;
    }

    h2 {
        font-size: 30px;
    }

    #gl {
        border: solid 1px #C00;
    }

    canvas {
        image-rendering: -moz-crisp-edges;          /* FF 6.0+                       */
        image-rendering: -webkit-optimize-contrast; /* Safari                        */
        image-rendering: -o-crisp-edges;            /* OS X & Windows Opera (12.02+) */
        image-rendering: pixelated;                 /* Awesome future-browsers       */
        image-rendering: crisp-edges;
        -ms-interpolation-mode: nearest-neighbor;   /* IE                            */
    }

    td {
        border: solid 8px #F8F8F8;
        padding: 16px;
        margin: 16px;
        background: #23A;
        color: #FFF;
        font-weight: 500;
    }

    .sw {
        background: #A32;
    }

    .hw {
        background: #3A2;
    }

    .over {
        border: 2px dashed #F00;
    }

    .info {
        display: flex;
        flex-direction: column;
        min-height: 32px;
        padding: 8px;
        border-bottom: 1px solid #CCC;
        font-size: small;
        margin-bottom: 8px;
    }
    /*(PVB ADD) NEW ADDED STYLES FOR ROM MANAGEMENT MENU*************/
    .rommap {
        padding: 8px;
        border-bottom: 1px solid #CCC;
        font-size: 12px;
    }
    .rominfoid {
        padding: 5px 5px 5px 5px;
        border: 1px solid green;
        color: green;
        font-size: 11px;
        line-height: 1.1em;
        margin-bottom: 8px;
    }
    .extract {
        overflow: auto;
        font-size: 11px;
        padding: 10px;
        border-bottom: 1px solid #CCC;
    }
    #extractinfo {
        font-size: 12px;
        font-weight: bold;
        padding-left: 12px;
    }
    /*(PVB ADD) STYLE FOR THE DISASSEMBLY EXTRACT BUTTON*************/
    .btnstyle {
        border-color: #AAC;
        padding: 3px;
        border-width: 1px;
        margin-inline: 2px;
        /*height: auto;
        border-radius: 4px;
        text-align: center;
        color: #000;*/
    }
    .btnstyle:hover {
        background-color: #CCF;
    }
    .btnstyle:active {
        box-shadow: inset -1px -1px 2px rgba(255, 255, 255, 0.6), inset 1px 1px 2px rgba(0, 0, 0, 0.6);
    }
    .btnstyle:disabled {
        color: #888;
        background-color: rgba(180, 180, 180, 0.6);
    }

    /* (PVB ADD) STYLE FOR THE ID=FILE CHARSET, LISTING DISASSEMBLY & DUMP OPTIONS*/
    pre#disoption {
        border-bottom: solid 1px #CCC;
    }
    .doblock {
        margin-top: -20px;
        display: flex;
        flex-direction: row-reverse;
        justify-content: flex-end;
        flex-wrap: nowrap;
    }
    input[type="checkbox"] {
	    width: 10px;
	    height: 10px;
	    margin-right: 0.5rem;
        cursor: pointer;
    }
    label {
        line-height: 1em;
    } 
    fieldset {
        margin-top: 6px;
        border: solid 1px #CCC;
    }
    .dobgrp {
        display: flex;
        flex-direction: column;
        align-items: flex-end;
    }
    input {
        margin-top: 2px;
        font-size: 12px;
    }
    /*(PVB end of ADD) **********************************************/
    
    .infof {
        min-height: 32px;
        padding: 8px;
        border-bottom: 1px solid #CCC;
        font-size: small;
        overflow: hidden;
    }

    .close-icon {
        display: block;
        box-sizing: border-box;
        width: 12px;
        height: 12px;
        border-width: 2px;
        border-style: solid;
        border-color: gray;
        border-radius: 100%;
        background: -webkit-linear-gradient(-45deg, transparent 0%, transparent 46%, white 46%, white 56%, transparent 56%, transparent 100%), -webkit-linear-gradient(45deg, transparent 0%, transparent 46%, white 46%, white 56%, transparent 56%, transparent 100%);
        background-color: gray;
        transition: all 0.3s ease;
        margin: 4px;
        float: right;
    }

    .close-icon:hover {
        border-color: red;
        background-color: red;
    }

    .radio {
        user-select: none;
        cursor: pointer;
        font-size: 12px;
        height: 16px;
        margin-left: 10px;
        margin-right: 10px;
        margin-top: 4px;
    }

    .radio:last-child {
        margin-right: 0px;
    }

    .radio span {
        margin-right: 1px;
        border: 1px solid #AAC;
        padding-left: 12px;
        padding-right: 12px;
        vertical-align: top;
    }

    .hilite {
        background: #CCF;
    }

    /*(PVB) this is used to display extension list //previously in// font-weight: 300;*/
    .exts {
        padding: 4px;
        margin: 4px;
        font-size: small;
        width: 600px;
    }

    .exts b {
        display: inline-block;
        margin-right: 16px;
        width: 140px;
        text-align: right;
    }

    .open {
        display: inline-block;
        font-size: large;
        cursor: pointer;
        width: 200px;
        border: solid 1px #CCC;
        font-weight: 300;
        margin: 20px;
        color: #AAA;
    }

    .open:hover {
        color: #888;
        border: solid 1px #888;
    }

    .open:active {
        color: #FFF;
        border: solid 1px #FFF;
    }

    .showcode {
        cursor: pointer;
        height: 16px;
        padding: 2px 4px;
        margin-left: 12px;
        margin-right: 12px;
        margin-top: 4px;
        border: solid 1px #CCC;
        background-color: #EEE;
    }

    .showcode:hover {
        color: #F00;
        border: solid 1px #F00;
    }

    /*(PVB ADD) NEW ADDED STYLES FOR BANK DUMP/DISASSEMBLY BUTTON****/
    .bankcode {
        cursor: pointer;
        height: 12px;
        padding: 1px 2px;
        margin-left: 4px;
        margin-right: 4px;
        margin-top: 2px;
        border: solid 1px #888;
        background-color: #EEE;
    }
    .bankcode:hover {
        color: #F00;
        border: solid 1px #F00;
    }
    /*(PVB end of ADD) **********************************************/

    .palette {
        margin-left: 8px;
        display: inline-block;
        margin-top: -2px;
    }

    .dropdown {
        position: relative;
        display: inline-block;
    }

    .dropdown-content {
        display: none;
        position: absolute;
        top: 16px;
        background: #CCC;
        min-width: 288px;
        box-shadow: 0px 8px 16px 0px rgba(0, 0, 0, 0.5);
        z-index: 100;
        margin: 0px;
        padding: 0px;
    }

    .dropdown:hover .dropdown-content {
        display: block;
    }

    .acolor {
        display: inline-block;
        min-width: 16px;
        min-height: 16px;
        border: solid 1px #CCC;
        vertical-align: bottom;
    }

    .acolor:hover {
        border: solid 1px #FFF;
    }

    .atari {
        font-family: 'Atari';
        font-size: 16px;
        line-height: 16px;
        background: #153382;
        color: #B5D3FF;
    }

    #atari_text {
        padding: 4px;
    }
    /*(PVB MOD) ADJUSTEMENT ON PRE AND PRE DATA STYLE*/
    pre {
        font-family: 'Noto Sans Mono', monospace;
        padding: 8px;
        font-size: 12px;
        line-height: 14px;
    }

    pre data {
        font-family: 'Atari';
        font-size: 10px;
        font-weight: normal;
        background: #153382;
        color: #B5D3FF;
    }

    .floater {
        position: fixed;
        z-index: 10;
        cursor: pointer;
        user-select: none;
        line-height: 16px;
        letter-spacing: 0px;
        box-shadow: 0px 8px 16px 0px rgba(171, 163, 163, 0.5);
    }

    .floater span:hover {
        filter: brightness(200%);
    }

    .floater span:active {
        background: #B5D3FF;
        color: #153382;
    }

    .disassembly {
        left: 24px;
        top: 384px;
        width: 492px;
        max-height: 384px;
        overflow: scroll;
        background: #EEE;
    }

    .draggable {
        width: 100%;
        padding: 4px 8px;
        background: #CCF;
        border: solid 1px #CCC;
        font-size: small;
        font-weight: bold;
    }
    /*(PVB MOD) height to 148px instead of 84 (4x16 added) for the E, P, S and M option*/
    .tools {
        width: 20px;
        height: 148px;
        left: 0px;
        top: 320px;
        text-align: center;
    }

    .dimmed {
        filter: brightness(75%);
    }

    .keyboard {
        display: none;
        left: 24px;
        top: 320px;
        height: 256px;
        width: 256px;
        z-index: 11;
    }

    .keyboard_invert {
        font-family: "Open Sans", "Helvetica Neue", Helvetica;
        text-align: center;
        vertical-align: center;
        color: #000;
        font-size: x-small;
        background: #F8F8F8;
    }

    .keyboard_invert:hover {
        background: #CCF;
    }

    .hexed {
        width: 100%;
        height: 100%;
        border: 0px;
    }
</style>
<!--(PVB PVBest infoo ADD) the script link to get the "HTML to CANVAS" function - if someone had better idea, let me know-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<script>
    var _ajax = function (m, u, c, d) {
        var x = new XMLHttpRequest;
        x.onreadystatechange = function () { x.readyState ^ 4 || c(this) };
        x.open(m, u);
        if (d) {
            x.setRequestHeader('Content-Type', 'application/json');
            d = JSON.stringify(d);
        }
        x.send(d);
    };

    var _q = function (q) { //(PVB COM) q is an id selector like "#toc", ou or class selector like ".disassembly"
        return document.querySelector(q) //(PVB COM) returns the HTML selector, ex "div.floater.disassembly"
    };

    //(PVB ADD) the _g() function
    var _g = function (q) { //(PVB COM) q is an id selector like "toc" in div id = toc
        return document.getElementById(q) //(PVB COM) returns the HTML selector, ex "div.floater.disassembly"
    };
    //(PVB END OF ADD)

    var _h = function (q, html) {
        var e = _q(q);
        if (!e) {
            console.log("_h can't find " + q);
            return null;
        }
        return e.innerHTML = html; //(PVB COM) display the "html" in the <div id= 'e' > HTML element
    };

    var _txt = function (q) {
        return _q(q).innerText;
    };

    function stop() {
        event.preventDefault();
        event.stopPropagation();
    }

    function get(url, cb, d) {
        _ajax(d ? "post" : "get", url, function (r) {
            var o = JSON.parse(r.responseText);
            cb(JSON.parse(r.responseText));
        }, d);
    }

    function save_bytes(name, data) { //called by other save_xx() functions
        var blob = new Blob([data], { type: "application/data" });
        var link = document.createElement('a');
        link.href = window.URL.createObjectURL(blob);
        link.download = name;
        link.click();
        window.URL.revokeObjectURL(link.href); //(PVB ADD) revoke to clear memory
    }
    //(PVB ADD) Save the editor() DIV id = "atari_text" into an PNG image
    function save_as_png() { //used by [Save as PNG Image<) button
        console.log("save_as_png() =>Try to save the editor() into PNG image...")
        html2canvas(editor()) //call to an external <script> function - if someone has better idea, let me know
            .then((canvas) => {
                var link = document.createElement("a");
                link.href = canvas.toDataURL("image/png");
                link.download = _shown.name + ".png";
                link.click();
            })
            .catch(function (error) {
            console.error('save_as_png() => Error something went wrong!', error);
            });
    }
    //(PVB END OF ADD)

    var _hex = "0123456789ABCDEF";
    function hex(i, len) {
        var s = '';
        if (!len) //(PVB COM) taille par defaut = 2 caracteres
            len = 2;
        if (i >> (len * 4)) len++; //(PVB MOD) // protection if len is one digit not enough: add a digit
        while (len--)
            s += _hex[(i >> (len * 4)) & 0xF];
        return s;
    }

    //(PVB ADD) escAtasciiChar(b) to modify atari char into an UTF-16 normal char, close to the original one, in the Client system font, but no inverted char considered
    function escAtasciiChar(b) {
        var _escUTFChar = [ //ATASCII control char converted into the closest UTF-16 char
            0x2665,0x2523,0x2595,0x251B,0x252B,0x2513,0x2571,0x2572, 0x25E2,0x2597,0x25E3,0x259D,0x2598,0x2594,0x2582,0x2596,
            0x2663,0x250F,0x2501,0x254B,0x2523,0x2584,0x258F,0x2533, 0x253B,0x258C,0x2517,0x0190,0x2191,0x2193,0x2190,0x2192
        ];
        var cUTF16;
        switch (b) {
            case 0x60:
            case 0xE0:
                cUTF16 = 0x2666; break; //diamond char symbol
            case 0x7B:
                cUTF16 = 0x2660; break; //spade char symbol
            case 0x9B:
                cUTF16 = 0x0190; break; //Return (Line feed) (note: $1B = Escape) [ESC char symbol]
            case 0x7D:
            case 0xFD:
                cUTF16 = 0xB6; break; //Clear & Buzzer [upper left corner arrow char symbol]
            case 0x7E:
            case 0xFE:
                cUTF16 = 0x25C0; break; //left arrow: Delete & Backstace
            case 0x7F:
            case 0xFF:
                cUTF16 = 0x25B6; break; //right arrow: Tab & Insert
            case 0x82: cUTF16 = 0x258A; break; // 3/4 right vertival
            case 0x88: cUTF16 = 0x25E4; break; // triangle up left
            case 0x89: cUTF16 = 0x259B; break; // corner left up
            case 0x8A: cUTF16 = 0x25E5; break; // triangle up right
            case 0x8B: cUTF16 = 0x2599; break; // corner left down
            case 0x8C: cUTF16 = 0x259F; break; // corner right down
            case 0x8D: cUTF16 = 0x2586; break; // 3/4 down horizontal
            case 0x8E: cUTF16 = 0x2580; break; // 3/4 up horizontal //approx
            case 0x8F: cUTF16 = 0x259C; break; // corner right up
            case 0x96: cUTF16 = 0x2595; break; // 3/4 right vertical //approx
            case 0x94: cUTF16 = 0x25D8; break; // inverted dot
            case 0x95: cUTF16 = 0x2580; break; // 1/2 up horizontal
            case 0x96: cUTF16 = 0x2595; break; // 3/4 right vertical //approx
            case 0x99: cUTF16 = 0x2590; break; // 1/2 right vertical
            case 0xA0: cUTF16 = 0x2588; break; // inverted space char
            default:
                cUTF16 = b & 0x7F; //cancel inverted Atascii Char for the others, and get UTF-16 code for Atari control char
                if ((b & 0x7F) < 0x20)
                    cUTF16 = _escUTFChar[cUTF16];
                //else normal ASCII (non inverted)
                break;
        }
        return String.fromCharCode(cUTF16);
    }
    //(PVB ADD) escHtmlChar(c) to escape HTML char with the normal font listing
    function escHtmlChar(c) { //(PVB COM) escaping the HTML <> in the string
        switch (c) {
            case "<": return "&lt;"
            case ">": return "&gt;"
            case "&": return "&amp;"
            case "'": return "&apos;"
            case '"': return '&quot;'
        }
        return c;
    }
    //(PVB ADD) escHtmlString(s) to get a clean "escaped" HTML string with normal font listing
    function escHtmlString(s) { //(PVB COM) esc function is not used ??!! //(PVB TODO) = check why
        var n = ''; 
        for (var i = 0; i < s.length; i++)
            n += escHtmlChar(s.charAt(i));
        return n;
    }

    //(PVB MOD) improvement of hex_line() function: display of sector/offset
    //previously //function hex_line(addr, data, i, len, awidth) {
    //added : sector and sector offset display instead of memory pointer
    //modified the variable name 'i' to 'idx' for index
    //when 'awidth' is the sector_size value (128) or (256), thus greater than 15
    function hex_line(addr, data, idx, len, awidth, dsector, doffset) {
        //addr = address of the beginning of the line; data = byte database;
        //idx = index in the byte database; awidth = number of char to display if <=15; or if not, a sector and an offset (dsector, doffset) to display
        var s = []; //(PVB MOD) Add / pointer + hex byte string
        if (awidth > 15) //(PVB MOD) awitdth is greater than 15 => this is a sector size
            s = ["[" + hex(dsector, 4) + ":" + hex(doffset, 2) + "] "];
        else //(PVB MOD) default display
            s = [hex(addr, awidth || 6) + "   "]; //if awidth is zero then it is replaced by 6 digits, which should be enought for a disk dump pointer up to 0xFFFFFF bytes
        //(PVB MOD) variable declaration
        var a1 = ''; //Atari ANTIC internal display String
        var a2 = ''; //Atari ATASCII (= Ascii for Atari) String
        var pcs1 = ''; //Padding left
        var pcs2 = ''; //Padding right

        var left = addr & 15;
        var right = (16 - ((addr + len) & 15)) & 15;
        if (left) {
            pcs1 += `<span style='background:#DDD'>${' '.repeat(left - 1)} </span>`;
            s.push('   '.repeat(left));
        }
        //(PVB MOD) the char dump is for ANTIC and ATASCII char
        while (len--) {
            var j1 = data[idx]; //by default byte data are ATASCII char codes (byte 00 is a heart char)
            var j2 = j1;
            //convert into ANTIC internal display char code
            if ((j1 & 0x7F) < 64) j1 += 32;
            else if ((j1 & 0x7F) < 96) j1 -= 64;
            //j1 is ANTIC code, j2 is ATASCII code
            if (!_bShowWebChar) { //get the Atari font Char
                a1 += String.fromCharCode(j1 + 0xE000); 
                a2 += String.fromCharCode(j2 + 0xE000); 
            }
            else { //get the equivalent converted HTML Monospace Font Char
                a1 += escAtasciiChar(j1);
                a2 += escAtasciiChar(j2); 
            }
            //push the Hex code into the string
            s.push(hex(data[idx++], 2) + " ");
        }
        //for normal HTML Monospace Font Char string, escape HTML char 
        if (_bShowWebChar) {
            a1 = escHtmlString(a1);
            a2 = escHtmlString(a2);
        }
        if (right) {
            pcs2 += `<span style='background:#DDD'>${' '.repeat(right - 1)} </span>`;
            s.push('   '.repeat(right));
        }
        //(PVB MOD) the display of ATASCII and ANTIC internal display char dump
        if (_bShowDispChar & _bShowAtasciiChar) //ATASCII on the left, ANTIC internal display on the right
            return s.join('') + "   <data>" + pcs1 + a2 + pcs2 + "</data>" + "   <data>" + pcs1 + a1 + pcs2 + "</data>";
        if (_bShowDispChar & !_bShowAtasciiChar)    
            return s.join('') + "   <data>" + pcs1 + a1 + pcs2 + "</data>";
        if (!_bShowDispChar & _bShowAtasciiChar)    
            return s.join('') + "   <data>" + pcs1 + a2 + pcs2 + "</data>";
        return s.join('');
    }

    //(PVB MOD) improvement of hex_dump() function: display of sector/offset
    //previously //function hex_dump(a, i, len, awidth) {
    //modified : the variable name 'hexOption' instead of 'awidth'
    //if 'awidth' has a sector_size value (128) or (256), then sector and sector offset are displayed instead of memory pointer
    //if 'awidth' is greater or equal to 0x1000, then the 'awidth' is an address used for real memory pointer display
    function hex_dump(a, i, len, hexOption) {
        //(PVB) a = byte database; i = index from 0 to xxxx = address; len = number of data to compute
        //if hexOption = x then there is x char for the memory pointer, but if hexOption = 0 then there is 6 char (thanks to hex_line() function)
        //if hexOption = 128 or 256 then we display the sectors and not the memory pointer
        //if hexOption >= 0x1000 then we display the memory address of the ROM bank (there is no lower address than 0x1000 for ROM)
        // then hexOption is formated like 0x10BK where BK is the rom bank number 0..$FF
        var hexdump = []; //(PVB) changed name !! from 'hex' to 'hexdump' - because not to confuse with the hex() function 
        var st; //(PVB ADD)
        //(PVB ADD)
        if (hexOption == 128 || hexOption == 256 ) { //sector_size : compute the sector & offset, then display both of them
            var dsector = 0, doffset = 0;
            hexdump.push("; Sector #" + (dsector+1) + " (at file offset $000000)");
            for (var j = 0; j < len; j += 16) { // one line = 16 bytes
                st = Math.min(16, len - j);
                k = dsector;
                if ((i+j) < 384) {
                    dsector = Math.floor((i+j) / 128);
                    doffset = (i+j) - ((dsector) * 128);
                }
                else {
                    dsector = Math.floor(((i+j) - 384)/ hexOption) + 3;
                    doffset = ((i+j)- 384) - ((dsector - 3) * hexOption);
                }
                if (k != dsector)
                    hexdump.push("; Sector #" + (dsector + 1) + " (at $" + hex(j, 6) + ")"); //(PVB COM) add an empty line between sectors
                //hexOption = a Sector Size, then display the sectors 
                hexdump.push(hex_line(j, a, i + j, st, hexOption, dsector + 1, doffset)); 
            }
            hexdump.push(";<i>End of sector dump \><a href='#top'>Back to top</a></i>");
        }
        //(PVB ADD)
        else if (hexOption >= 0x1000) { //the ROM Disassembly
            var bk = hexOption & 0xFF;//extract the bank number 0xff max
            hexOption &= 0xFF00; // clear the lowest byte of the bank number
            for (var j = 0; j < len; j += 16) { // one line = 16 bytes
                //hexOption = a Start Address, then display the real address
                hexdump.push((_bShowROMBank ? ("n" + hex(bk,2) + ":") : "") + hex_line(hexOption + j, a, i + j, Math.min(16, len - j), 4));
            }
        }   
        else {
            //(PVB end of ADD)
            var k = 0;
            for (var j = 0; j < len; j += 16) { // one line = 16 bytes
                //hexOption = a number of char, then display an index from Zero
                hexdump.push(hex_line(j, a, i + j, Math.min(16, len - j), hexOption)); //hexOption = number of char, 6 is considered if hexOption = 0
                if ((k & 0xF) == 0xF) hexdump.push("");
                k++;
            }
        }
        return hexdump.join("\n");
    }

    //===================================================================================================

    var _fcanvas;
    function draw(ctx, s, x, y, fcanvas) {
        fcanvas = fcanvas || _fcanvas;
        for (var i = 0; i < s.length; i++) {
            var n = s.charCodeAt(i);
            ctx.drawImage(fcanvas, n * 8, 0, 8, 8, x * 8, y * 8, 8, 8);
            x++;
        }
    }

    // generate a canvas containing atari font
    function get_font(src, palette, one_bit) {
        // map atascii to a line of font bits
        // https://www.atariarchives.org/mapping/appendix10.php
        function font_bits(c, y) {
            var invert = c & 0x80 ? 0xFF : 0x00;
            c = c & 0x7F;
            if (c >= 32 && c < 96)
                c -= 32;
            else if (c < 32)
                c += 64;
            return src[c * 8 + y] ^ invert;
        }

        var canvas = document.createElement('canvas');
        canvas.width = 256 * 8;
        canvas.height = 8;
        var ctx = canvas.getContext('2d');

        var pix = ctx.getImageData(0, 0, 256 * 8, 8);
        var d = pix.data;
        var f = 0;
        var i = 0;
        var ap = (p) => {
            p = atari_palette_rgb[palette[p]];
            d[i + 0] = (p >> 16) & 0xFF;
            d[i + 1] = (p >> 8) & 0xFF;
            d[i + 2] = p & 0xFF;
            d[i + 3] = 0xFF;
            i += 4;
        }
        if (!palette) {
            palette = [128 + 20, 128 + 30];
            one_bit = true;
        }
        var bg = atari_palette_rgb[128 + 20];
        for (var y = 0; y < 8; y++) {
            for (var c = 0; c < 256; c++) {
                var b = font_bits(c, y);
                if (palette) {
                    if (one_bit) {
                        for (var x = 0; x < 8; x++) {
                            ap((b >> 7) & 1);
                            b <<= 1;
                        }
                    } else {
                        for (var x = 0; x < 4; x++) {
                            ap((b >> 6) & 3);
                            ap((b >> 6) & 3);
                            b <<= 2;
                        }
                    }
                } else {
                    /*
                    for (var x = 0; x < 8; x++) {
                        if (b & 0x80) {
                                d[i+0] = 128;
                                d[i+1] = 162;
                                d[i+2] = 255;
                            } else {
                                d[i+0] = (bg >> 16) & 0xFF;
                                d[i+1] = (bg >> 8) & 0xFF;
                                d[i+2] = (bg >> 0) & 0xFF;
                            }
                            d[i+3] = 0xFF;
                            i += 4;
                            b <<= 1;
                    }
                    */
                }
            }
        }
        ctx.putImageData(pix, 0, 0);
        return canvas;
    }

    //===================================================================================================

    class Octree {
        constructor(bits) {
            this.leaves = 0;
            this.count = 0;
            this.leaf_level = bits || 4;
        }

        insert(node, color, level) {
            var level;
            if (!node) {
                node = {
                    level: level,
                    n: 0,
                    red: 0,
                    green: 0,
                    blue: 0,
                }
                if (level < this.leaf_level)
                    node.child = [];
                else
                    this.leaves++;
            }
            node.n++;
            node.red += (color >> 16) & 0xFF;
            node.green += (color >> 8) & 0xFF;
            node.blue += color & 0xFF;
            if (node.child) {
                var k = this.key(color, level);
                node.child[k] = this.insert(node.child[k], color, level + 1);
            }
            return node;
        }

        key(color, level) {
            var k = 0;
            var m = 0x80 >> level;
            if ((color >> 16) & m) k |= 0x04;
            if ((color >> 8) & m) k |= 0x02;
            if (color & m) k |= 0x01;
            return k
        }

        color(node) {
            var r = node.red / node.n | 0;
            var g = node.green / node.n | 0;
            var b = node.blue / node.n | 0;
            return { n: node.n, color: ((r << 16) | (g << 8) | b) };
        }

        add(color) {
            this.root = this.insert(this.root, color, 0);
            this.count++;
        }

        scan(node, level, list) {
            if (node.level == level) {
                list.push(node);
                return;
            }
            if (node.child)
                node.child.forEach(c => this.scan(c, level, list));
        }

        finalize(count) {
            var pal;
            var level = 0;
            do {
                pal = [];
                this.scan(this.root, level++, pal);   // scan into levels until we get enough colors
            } while (pal.length < count);
            console.log(pal);
            pal.sort((a, b) => b.n - a.n);
            if (pal.length >= count)
                pal.length = count;
            return pal.map(node => this.color(node));
        }
    }

    function octree(pix, count, gray) {
        var d = pix.data;
        var q = new Octree();
        for (var i = 0; i < pix.width * pix.height * 4; i += 4) {
            var r = d[i];
            var g = d[i + 1];
            var b = d[i + 2];
            if (gray)
                r = g = b = (r * 0.29 + g * 0.59 + b * 0.12) | 0;
            q.add((r << 16) | (g << 8) | b, 0);
        }

        var pal = q.finalize(count);
        return pal.map(c => rgb2atari((c.color >> 16) & 0xFF, (c.color >> 8) & 0xFF, c.color & 0xFF));
    }

    //===================================================================================================
    //  Kmeans for palettes

    function median_cut(pix, centroid_count) {
        var sample_count = pix.width * pix.height;
        var d = pix.data;
        var index = new Uint32Array(sample_count);
        for (var i = 0; i < sample_count; i++)
            index[i] = i * 4;
        var slices = [index];

        function cut(s) {
            var rgb = [];
            for (var c = 0; c < 3; c++)
                rgb.push({ c: c, min: 255, max: 0, d: new Uint32Array(256) });
            for (var i = 0; i < s.length; i++) {
                for (var c = 0; c < 3; c++) {
                    var v = d[s[i] + c];
                    rgb[c].d[v]++;
                    rgb[c].min = Math.min(v, rgb[c].min);
                    rgb[c].max = Math.max(v, rgb[c].max);
                }
            }
            rgb.sort((a, b) => (b.max - b.min) - (a.max - a.min));
            var split = rgb[0];
            var c = split.c;
            var cut = (split.max + split.min) >> 1;
            console.log("Splitting " + ["red", "green", "blue"][c] + " at " + cut);
            console.log(rgb);

            var left = [];
            var right = [];
            for (var i = 0; i < s.length; i++) {
                if (d[s[i] + c] < cut)
                    left.push(s[i]);
                else
                    right.push(s[i]);
            }
            return [left, right];
        }

        while (slices.length < centroid_count) {
            slices.sort((a, b) => b.length - a.length);
            var split = cut(slices.shift());
            slices = slices.concat(split);
        }
        console.log(slices);
        var pal = [];
        slices.forEach(s => {
            var r = 0;
            var g = 0;
            var b = 0;
            s.forEach(i => {
                r += d[i];
                g += d[i + 1];
                b += d[i + 2];
            });
            pal.push(rgb2atari(r / s.length, g / s.length, b / s.length));
        });
        return pal;
    }

    //===================================================================================================
    //  Kmeans for palettes

    function kmeans(pix, centroid_count, gray) {
        console.log("kmeans " + centroid_count + (gray ? "(grayscale)" : ""));
        var sample_count = pix.width * pix.height;
        var samples = [];
        for (var i = 0; i < sample_count; i++)
            samples.push(rgb2yiq(pix.data[i * 4 + 0], pix.data[i * 4 + 1], pix.data[i * 4 + 2]));

        // kmeans++ centroid init
        _lfsr = 0xACE1;
        var rands = () => samples[lfsr() % sample_count];
        var centroids = [{ color: rands(), avg: { y: 0, i: 0, q: 0 }, err: 0, count: 0 }];
        while (centroids.length < centroid_count) {
            var maxe = 0;
            var new_centroid;
            for (var i = 0; i < 100; i++) {
                var s = rands();
                centroids.forEach(c => {
                    var e = yiq_distance(s, c.color);
                    if (e > maxe) {
                        maxe = e;
                        new_centroid = s;
                    }
                });
            }
            centroids.push({ color: new_centroid, avg: { y: 0, i: 0, q: 0 }, err: 0, count: 0 });
        }

        // match samples to centroids
        var last = 0;
        for (var pass = 0; pass < 16; pass++) {

            // match all the samples
            var total_err = 0;
            for (var i = 0; i < sample_count; i++) {
                var mine = 0x7FFFFFF;
                var index = -1;
                var color = samples[i];
                for (var j = 0; j < centroid_count; j++) {
                    var e = yiq_distance(color, centroids[j].color);
                    if (e < mine) {
                        mine = e;
                        index = j;
                    }
                }
                var c = centroids[index];
                c.avg.y += color.y;
                c.avg.i += color.i;
                c.avg.q += color.q;
                c.count++;
                c.err += mine;     // accumulate error
                total_err += mine;
            }

            // recalculate centroid color
            var errs = [];
            for (var i = 0; i < centroid_count; i++) {
                var c = centroids[i];
                if (gray)
                    c.avg.i = c.avg.q = 0;
                if (c.count)
                    c.color = { y: c.avg.y / c.count, i: c.avg.i / c.count, q: c.avg.q / c.count };
                errs.push({ index: i, err: c.err });
            }

            errs.sort((a, b) => b.err - a.err);
            console.log(errs);
            console.log(centroids);

            // split centroids if required
            for (var i = 0; i < centroid_count; i++) {
                if (centroids[i].count == 0) {                              // centroid is not being used
                    var c0 = centroids[errs[0].index].color;
                    var c1 = centroids[errs[1].index].color;                // make new centroid at average of two biggest errors
                    centroids[i].color = { y: (c0.y + c1.y) / 2, i: (c0.i + c1.i) / 2, q: (c0.q + c1.q) / 2 };
                }
                // reset centroids
                centroids[i].count = centroids[i].err = 0;
                centroids[i].avg = { y: 0, i: 0, q: 0 };
            }

            console.log("pass: " + pass + ":" + total_err);
            if (last && total_err >= last)
                break;
            last = total_err;
        }

        var pal = [];
        for (var i = 0; i < centroid_count; i++) {
            var c = centroids[i].color;
            pal.push(yiq2atari(c.y, c.i, c.q));
        }
        console.log(pal);
        return pal;
    }

    // 888 rgb to atari
    function to_atari(rgb) {
        var mine = 0x7FFFFFF;
        var mini = -1;
        for (var i = 0; i < 256; i++) {
            var a = atari_palette_rgb[i];
            var r = ((rgb >> 16) & 0xFF) - ((a >> 16) & 0xFF);
            var g = ((rgb >> 8) & 0xFF) - ((a >> 8) & 0xFF);
            var b = (rgb & 0xFF) - (a & 0xFF);
            var e = r * r + g * g + b * b;
            if (e < mine) {
                mine = e;
                mini = i;
            }
        }
        return mini;
    }

    //===================================================================================================
    // Images

    var atari_palette_rgb = [
        0x00000000, 0x000F0F0F, 0x001B1B1B, 0x00272727, 0x00333333, 0x00414141, 0x004F4F4F, 0x005E5E5E,
        0x00686868, 0x00787878, 0x00898989, 0x009A9A9A, 0x00ABABAB, 0x00BFBFBF, 0x00D3D3D3, 0x00EAEAEA,
        0x00001600, 0x000F2100, 0x001A2D00, 0x00273900, 0x00334500, 0x00405300, 0x004F6100, 0x005D7000,
        0x00687A00, 0x00778A17, 0x00899B29, 0x009AAC3B, 0x00ABBD4C, 0x00BED160, 0x00D2E574, 0x00E9FC8B,
        0x001C0000, 0x00271300, 0x00331F00, 0x003F2B00, 0x004B3700, 0x00594500, 0x00675300, 0x00756100,
        0x00806C12, 0x008F7C22, 0x00A18D34, 0x00B29E45, 0x00C3AF56, 0x00D6C36A, 0x00EAD77E, 0x00FFEE96,
        0x002F0000, 0x003A0000, 0x00460F00, 0x00521C00, 0x005E2800, 0x006C3600, 0x007A4416, 0x00885224,
        0x00925D2F, 0x00A26D3F, 0x00B37E50, 0x00C48F62, 0x00D6A073, 0x00E9B487, 0x00FDC89B, 0x00FFDFB2,
        0x00390000, 0x00440000, 0x0050000A, 0x005C0F17, 0x00681B23, 0x00752931, 0x0084373F, 0x0092464E,
        0x009C5058, 0x00AC6068, 0x00BD7179, 0x00CE838A, 0x00DF949C, 0x00F2A7AF, 0x00FFBBC3, 0x00FFD2DA,
        0x00370020, 0x0043002C, 0x004E0037, 0x005A0044, 0x00661350, 0x0074215D, 0x0082306C, 0x00903E7A,
        0x009B4984, 0x00AA5994, 0x00BC6AA5, 0x00CD7BB6, 0x00DE8CC7, 0x00F1A0DB, 0x00FFB4EF, 0x00FFCBFF,
        0x002B0047, 0x00360052, 0x0042005E, 0x004E006A, 0x005A1276, 0x00672083, 0x00762F92, 0x00843DA0,
        0x008E48AA, 0x009E58BA, 0x00AF69CB, 0x00C07ADC, 0x00D18CED, 0x00E59FFF, 0x00F9B3FF, 0x00FFCAFF,
        0x0016005F, 0x0021006A, 0x002D0076, 0x00390C82, 0x0045198D, 0x0053279B, 0x006135A9, 0x006F44B7,
        0x007A4EC2, 0x008A5ED1, 0x009B6FE2, 0x00AC81F3, 0x00BD92FF, 0x00D0A5FF, 0x00E4B9FF, 0x00FBD0FF,
        0x00000063, 0x0000006F, 0x00140C7A, 0x00201886, 0x002C2592, 0x003A329F, 0x004841AE, 0x00574FBC,
        0x00615AC6, 0x00716AD6, 0x00827BE7, 0x00948CF8, 0x00A59DFF, 0x00B8B1FF, 0x00CCC5FF, 0x00E3DCFF,
        0x00000054, 0x00000F5F, 0x00001B6A, 0x00002776, 0x00153382, 0x00234190, 0x0031509E, 0x00405EAC,
        0x004A68B6, 0x005A78C6, 0x006B89D7, 0x007D9BE8, 0x008EACF9, 0x00A1BFFF, 0x00B5D3FF, 0x00CCEAFF,
        0x00001332, 0x00001E3E, 0x00002A49, 0x00003655, 0x00004261, 0x0012506F, 0x00205E7D, 0x002F6D8B,
        0x00397796, 0x004987A6, 0x005B98B7, 0x006CA9C8, 0x007DBAD9, 0x0091CEEC, 0x00A5E2FF, 0x00BCF9FF,
        0x00001F00, 0x00002A12, 0x0000351E, 0x0000422A, 0x00004E36, 0x000B5B44, 0x00196A53, 0x00287861,
        0x0033826B, 0x0043927B, 0x0054A38C, 0x0065B49E, 0x0077C6AF, 0x008AD9C2, 0x009EEDD6, 0x00B5FFED,
        0x00002400, 0x00003000, 0x00003B00, 0x00004700, 0x0000530A, 0x00106118, 0x001E6F27, 0x002D7E35,
        0x00378840, 0x00479850, 0x0059A961, 0x006ABA72, 0x007BCB84, 0x008FDE97, 0x00A3F2AB, 0x00BAFFC2,
        0x00002300, 0x00002F00, 0x00003A00, 0x00004600, 0x00115200, 0x001F6000, 0x002E6E00, 0x003C7C12,
        0x0047871C, 0x0057972D, 0x0068A83E, 0x0079B94F, 0x008ACA61, 0x009EDD74, 0x00B2F189, 0x00C9FFA0,
        0x00001B00, 0x00002700, 0x000F3200, 0x001C3E00, 0x00284A00, 0x00365800, 0x00446600, 0x00527500,
        0x005D7F00, 0x006D8F19, 0x007EA02B, 0x008FB13D, 0x00A0C24E, 0x00B4D662, 0x00C8EA76, 0x00DFFF8D,
        0x00110E00, 0x001D1A00, 0x00292500, 0x00353100, 0x00413D00, 0x004F4B00, 0x005D5A00, 0x006B6800,
        0x0076720B, 0x0085821B, 0x0097932D, 0x00A8A43E, 0x00B9B650, 0x00CCC963, 0x00E0DD77, 0x00F7F48F,
    ];

    function rgb2yiq(r, g, b) {
        return {
            y: r * 0.299 + g * 0.587 + b * 0.114,
            i: r * 0.596 - g * 0.275 - b * 0.321,
            q: r * 0.212 - g * 0.523 + b * 0.311
        }
    }

    function rgb2atari(r, g, b) {
        var yiq = rgb2yiq(r, g, b);
        var angle = Math.atan2(yiq.i, yiq.q);
        var saturation = yiq.i * yiq.i + yiq.q * yiq.q;
        var offset = (180 - 26.8) * Math.PI / 180.0;
        var scale = 360 / 26.8;
        var cr = (offset - angle) * scale / (2 * Math.PI) | 0;
        cr %= 15;
        if (saturation < 1)
            cr = 0;
        else
            cr++;
        return (cr << 4) | (yiq.y / 16 | 0);
    }

    function atari2yiq(a) {
        var cr = a >> 4;
        var i = 0;
        var q = 0;
        if (cr) {
            var color_diff = 2 * Math.PI * 26.8 / 360;
            var angle = Math.PI * 303 / 180 + (cr - 1) * color_diff;
            i = Math.cos(angle) * 63;
            q = Math.sin(angle) * 63;
        }
        return { y: (a & 0xF) * 16, i: i, q: q };
    }

    function yiq2atari(y, i, q) {
        var angle = Math.atan2(i, q);
        var saturation = i * i + q * q;
        var offset = (180 - 26.8) * Math.PI / 180.0 - angle;
        if (offset < 0)
            offset += 2 * Math.PI;
        var scale = 360 / 26.8;
        var cr = offset * scale / (2 * Math.PI);
        cr = (cr + 0.5) | 0;
        if (saturation < 256)
            cr = 0;
        else
            cr = (cr + 1) & 0xF;
        cr = (cr << 4) | ((y / 16) | 0);
        console.log("y:" + y + " i:" + i + " q:" + q + " -> " + hex(cr) + " sat:" + saturation);
        return cr;
    }

    function yiq_distance(a, b) {
        var dy = a.y - b.y;
        var di = a.i - b.i;
        var dq = a.q - b.q;
        return dy * dy + di * di + dq * dq;
    }

    // 
    var _lfsr = 0xACE1;
    function lfsr() {
        _lfsr ^= _lfsr >> 7;
        _lfsr ^= _lfsr << 9;
        _lfsr ^= _lfsr >> 13;
        return _lfsr;
    }

    // mode 0 = Atkinson Dither
    // mode 1 = Floyd Steinberg
    // mode 2 = noise
    // mode 3 = ordered
    // mode 4 = No diffusion

    var _ordered8x8 = new Uint8Array([
        0, 32, 8, 40, 2, 34, 10, 42,
        48, 16, 56, 24, 50, 18, 58, 26,
        12, 44, 4, 36, 14, 46, 6, 38,
        60, 28, 52, 20, 62, 30, 54, 22,
        3, 35, 11, 43, 1, 33, 9, 41,
        51, 19, 59, 27, 49, 17, 57, 25,
        15, 47, 7, 39, 13, 45, 5, 37,
        63, 31, 55, 23, 61, 29, 53, 21
    ]);

    var _ordered16x16 = new Uint8Array([
        0, 192, 48, 240, 12, 204, 60, 252, 3, 195, 51, 243, 15, 207, 63, 255,
        128, 64, 176, 112, 140, 76, 188, 124, 131, 67, 179, 115, 143, 79, 191, 127,
        32, 224, 16, 208, 44, 236, 28, 220, 35, 227, 19, 211, 47, 239, 31, 223,
        160, 96, 144, 80, 172, 108, 156, 92, 163, 99, 147, 83, 175, 111, 159, 95,
        8, 200, 56, 248, 4, 196, 52, 244, 11, 203, 59, 251, 7, 199, 55, 247,
        136, 72, 184, 120, 132, 68, 180, 116, 139, 75, 187, 123, 135, 71, 183, 119,
        40, 232, 24, 216, 36, 228, 20, 212, 43, 235, 27, 219, 39, 231, 23, 215,
        168, 104, 152, 88, 164, 100, 148, 84, 171, 107, 155, 91, 167, 103, 151, 87,
        2, 194, 50, 242, 14, 206, 62, 254, 1, 193, 49, 241, 13, 205, 61, 253,
        130, 66, 178, 114, 142, 78, 190, 126, 129, 65, 177, 113, 141, 77, 189, 125,
        34, 226, 18, 210, 46, 238, 30, 222, 33, 225, 17, 209, 45, 237, 29, 221,
        162, 98, 146, 82, 174, 110, 158, 94, 161, 97, 145, 81, 173, 109, 157, 93,
        10, 202, 58, 250, 6, 198, 54, 246, 9, 201, 57, 249, 5, 197, 53, 245,
        138, 74, 186, 122, 134, 70, 182, 118, 137, 73, 185, 121, 133, 69, 181, 117,
        42, 234, 26, 218, 38, 230, 22, 214, 41, 233, 25, 217, 37, 229, 21, 213,
        170, 106, 154, 90, 166, 102, 150, 86, 169, 105, 153, 89, 165, 101, 149, 85
    ]);

    function dither_image(pix, pal, mode) {
        mode = mode || 0;
        var d = pix.data;
        var buf = new Uint8Array(3);
        var errs = new Int16Array(3);
        var dst = new Uint8Array(pix.width * pix.height);
        var distance = _radios["distance"].value;
        var dscale = pal.length == 2 ? 0.75 : 0.25;

        function get_index(src, p) {
            var mind = -1;
            var merr = 0xFFFFFF;

            if (distance == 0)  // RGB distnance measure
            {
                var r = src[p + 0];
                var g = src[p + 1];
                var b = src[p + 2];
                var e;
                for (var i = 0; i < pal.length; i++) {
                    var err = 0;
                    var c = atari_palette_rgb[pal[i]];
                    e = r - ((c >> 16) & 0xFF);
                    err += e * e;
                    e = g - ((c >> 8) & 0xFF);
                    err += e * e;
                    e = b - (c & 0xFF);
                    err += e * e;
                    if (err < merr) {
                        merr = err;
                        mind = i;
                    }
                }
            } else {
                var pyiq = rgb2yiq(src[p + 0], src[p + 1], src[p + 2]);  // yiq + y only
                var e;
                for (var i = 0; i < pal.length; i++) {
                    var err = 0;
                    var yiq = atari2yiq(pal[i]);
                    e = yiq.y - pyiq.y;
                    err += e * e * 2;
                    if (distance == 1) {        // include chroma
                        e = yiq.i - pyiq.i;
                        err += e * e;
                        e = yiq.q - pyiq.q;
                        err += e * e;
                    }
                    if (err < merr) {
                        merr = err;
                        mind = i;
                    }
                }
            }

            var c = atari_palette_rgb[pal[mind]];
            errs[0] = (src[p + 0] - ((c >> 16) & 0xFF));   // save error in RGB
            errs[1] = (src[p + 1] - ((c >> 8) & 0xFF));
            errs[2] = (src[p + 2] - ((c >> 0) & 0xFF));
            return pal[mind];    // closest index
        }

        function pin(n) {
            if (n < 0) return 0;
            if (n > 255) return 255;
            return n;
        }

        function rnd() {
            return ((lfsr() & 0xFF) - 128) * dscale;
        }

        function noisy(i) {
            buf[0] = pin(d[i + 0] + rnd());
            buf[1] = pin(d[i + 1] + rnd());
            buf[2] = pin(d[i + 2] + rnd());
        }

        function ordered(i, x, y) {
            var n = ((x & 0xF) << 4) | (y & 0xF);
            n = (_ordered16x16[n] - 128) * dscale;
            buf[0] = pin(d[i + 0] + n);
            buf[1] = pin(d[i + 1] + n);
            buf[2] = pin(d[i + 2] + n);
        }

        function add_err(x, y, scale) {
            scale = scale || 1 / 6;   // Atkinson
            if (x < 0 || x >= pix.width || y < 0 || y >= pix.height)
                return;
            var i = (x + y * pix.width) * 4;
            d[i + 0] = pin(d[i + 0] + errs[0] * scale);
            d[i + 1] = pin(d[i + 1] + errs[1] * scale);
            d[i + 2] = pin(d[i + 2] + errs[2] * scale);
        }

        var i = 0;
        var row = 0;
        for (var y = 0; y < pix.height; y++) {
            for (var x = 0; x < pix.width; x++) {
                switch (mode) {
                    case 0:
                        dst[i++] = get_index(d, row + x * 4);    // Atkinson
                        add_err(x + 1, y + 0);
                        add_err(x + 2, y + 0);
                        add_err(x - 1, y + 1);
                        add_err(x + 0, y + 1);
                        add_err(x + 1, y + 1);
                        add_err(x + 0, y + 2);
                        break;

                    case 1:
                        dst[i++] = get_index(d, row + x * 4);    // Floyd Steinberg
                        add_err(x + 1, y + 0, 7 / 16);
                        add_err(x - 1, y + 1, 3 / 16);
                        add_err(x + 0, y + 1, 5 / 16);
                        add_err(x + 1, y + 1, 1 / 16);
                        break;

                    case 2:
                        noisy(row + x * 4);
                        dst[i++] = get_index(buf, 0);
                        break;

                    case 3: // ordered
                        ordered(row + x * 4, x, y);
                        dst[i++] = get_index(buf, 0);
                        break;

                    case 4: // none
                        dst[i++] = get_index(d, row + x * 4);
                        break;
                }
            }
            row += pix.width * 4;
        }
        return dst;
    }

    function pack_img(indexes, pal, ext) {
        var dst = 0;
        var bpp = 2;
        switch (ext) {
            case 'gr8':
                bpp = 1;
                break;
            case 'gr9':
            case 'g10':
                bpp = 4;
                break;
        }
        var ppb = 8 / bpp;
        var pal_len = pal ? pal.length : 0;
        var d = new Uint8Array(indexes.length / ppb + pal_len);

        for (var i = 0; i < indexes.length;) {
            var b = 0;
            for (var j = 0; j < ppb; j++) {
                b <<= bpp;
                if (pal_len)
                    b |= pal.indexOf(indexes[i++]);
                else
                    b |= indexes[i++];
            }
            d[dst++] = b;
        }
        for (var i = 0; i < pal_len; i++)
            d[dst++] = pal[i];
        return d;
    }

    function raw_rgb(pix) {
        var n = pix.width * pix.height;
        var d = new Uint8Array(n * 3);
        if (1) {
            var pal = [];
            for (var i = 0; i < 256; i++)
                pal.push(i);
            var indexed = dither_image(pix, pal, 1);
            for (var i = 0; i < n; i++) {
                var c = atari_palette_rgb[indexed[i]];  // 
                d[i * 3 + 0] = (c >> 16) & 0xFF;
                d[i * 3 + 1] = (c >> 8) & 0xFF;
                d[i * 3 + 2] = c & 0xFF;
            }
        } else {
            for (var i = 0; i < n; i++) {
                d[i * 3 + 0] = pix.data[i * 4 + 0];
                d[i * 3 + 1] = pix.data[i * 4 + 1];
                d[i * 3 + 2] = pix.data[i * 4 + 2];
            }
        }
        return d;
    }

    // raw rgb
    function show_rgb(canvas, f) {
        canvas.width = f.data.length == (320 * 192 * 3) ? 320 : 160;
        canvas.height = 192;
        var ctx = canvas.getContext('2d');
        var pix = ctx.getImageData(0, 0, canvas.width, canvas.height);
        var d = pix.data;
        var s = f.data;
        var n = canvas.width * canvas.height;
        var p = {};
        for (var i = 0; i < n; i++) {
            var r = d[i * 4 + 0] = s[i * 3 + 0];
            var g = d[i * 4 + 1] = s[i * 3 + 1];
            var b = d[i * 4 + 2] = s[i * 3 + 2];
            d[i * 4 + 3] = 0xFF;
            p[(r << 16) | (g << 8) | b] = 1;
        }
        var pal = [];
        Object.keys(p).forEach(c => pal.push(rgb2atari((c >> 16) | 0xFF, (c >> 8) & 0xFF, c & 0xFF)));
        ctx.putImageData(pix, 0, 0);
        return { pal: pal, aspect: [320 / canvas.width * 2, 192 / canvas.height * 2] };
    }

    var _mono_cr = 0;
    function convert_image(canvas, f, pal, reload) {
        //if (f.name.indexOf(".rgb") != -1)
            //return show_rgb(canvas,f);

        var dither = _radios["dither"].value;
        var scheme = _radios["scheme"].value;

        var width = 320;
        var height = 192;

        var img = f.imgTag;
        var src_width = img.width;
        var src_height = img.height;
        var dst_width, dst_height;
        var ratio = img.width / img.height;
        if (ratio > width / height) {
            dst_width = width;
            dst_height = width / ratio;    // wide
        } else {
            dst_height = height;
            dst_width = height * ratio;    // tall
        }

        // 80,160 or 320 wide
        var pal_size = 0;
        switch (f.ext) {
            case "gr7":
                width /= 2;
                if (src_width == 160 && src_height == 192) {
                    // already native size
                } else {
                    dst_width /= 2;
                }
                pal_size = 4;
                break;
            case "gr8":
                pal_size = 2;
                break;
            case "gr9":
                pal = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];
            case "g10":
                width /= 4;
                if (src_width == 80 && src_height == 192) {
                    // already native size
                } else {
                    dst_width /= 4;
                }
                pal_size = f.ext == 'g10' ? 9 : 0;
                break;
        }

        canvas.width = width;
        canvas.height = height;
        var ctx = canvas.getContext('2d');
        ctx.fillRect(0, 0, width, height);
        ctx.drawImage(f.imgTag, 0, 0, img.width, src_height, (width - dst_width) / 2, (height - dst_height) / 2, dst_width, dst_height);

        var pix = ctx.getImageData(0, 0, width, height);
        //f.rgb = raw_rgb(pix);

        var mono = -1;
        if (reload && pal_size) {
            function monochrome(c) {
                for (var i = 0; i < pal_size; i++)  // make a grey palette, will apply chroma later
                    pal[i] = (i * 15 / (pal_size - 1)) | (_mono_cr << 4);
                mono = c;
            }
            switch (scheme) {
                case 0:
                    monochrome(0x00);   // grey
                    break;
                case 1:     // red-green
                    switch (pal_size) {
                        case 2: pal = [0x45, 0xE9]; break;
                        case 4: pal = [0x71, 0x45, 0xE9, 0x0D]; break; // Technicolor 100
                        case 9: pal = [0x71, 0x45, 0xE9, 0x47, 0xE7, 0x07, 0x49, 0xE5, 0x0D]; break; // Technicolor 100
                            break;
                    }
                    break;
                case 2:      // random
                    for (var i = 0; i < pal.length; i++)
                        pal[i] = lfsr() & 0xFF;
                    break;

                case 3: // kmeans
                    pal = kmeans(pix, pal_size);
                    break;

                case 4: // octree
                    pal = octree(pix, pal_size);
                    break;

                case 5:
                    pal = median_cut(pix, pal_size);
                    break;
            }
        }

        // dither to atari palette
        var indexed = dither_image(pix, pal, dither);

        // apply mono color if any
        if (mono != -1) {
            for (var i = 0; i < pal.length; i++)
                pal[i] |= mono;
            for (var i = 0; i < indexed.length; i++)
                indexed[i] |= mono;
        }

        // pack into the appropriate format
        f.packed_img = pack_img(indexed, pal_size ? pal : null, f.ext);

        // turn it back into RGB to display
        var rgb = Uint32Array.from(indexed).map(i => atari_palette_rgb[i]);
        rgb2canvas(canvas, rgb, width, height, 1);
        return { pal: pal, aspect: [320 / canvas.width * 2, 192 / canvas.height * 2] };
    }

    // atari index color to canvas
    // may stretch horizontally to maintain aspect ratio
    function rgb2canvas(canvas, atari, width, height, aspect, brightness) {
        brightness = brightness || 1;
        canvas.width = width * aspect;
        canvas.height = height;
        var ctx = canvas.getContext('2d');
        var pix = ctx.getImageData(0, 0, width * aspect, height);
        var d = pix.data;
        var src = 0;
        var i = 0;
        var pin = (p) => Math.min(0xFF, (p & 0xFF) * brightness);
        for (var y = 0; y < height; y++) {
            for (var x = 0; x < width; x++) {
                var c = atari[src++];
                for (var j = 0; j < aspect; j++) {
                    d[i + 0] = pin(c >> 16);
                    d[i + 1] = pin(c >> 8);
                    d[i + 2] = pin(c);
                    d[i + 3] = 0xFF;
                    i += 4;
                }
            }
        }
        ctx.putImageData(pix, 0, 0);
    }

    // convert a koala into a mic
    function koala(src) {
        var dst = new Uint8Array(7684);
        var dst_len = 7680;
        var i = src[4] + 1;
        var j = 0;
        var end = src.length;
        var type = src[7];

        if (type == 0) {
            while (i < end)
                dst[j++] = src[i++];  // no compression
        } else {
            while (i < end) {
                var b = src[i++];
                var len = b & 0x7F;
                if (len == 0) {
                    len = src[i++] << 8;
                    len |= src[i++];
                }
                b = (b & 0x80) ? -1 : src[i++];

                do {
                    dst[j] = b < 0 ? src[i++] : b;
                    if (j == (dst_len - 1))
                        break;
                    if (type == 2)
                        j++;
                    else {
                        j += 80;
                        if (j >= dst_len)
                            j -= (j < dst_len + 40) ? dst_len - 40 : dst_len + 39;
                    }
                } while (--len > 0);
            }
        }

        dst[7680] = src[17];
        dst[7681] = src[13];
        dst[7682] = src[14];
        dst[7683] = src[15];
        return dst;
    }

    // unpack from Piotr Fusik and Adrian Matoga

    function unpack_rip(data, data_len, unpacked_data, unpacked_len) {
        function create_fano_tree(src, offset, n, tree) {
            var i;
            var pos = 0;
            var positions = new Int32Array(16);
            for (i = 0; i < 16; i++)
                tree.count[i] = 0;
            for (i = 0; i < n; i++) {
                var bits = src[(i >> 1) + offset];
                bits = (i & 1) == 0 ? bits >> 4 : bits & 0xf;
                tree.count[bits]++;
            }
            for (i = 0; i < 16; i++) {
                positions[i] = pos;
                pos += tree.count[i];
            }
            for (i = 0; i < n; i++) {
                var bits = src[(i >> 1) + offset];
                bits = (i & 1) == 0 ? bits >> 4 : bits & 0xf;
                tree.values[positions[bits]++] = i & 0xFF;
            }
        }

        function get_bit(s) {
            var bits = s.bits;
            if (bits == 0x80) {
                if (s.offset >= s.length)
                    return -1;
                bits = s.bytes[s.offset++] * 2 + 1;
            }
            else
                bits <<= 1;
            s.bits = bits & 0xFF;
            return bits >> 8;
        }

        function get_code(s, tree) {
            var p = tree.count[0];
            var i = 0;
            var bits;
            for (bits = 1; bits < 16; bits++) {
                var n = tree.count[bits];
                var bit = get_bit(s);
                if (bit == -1)
                    return -1;
                i = i * 2 + bit;
                if (i < n)
                    return tree.values[p + i];
                p += n;
                i -= n;
            }
            return -1;
        }

        var length_tree = { count: new Int32Array(16), values: new Uint8Array(256) };
        var distance_tree = { count: new Int32Array(16), values: new Uint8Array(256) };
        var literal_tree = { count: new Int32Array(16), values: new Uint8Array(256) };
        var stream = { bits: 0x80, bytes: data, length: data_len, offset: 16 + 288 };
        var unpacked_offset;

        /* "PCK" header (16 bytes) */
        if (data_len < 304 || data[0] != 80 || data[1] != 67 || data[2] != 75)  // PCK
            return 0;

        /* 288 bytes Shannon-Fano bit lengths */
        create_fano_tree(data, 16, 64, length_tree);
        create_fano_tree(data, 16 + 32, 256, distance_tree);
        create_fano_tree(data, 16 + 32 + 128, 256, literal_tree);

        /* LZ77 */
        for (unpacked_offset = 0; unpacked_offset < unpacked_len;) {
            switch (get_bit(stream)) {
                case -1:
                    console.log(`rip truncation: got ${unpacked_offset} of ${unpacked_len}`);
                    return 0;
                case 0:
                    unpacked_data[unpacked_offset++] = get_code(stream, literal_tree);
                    break;
                case 1:
                    {
                        var distance = get_code(stream, distance_tree) + 2;
                        var len;
                        if (distance > unpacked_offset)
                            return 0;
                        len = get_code(stream, length_tree) + 2;
                        do {
                            unpacked_data[unpacked_offset] = unpacked_data[unpacked_offset - distance];
                            unpacked_offset++;
                        } while (--len > 0);
                        break;
                    }
            }
        }
        return 1;
    }

    function rip(d) {
        var mode = d[7];
        var hdr_len = d[11] + (d[12] << 8);
        var height = d[15];
        var txt_len = d[17];
        var pal_len = d[20 + txt_len];
        var dst;
        var txt = '';

        for (var i = 0; i < txt_len; i++)
            txt += String.fromCharCode(d[24 + i]);
        console.log(`rip mode:${mode}, rowbytes:${d[13]}, height:${d[15]} txt:${txt}`);

        if (d[9] == 0) {
            dst = d.slice(hdr_len, d.length);
        } else if (d[9] == 1) {
            var n = d[13];
            if (mode == 0x30)
                n += 4;  // 8 byte palette every 2nd line at end of image(s)
            n *= height;
            dst = new Uint8Array(n);
            var src = d.slice(hdr_len, d.length);
            if (!unpack_rip(src, src.length, dst, n))
                console.log("bad unpack_rip?");
        } else
            return null;

        // Copy palette
        var pal = new Uint8Array(pal_len);
        for (var i = 0; i < pal_len; i++)
            pal[i] = d[24 + txt_len + i];

        // separate mutlirip palette
        var multihip_pal = null;
        if (mode == 0x30) {
            var n = d[13] * height;
            multihip_pal = dst.slice(n, dst.length);
            dst = dst.slice(0, n);
        }
        // have the unpacked frame
        return {
            pal: pal,
            multihip_pal: multihip_pal,
            data: dst,
            ext: "rip_hip",
            mode: mode
        }
    }

    var _palette = [0, 5, 10, 15];
    var _reload_palette = 0; //(PVB MOD) force to 0 ///WIP// is this correction is now OK ?
    var _palettable = ["gr7", "gr8", "g10", "mic", "mcp", "inp", "cin", "pic", "scr"]; //(PVB COM) list of palettable image type
    function is_palettable(ext) {
        return _palettable.indexOf(ext) != -1;
    }

    function render_image(canvas, f) {
        var def_palette = [0, 5, 10, 15];
        switch (f.ext) {
            case "gr8": def_palette = [0, 15]; break;
            case "g10": def_palette = [0, 2, 4, 6, 8, 10, 12, 14, 15]; break;
        }
        var pal0 = _reload_palette ? def_palette.slice() : _palette.slice();
        var pal1 = _reload_palette ? def_palette.slice() : _palette.slice();
        var hip = [0, 0, 2, 4, 6, 8, 10, 12, 14, 0x20, 0x40, 0x60, 0x80, 0xA0, 0xC0, 0xE0];
        var multihip_pal = null;

        // We are rendering an image
        //  if (f.img || (f.name.indexOf(".rgb") != -1)) {
        if (f.imgTag) {
            var r = convert_image(canvas, f, pal0, _reload_palette);
            if (_reload_palette) {
                _palette = r.pal.slice();
                redraw_palette();
            }
            return r.aspect;
        }

        var data = f.data;
        var ext = f.ext;
        var height = 192;
        var width = 160;
        var offset = 40;
        var offset2 = 40;
        var gr = 7;
        var src = 0;

        // Turn PIC into MIC
        if (ext == "pic") {
            data = koala(data);
            ext = "mic";
        }

        // Turn RIP into something
        if (ext == "rip") {
            var r = rip(data);
            data = r.data;
            ext = r.ext;
            hip = r.pal;

            switch (r.mode) {
                case 14: ext = "rip_mode_14"; break;
                case 16: ext = "rip_mode_16"; break;
                case 30:
                    ext = "inp";
                    for (var i = 0; i < 4; i++)
                        pal0[i] = pal1[i] = hip[4 + ((i - 1) & 3)];
                    break;
                case 48:
                    ext = "rip_multirip";
                    multihip_pal = r.multihip_pal;
                    break;
            }
        }

        function set_pal(p, offset, len) {
            if (_reload_palette) {
                pal0.length = len;
                pal1.length = len;
                for (var i = 0; i < len; i++)
                    pal0[i] = pal1[i] = p[offset++];
                _palette = pal0.slice();
                redraw_palette();
            }
        }

        function avg(p0, p1) {
            return ((atari_palette_rgb[p0] & 0x00FEFEFE) + (atari_palette_rgb[p1] & 0x00FEFEFE)) >> 1;
        }

        // Atari Graphics Works?
        if (ext == "scr" && data.length == 16000) {
            data = data.slice(0, 7684);
            ext = "gr7";
        }

        switch (data.length) {
            case 3844:
            case 7684:
            case 9604:
            case 16004: // Interpainter
                set_pal(data, data.length - 4, 4);
                break;

            case 7682:
                set_pal(data, data.length - 2, 2);
                break;

            case 7689:
                set_pal(data, data.length - 9, 9);
                break;
        }

        switch (ext) {
            case "mic": //mic & pic (above converted to mic)
            case "gr7":
                height = 96;
                if (data.length >= 7680)
                    height = 192;
                break;

            case "gr8":
                width = 320;
                gr = 8;
                if (data.length == 7680)
                    set_pal([0, 0xF], 0, 2);
                break;

            case "gr9":
                width = 80;
                gr = 9;
                break;

            case "g10":
                width = 80;
                gr = 10;
                break;

            case "ilc":
            case "pzm":
                width = 80;
                offset = 40 * 192;
                gr = 33;
                break;

            case "plm":
            case "apc":
                width = 80;
                height = 96;
                gr = 32;
                break;

            case "mcp":
                height = data.length == 16008 ? 200 : 100;
                for (var i = 0; i < 4; i++) {
                    pal0[i] = data[height * 80 + ((i - 1) & 3)];
                    pal1[i] = data[height * 80 + 4 + ((i - 1) & 3)];
                }
                offset = height * 40;
                gr = 39;
                break;

            case "inp":
                height = 200;
                offset = height * 40;
                gr = 37;
                break;

            // switch between Graphics 11 and Graphics 15
            // https://en.wikipedia-on-ipfs.org/wiki/Atari_8-bit_family_software-driven_graphics_modes.html
            case "cin":
                offset = 80 * height / 2;
                gr = 34;
                break;

            case "raw":
                src += 4;       // skip header 'XLPB'
                for (var i = 0; i < 4; i++) {
                    pal0[i] = data[0x3C04 + ((i - 1) & 3)];
                    pal1[i] = data[0x3C08 + ((i - 1) & 3)];
                }
                height = 192;
                gr = 37;
                break;

            case "ist":
                height = 200;
                src = 16;
                offset = 0x2000;
                gr = 35;
                break;

            case "hip":
                // 10 and 9 greyscale
                gr = 36;
                var hdr = le16(data, 0); // FFFF
                if (hdr == 0xFFFF && data.length != 16009) {    // Has header: Frames have explicit length
                    var len0 = le16(data, 4) - le16(data, 2) + 1;
                    var len1 = le16(data, 4 + len0 + 6) - le16(data, 2 + len0 + 6) + 1;
                    src += 6;
                    offset = len0 + 6;
                    height = len0 / 40;
                } else {
                    height = data.length / 80 | 0;
                    src = height * 40;
                    offset = -height * 40;
                    var p = height * 80;
                    if ((p + 9) == data.length) {   // has a palette?
                        for (var i = 0; i < 9; i++)
                            hip[i] = data[p++];
                    }
                }
                break;

            case "tip":
                width = data[5];
                height = data[6];
                var frame_len = data[7] | (data[8] << 8);
                // 3 frames: gr9 luma, gr10 luma, gr11 chroma
                src += 9;                   // gr9 luma
                offset = frame_len;         // gr10 luma
                offset2 = frame_len * 2;      // chroma
                gr = 38;
                break;

            case "rip_hip":
            case "rip_multirip":
                height = data.length / 80;
                offset = height * 40;
                gr = 36;
                break;

            case "rip_mode_14":
                height = 192;
                for (var i = 0; i < 4; i++) {
                    pal0[i] = pal1[i] = hip[4 + (i == 0 ? 4 : i - 1)] & 0xFE;
                    set_pal(pal0, 0, 4);
                }
                gr = 7;
                break;

            case "rip_mode_16":
                for (var i = 0; i < 4; i++) {
                    pal0[i] = hip[4 + i]; // TODO: why are they all dark?
                    pal1[i] = hip[0 + i] & 0xFE;
                }
                height = data.length / 80;
                offset = data.length / 2;
                gr = 37;    //
                break;
        }

        var buf = new Uint32Array(width * height);
        var dst = 0;
        var lastp = 0;
        var ap = atari_palette_rgb;
        for (var y = 0; y < height; y++) {
            var pal = (y & 1) ? pal1 : pal0;

            if (gr == 35) { // ist palette
                pal0[0] = pal1[0] = data[0x4000 + y];
                pal0[1] = pal1[1] = data[0x40C8 + y];
                pal0[2] = pal1[2] = data[0x4190 + y];
                pal0[3] = pal1[3] = data[0x4258 + y];
            }

            if (multihip_pal) {
                for (var i = 0; i < 16; i++) {
                    var gr10_to_reg = [0, 1, 2, 3, 4, 5, 6, 7, 8, 8, 8, 8, 4, 5, 6, 7];
                    hip[i] = i == 0 ? 0 : multihip_pal[gr10_to_reg[i] + ((y >> 1) << 3) - 1] & 0xFE;
                }
            }

            for (var x = 0; x < width;) {
                var b = data[src];
                switch (gr) {
                    case 7:
                        for (var j = 0; j < 4; j++) {
                            var bb = (b >> 6) & 3;
                            buf[dst++] = ap[pal[bb]];
                            b <<= 2;
                        }
                        x += 4;
                        break;

                    case 8:
                        for (var j = 0; j < 8; j++) {
                            var bb = (b >> 7) & 1;
                            buf[dst++] = ap[pal[bb]];
                            b <<= 1;
                        }
                        x += 8;
                        break;

                    case 9:
                        buf[dst++] = ap[b >> 4];        // 9=16 greys,10=index,11=chroma
                        buf[dst++] = ap[b & 0x0F];
                        x += 2;
                        break;

                    case 10:
                        buf[dst++] = ap[pal[b >> 4]];
                        buf[dst++] = ap[pal[b & 0x0F]];
                        x += 2;
                        break;

                    case 32:
                        var luma = data[src + offset];
                        buf[dst++] = ap[((luma >> 4) & 0x0F) | (b & 0xF0)];
                        buf[dst++] = ap[(luma & 0xF) | ((b & 0xF) << 4)];
                        x += 2;
                        break;

                    case 33:
                        var hue = data[src + offset];
                        buf[dst++] = ap[((b >> 4) & 0x0F) | (hue & 0xF0)];
                        buf[dst++] = ap[(b & 0xF) | ((hue & 0xF) << 4)];
                        x += 2;
                        break;

                    case 34: // Champions
                        var hue = data[src + offset];
                        buf[dst++] = ap[pal[b >> 6] | (hue & 0xF0)];
                        buf[dst++] = ap[pal[(b >> 4) & 3] | (hue & 0xF0)];
                        buf[dst++] = ap[pal[(b >> 2) & 3] | ((hue & 0xF) << 4)];
                        buf[dst++] = ap[pal[b & 3] | ((hue & 0xF) << 4)];
                        x += 4;
                        break;

                    case 36:  // hip
                        //  00001111
                        //  LL222233
                        var p2 = hip[b >> 4];         // gr10
                        var p3 = hip[b & 0xF];
                        b = data[src + offset];
                        var p0 = b >> 4;                // gr9
                        var p1 = b & 0xF;

                        buf[dst++] = avg(p0, lastp);
                        buf[dst++] = avg(p0, p2);
                        buf[dst++] = avg(p1, p2);
                        buf[dst++] = avg(p1, p3);
                        lastp = p3;
                        x += 4;
                        break;// hip

                    case 35: // ist
                    case 37: // rip_mode_16/inp
                        var b2 = data[src + offset];
                        var pal_0 = (y & 1) ? pal1 : pal0;
                        var pal_1 = (y & 1) ? pal0 : pal1;
                        for (var j = 0; j < 4; j++) {
                            var p0 = pal_1[(b2 >> 6) & 3];
                            var p1 = pal_0[(b >> 6) & 3];
                            buf[dst++] = avg(p0, p1);
                            b <<= 2;
                            b2 <<= 2;
                        }
                        x += 4;
                        break;

                    case 39: // mcp
                        var b2 = data[src + offset];
                        for (var j = 0; j < 4; j++) {
                            var p0 = pal0[(b >> 6) & 3];
                            var p1 = pal1[(b2 >> 6) & 3];
                            buf[dst++] = avg(p0, p1);
                            b <<= 2;
                            b2 <<= 2;
                        }
                        x += 4;
                        break;

                    case 38: // tip!
                        var luma = data[src];
                        var luma10 = data[src + offset];
                        var chroma = data[src + offset2];          // chroma

                        var l0 = ((luma >> 4) + lastp) >> 1;
                        var l1 = ((luma >> 4) + hip[luma10 >> 4]) >> 1;
                        var l2 = ((luma & 0xF) + hip[luma10 >> 4]) >> 1;
                        lastp = hip[luma10 & 0xF];
                        var l3 = ((luma & 0xF) + lastp) >> 1;

                        var c0 = chroma & 0xF0;
                        var c1 = (chroma << 4) & 0xF0;

                        buf[dst++] = ap[c0 | l0];
                        buf[dst++] = ap[c0 | l1];
                        buf[dst++] = ap[c1 | l2];        // 9=16 greys,10=index,11=chroma
                        buf[dst++] = ap[c1 | l3];
                        x += 4;
                        break;
                }
                src++;
            }
            if (gr == 32 && offset == 40)
                src += 40;
        }

        var brightness = 1;
        switch (ext) {
            case "rip_mode_16": brightness = 3; break;    // rip_mode_16,raw is dark, boost it please
            case "raw":
            case "mcp":
                brightness = 2;
                break;
        }
        rgb2canvas(canvas, buf, width, height, 320 / width, brightness);
        return [320 / canvas.width * 2, 192 / canvas.height * 2];
    }

    //===================================================================================================
    // UI
    //===================================================================================================

    // make an atari line of text to look like dir

    function set_class(el, cname, on) { //(PVB COM) Add or remove a Class Property
    //(PVB COM) "el" is a class like "nav#toc"; cname is a class property like "over"
    // or for floater : "span#A" is a class; "dimmed" is a class property
    // when "on" is true, then class property is added, removed otherwise
        if (on)
            el.classList.add(cname);
        else
            el.classList.remove(cname);
    }

    function draw_line(id, txt, recovered, is_dir) {
        var c = _q(id);
        c.width = txt.length * 8;
        c.height = 8;
        var ctx = c.getContext('2d');
        draw(ctx, txt, 0, 0);
        resize_parent(c, 2);
        set_class(c, "recovered", recovered);
        set_class(c, "isdir", is_dir);
    }

    // Simple radio and check buttons
    var _radios = {};
    var _checks = {};
    function radio_init(name, values, value, col) { //(PVB ADD) 'col' for direction of display radio: if 'col' is true, then add <div> over <span>
        var cur = _radios[name] ? _radios[name].value : 0;
        value = value || cur;
        var s = '';
        for (var i = 0; i < values.length; i++)
            s += (col ? "<div class='radio'>" : "") + `<span onclick="radio_click('${name}',${i})" ${i == value ? "class='hilite'" : ""}>${values[i]}</span>` + (col ? "</div>" : "");
        _radios[name] = { values: values, value: value };
        return s;
    }

    function radio_click(name, n) {
        var v = _radios[name];
        if (n != -1 && n != v.value) {
            v.value = n;
            radio_changed(name, n);
        }
    }

    //function radio_changed(name, v) { //(PVB MOD) 'v' is not used
    function radio_changed(name) {
        switch (name) {
            case "atarichlist": //(PVB ADD) the radio button for selecting the font display
                _bShowWebChar = _radios["atarichlist"].value == 1;
                _bShowAtariFont = _radios["atarichlist"].value == 2;
            case "layout":
            case "dither":
            case "scheme":
            case "distance":
                refresh();
                break;
        }
    }

    function check_init(name, dname) {
        _checks[name] = _checks[name] | 0; //(PVB MOD) '||' previously
        var cur = _checks[name] ? _checks[name] : 0;
        return `<span id="${name}" onclick="check_click('${name}')" ${cur ? "class='hilite'" : ""}>${dname}</span>`; //(PVB ADD) add the name id
    }

    //function check_click(name, n) { //(PVB MOD) 'n' is not used
    function check_click(name) {
        _checks[name] ^= 1;
        check_changed(name, _checks[name]);
    }

    //function check_changed(name, v) { //(PVB MOD) 'v' is not used
    function check_changed(name, v) {
        switch (name) {
            case "indent":
            case "multicolor":
                refresh();
                break;
            //(PVB ADD) the radio check buttons for selecting the display options
            case "cShowA5200Eq":
                _bShowA5200Equates = _checks["cShowA5200Eq"]; //whatever was the value of _shown.a5200eq, we change the equate
                refresh();
                break;
            default: //we assume here that one clicks on a 'display option check' button, so we update the global _bShow flags
                _bShowDisLinks = _checks["cShowDisLinks"];
                _bShowAtasciiChar = _checks["cShowAtasciiChar"];
                _bShowDispChar = _checks["cShowDispChar"];
                _bShowDisFlags = _checks["cShowDisFlags"];
                _bShowDisBRK = _checks["cShowDisBRK"];
                _bShowROMBank = _checks["cShowROMBank"];
                refresh();
        }
    }

    function resize_parent(e, sx, sy) {
        sy = sy || sx;
        e.style.transform = `scale(${sx},${sy})`;
        e.parentNode.style.width = e.width * sx + "px";
        e.parentNode.style.height = e.height * sy + "px";
    }

    // U+200B ZERO-WIDTH SPACE after ':',',''
    function atari2ascii(lst, insert_breaks) { //called by show_ataritext() to convert atari char byte into relevant Atari ascii char for the editor()
        var r = [];
        var wbr = insert_breaks ? String.fromCharCode(0x200B) : null; // insert_breaks = insert ZERO-WIDTH SPACE for indentation
        lst.forEach(src => {
            var dst = '';
            for (var i = 0; i < src.length; i++) {
                var c = src.charCodeAt(i);
                switch (c) {
                    case 0x7B: // { in ascii, spade in atari
                    case 0x7D: // } in ascii, upleft in atari
                    case 0x7E: // ~ in ascii, left triangle in atari
                    case 0x7F: // right triangle in atari
                        c += 0xE000; //(PVB COM) U+E0xx is the specific Atari Chartset in the css embedded font style
                        break;
                    case 0x20: //(PVB ADD) 0x20 space char
                        //c = 0x00A0; // the 0x20 space char is set to "&nbsp;" (0xA0) which has correct width
                        c +=  0xE000; //or use de 0x20 from the ATARI Charset for correct space width display ?
                        break;
                    default:
                        if (c < 0x20 || c > 0x7E)   // keep printing chars whole 
                            c += 0xE000;
                }
                c = String.fromCharCode(c);
                dst += c;
                //(PVB COM) add the ZERO-WIDTH SPACE after punctuation mark
                if (wbr && (c == ':' || c == ',' || c == ';')) //(PVB ADD) the ";" semi-colon
                    dst += wbr;
            }
            r.push(dst);
        })
        return r;
    }
    //(PVB ADD) the ascii2print(lst) function to get the atari displayed text from the editor() and convert it to standard UTF-8 text file on OS Client (used by save() function)
    function ascii2print(lst) {
        var s = []; //main string
        lst.forEach(src => {
            for (var i = 0; i < src.length; i++) {
                var c = src.charCodeAt(i); //get the UTF-16 value for the char
                if (c == 0x200B) //keep the ZERO-WIDTH SPACE set by the indent button
                    c = String.fromCharCode(c);
                //or do nothing in case of use of 0xE020 instead of "0xA0" &nbsp
                else //other char
                    c = escAtasciiChar(c & 0xFF); //cancel the +E0xx Atari font code value for a standard ascii char
                s.push(c); //push the char in main string
            }
            s.push('\n'); //add a line feed UTF char for each "lst" line
        });
        return s.join(''); //create and return a big UTF string of all the text
    }
    //(PVB MOD) the ascii2atari(lst) function to get the atari displayed text from the editor and convert it to a buffer of Atari bytes
    function ascii2atari(lst) { //used by function get_ataritext() to convert lst text (from editor()) into atari ascii ATASCII char code
        var d = []; //data buffer, for the Save as Atari LST file
        lst.forEach(src => { //"lst" is an array of strings (one string for each lines)
            for (var i = 0; i < src.length; i++) {
                c = src.charCodeAt(i); ////get the UTF-16 value for the char. Atari chars are at UTF+E000 to UTF+E0FF special page.
                if (c == 0x2009 || c == 0x00A0) c = 0x20; //editor() may use Thin Space (0x2009) and No-Break Space (NBSP) (0x00A0) so convert them to normal space (0x0020)
                if (c != 0x200B) //if ZERO WIDTH SPACE added in the editor() by the indent button, do nothing (don't add it in the data buffer)
                    d.push(c & 0xFF); //else push the Atari ascii code byte in the buffer (= remove 0xE0xx of UTF char code)
            }
            d.push(0x9B); //add the End-of-Line (RETURN)(EOL) 0x9B atari char for each "lst" line
        });
        return new Uint8Array(d); //return an array of bytes from all the text
    }

    function editor() {
        return _q("#atari_text");
    }

    function get_ataritext() { //used to get text from editor(), for saving purpose, in function save(as_lst)
        return ascii2atari(editor().innerText.split("\n"));
    }

    var _gs = window.getSelection || document.getSelection;
    function get_selection() {
        return _gs().toString();
    }

    function invert_selection() {
        keyboard(get_selection(), true);
    }

    //(PVB COM) disassemble_selection() is used only to disassemble the Atari text selection in the displayed Atari text area
    //(PVB TODO) improve this feature with several line selection in Hexdump()
    function disassemble_selection() { 
        var txt = get_selection();
        if (!txt || !txt.length) //(PVB COM) No text is selected so exit
            return;

        var asm = [];
        for (var i = 0; i < txt.length; i++)
            asm.push(txt.charCodeAt(i) & 0xFF); //(PVB COM) Convert Atari selected text to byte numbers
        var dis = _q(".disassembly"); //new window with "disassembly" class
        draggable(dis, _shown.name + " disassembly"); //_shown.name = file name (DOS or disk) displayed
        _h("#disassembly", xex_dump("asm", asm, 0, asm.length, "SEL")); //(PVB ADD) "SEL" for 'disassemble selection'

        var r = _gs().getRangeAt(0).getBoundingClientRect(); //(PVB COM) "r" is a DOMRect
        var dx = (dis.width - r.width) / 2;
        dis.style.left = ((dx | 0) + r.left) + "px";
        dis.style.top = r.bottom + 4 + "px";
        dis.hidden = false; //show the window
        editor().focus();
    }

    function selection_change() { //(PVB COM) Function used to monitor where is the mouse pointer and if text is selected
        var el = document.activeElement;
        if (el.id == "atari_text") {
            var txt = get_selection();
            var sel = txt && txt.length;
            //(PVB COM) if we have a text selection, then activate tool "I" for inverting text; and "D" for disassembling text  
            set_tool("I", sel);  // we have a selection
            set_tool("D", sel);
        }
    }

    function keyboard(txt, invert) {
        var e = editor();
        if (!e)
            return;

        if (!txt) {
            e.focus();
            return;
        }

        // same in ATASCII as ASCII
        // will cause unescaping of <>& etc
        function common_chars(s) {
            var dst = '';
            for (var i = 0; i < s.length; i++) {
                var c = s.charCodeAt(i);
                if ((c & 0xFF) > 0x20 && ((c & 0xFF) < 0x7B)) //PVB TODO WIP 0x20 is not a normal char !
                    c &= 0xFF;
                dst += String.fromCharCode(c);
            }
            return dst;
        }

        if (invert) {
            txt = get_selection();
            var s = '';
            for (var i = 0; i < txt.length; i++) {
                var c = txt.charCodeAt(i);
                c = ((c < 0x20) || (c == 0x200B)) ? c : (c ^ 0x80) | 0xE000;
                s += String.fromCharCode(c);
            }
            txt = s;
        }
        txt = common_chars(txt);

        var range = _gs().getRangeAt(0);
        if (invert)
            range.deleteContents();
        else
            range.collapse();

        // insert
        if (txt.indexOf('\n') != -1) {  // need to deal with newlines and insert the as breaks
            var lst = txt.split('\n');
            var n = [];
            for (var i = 0; i < lst.length; i++) {
                n.push(document.createTextNode(lst[i]));
                if (i != lst.length - 1)
                    n.push(document.createElement("br"));
            }
            var i = n.length;
            while (i--)
                range.insertNode(n[i]);
            range.setEndAfter(n[n.length - 1]);
        } else
            range.insertNode(document.createTextNode(txt));
        e.focus();
    }

    function show_ataritext(f, lst) {
        //called by show_txt() with argument (f, t) after buffer conversion by "t = ataritext(f.data, 0, f.data.length)""
        //called by show_bas(f) with argument (f, t ? t.listing : parse_failed(f)) after buffer conversion by "t = ataribasic(f.data, 0, f.data.length)""
        //called by show_m65(f) with argument (f, asm ? asm : parse_failed(f)) after buffer conversion by "asm = mac65(f.data, 0, f.data.length)"
        //"lst" is an array of strings (one string for each lines)
        render_file(f);
        var layout = _radios["layout"].value; //(PVB COM) 0 = 38, 1 = 40, 2 = 80, 3 = Wide
        var idnt = (f.ext == "bas") ? _checks['indent'] : 0; //(PVB ADD) idnt is taken from the button, only if basic
        var cols = layout < 2 ? 40 : 80;
        if (layout == 3)
            lst.forEach(s => cols = Math.max(cols, s.length));      
        lst = atari2ascii(lst, idnt); //(PVB MOD) previously//lst = atari2ascii(lst, f.ext == "bas")//idnt is now taken from the button
        var ta = editor(); //the editor blue window with atari text, HTML id="#atari_text"
        if (layout == 0) {
            ta.style.paddingLeft = '32px';
            cols -= 2;
        }
        else
            ta.style.paddingLeft = '0px';
        if (layout == 3)
            ta.style.fontSize = ta.style.lineHeight = '8px';
        else {
            ta.style.fontSize = ta.style.lineHeight = '16px';
            ta.style.minWidth = ta.style.maxWidth = (cols * 16) + "px";
        }
        ta.innerText = lst.join('\n');
    }

    // old fashioned font
    function show_font(f, lst, font, palette) {
        render_file(f);

        var fcanvas;
        if (font)
            fcanvas = get_font(font, palette);

        var layout = _radios["layout"].value;
        var cols = layout < 2 ? 40 : 80;
        var margin = layout == 0 ? 2 : 0;
        var wrap = [];

        if (layout == 3) {  // Don't wrap at all
            lst.forEach(line => cols = Math.max(line.length, cols));
            cols += 2 * margin;
            wrap = lst;
        } else {
            var wrap = [];
            lst.forEach(s => {
                while (s.length > (cols - margin)) {
                    wrap.push(s.substr(0, (cols - margin)));
                    s = s.substr((cols - margin));
                }
                wrap.push(s);
            });
        }

        var c = _q("#show");
        c.width = cols * 8;
        c.height = wrap.length * 8 + 16;
        var ctx = c.getContext('2d');
        ctx.webkitImageSmoothingEnabled = false;
        var bg = atari_palette_rgb[palette ? palette[0] : 128 + 20];
        ctx.fillStyle = '#' + hex(bg, 6); // "rgba(17,59,128,1)";
        ctx.fillRect(0, 0, c.width, c.height);
        for (var y = 0; y < wrap.length; y++)
            draw(ctx, wrap[y], margin, y + 1, fcanvas);
        resize_parent(c, layout == 3 ? 1 : 2);
    }

    var _font = [ //as stored in ROM memory of 800/XL/XE ROM like in $E000-E3FF 
        // atari 128 rom font 
        // 32..95
        // 0..31
        // 96..128
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x00,
        0x00, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x66, 0xff, 0x66, 0x66, 0xff, 0x66, 0x00,
        0x18, 0x3e, 0x60, 0x3c, 0x06, 0x7c, 0x18, 0x00,
        0x00, 0x66, 0x6c, 0x18, 0x30, 0x66, 0x46, 0x00,
        0x1c, 0x36, 0x1c, 0x38, 0x6f, 0x66, 0x3b, 0x00,
        0x00, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x0e, 0x1c, 0x18, 0x18, 0x1c, 0x0e, 0x00,
        0x00, 0x70, 0x38, 0x18, 0x18, 0x38, 0x70, 0x00,
        0x00, 0x66, 0x3c, 0xff, 0x3c, 0x66, 0x00, 0x00,
        0x00, 0x18, 0x18, 0x7e, 0x18, 0x18, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30,
        0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00,
        0x00, 0x06, 0x0c, 0x18, 0x30, 0x60, 0x40, 0x00,
        0x00, 0x3c, 0x66, 0x6e, 0x76, 0x66, 0x3c, 0x00,
        0x00, 0x18, 0x38, 0x18, 0x18, 0x18, 0x7e, 0x00,
        0x00, 0x3c, 0x66, 0x0c, 0x18, 0x30, 0x7e, 0x00,
        0x00, 0x7e, 0x0c, 0x18, 0x0c, 0x66, 0x3c, 0x00,
        0x00, 0x0c, 0x1c, 0x3c, 0x6c, 0x7e, 0x0c, 0x00,
        0x00, 0x7e, 0x60, 0x7c, 0x06, 0x66, 0x3c, 0x00,
        0x00, 0x3c, 0x60, 0x7c, 0x66, 0x66, 0x3c, 0x00,
        0x00, 0x7e, 0x06, 0x0c, 0x18, 0x30, 0x30, 0x00,
        0x00, 0x3c, 0x66, 0x3c, 0x66, 0x66, 0x3c, 0x00,
        0x00, 0x3c, 0x66, 0x3e, 0x06, 0x0c, 0x38, 0x00,
        0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00,
        0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x30,
        0x06, 0x0c, 0x18, 0x30, 0x18, 0x0c, 0x06, 0x00,
        0x00, 0x00, 0x7e, 0x00, 0x00, 0x7e, 0x00, 0x00,
        0x60, 0x30, 0x18, 0x0c, 0x18, 0x30, 0x60, 0x00,
        0x00, 0x3c, 0x66, 0x0c, 0x18, 0x00, 0x18, 0x00,
        0x00, 0x3c, 0x66, 0x6e, 0x6e, 0x60, 0x3e, 0x00,
        0x00, 0x18, 0x3c, 0x66, 0x66, 0x7e, 0x66, 0x00,
        0x00, 0x7c, 0x66, 0x7c, 0x66, 0x66, 0x7c, 0x00,
        0x00, 0x3c, 0x66, 0x60, 0x60, 0x66, 0x3c, 0x00,
        0x00, 0x78, 0x6c, 0x66, 0x66, 0x6c, 0x78, 0x00,
        0x00, 0x7e, 0x60, 0x7c, 0x60, 0x60, 0x7e, 0x00,
        0x00, 0x7e, 0x60, 0x7c, 0x60, 0x60, 0x60, 0x00,
        0x00, 0x3e, 0x60, 0x60, 0x6e, 0x66, 0x3e, 0x00,
        0x00, 0x66, 0x66, 0x7e, 0x66, 0x66, 0x66, 0x00,
        0x00, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x7e, 0x00,
        0x00, 0x06, 0x06, 0x06, 0x06, 0x66, 0x3c, 0x00,
        0x00, 0x66, 0x6c, 0x78, 0x78, 0x6c, 0x66, 0x00,
        0x00, 0x60, 0x60, 0x60, 0x60, 0x60, 0x7e, 0x00,
        0x00, 0x63, 0x77, 0x7f, 0x6b, 0x63, 0x63, 0x00,
        0x00, 0x66, 0x76, 0x7e, 0x7e, 0x6e, 0x66, 0x00,
        0x00, 0x3c, 0x66, 0x66, 0x66, 0x66, 0x3c, 0x00,
        0x00, 0x7c, 0x66, 0x66, 0x7c, 0x60, 0x60, 0x00,
        0x00, 0x3c, 0x66, 0x66, 0x66, 0x6c, 0x36, 0x00,
        0x00, 0x7c, 0x66, 0x66, 0x7c, 0x6c, 0x66, 0x00,
        0x00, 0x3c, 0x60, 0x3c, 0x06, 0x06, 0x3c, 0x00,
        0x00, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00,
        0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7e, 0x00,
        0x00, 0x66, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x00,
        0x00, 0x63, 0x63, 0x6b, 0x7f, 0x77, 0x63, 0x00,
        0x00, 0x66, 0x66, 0x3c, 0x3c, 0x66, 0x66, 0x00,
        0x00, 0x66, 0x66, 0x3c, 0x18, 0x18, 0x18, 0x00,
        0x00, 0x7e, 0x0c, 0x18, 0x30, 0x60, 0x7e, 0x00,
        0x00, 0x1e, 0x18, 0x18, 0x18, 0x18, 0x1e, 0x00,
        0x00, 0x40, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x00,
        0x00, 0x78, 0x18, 0x18, 0x18, 0x18, 0x78, 0x00,
        0x00, 0x08, 0x1c, 0x36, 0x63, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00,
        0x00, 0x36, 0x7f, 0x7f, 0x3e, 0x1c, 0x08, 0x00,
        0x18, 0x18, 0x18, 0x1f, 0x1f, 0x18, 0x18, 0x18,
        0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
        0x18, 0x18, 0x18, 0xf8, 0xf8, 0x00, 0x00, 0x00,
        0x18, 0x18, 0x18, 0xf8, 0xf8, 0x18, 0x18, 0x18,
        0x00, 0x00, 0x00, 0xf8, 0xf8, 0x18, 0x18, 0x18,
        0x03, 0x07, 0x0e, 0x1c, 0x38, 0x70, 0xe0, 0xc0,
        0xc0, 0xe0, 0x70, 0x38, 0x1c, 0x0e, 0x07, 0x03,
        0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f, 0xff,
        0x00, 0x00, 0x00, 0x00, 0x0f, 0x0f, 0x0f, 0x0f,
        0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe, 0xff,
        0x0f, 0x0f, 0x0f, 0x0f, 0x00, 0x00, 0x00, 0x00,
        0xf0, 0xf0, 0xf0, 0xf0, 0x00, 0x00, 0x00, 0x00,
        0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0xf0, 0xf0, 0xf0, 0xf0,
        0x00, 0x1c, 0x1c, 0x77, 0x77, 0x08, 0x1c, 0x00,
        0x00, 0x00, 0x00, 0x1f, 0x1f, 0x18, 0x18, 0x18,
        0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00,
        0x18, 0x18, 0x18, 0xff, 0xff, 0x18, 0x18, 0x18,
        0x00, 0x00, 0x3c, 0x7e, 0x7e, 0x7e, 0x3c, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
        0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0,
        0x00, 0x00, 0x00, 0xff, 0xff, 0x18, 0x18, 0x18,
        0x18, 0x18, 0x18, 0xff, 0xff, 0x00, 0x00, 0x00,
        0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0,
        0x18, 0x18, 0x18, 0x1f, 0x1f, 0x00, 0x00, 0x00,
        0x78, 0x60, 0x78, 0x60, 0x7e, 0x18, 0x1e, 0x00,
        0x00, 0x18, 0x3c, 0x7e, 0x18, 0x18, 0x18, 0x00,
        0x00, 0x18, 0x18, 0x18, 0x7e, 0x3c, 0x18, 0x00,
        0x00, 0x18, 0x30, 0x7e, 0x30, 0x18, 0x00, 0x00,
        0x00, 0x18, 0x0c, 0x7e, 0x0c, 0x18, 0x00, 0x00,
        0x00, 0x18, 0x3c, 0x7e, 0x7e, 0x3c, 0x18, 0x00,
        0x00, 0x00, 0x3c, 0x06, 0x3e, 0x66, 0x3e, 0x00,
        0x00, 0x60, 0x60, 0x7c, 0x66, 0x66, 0x7c, 0x00,
        0x00, 0x00, 0x3c, 0x60, 0x60, 0x60, 0x3c, 0x00,
        0x00, 0x06, 0x06, 0x3e, 0x66, 0x66, 0x3e, 0x00,
        0x00, 0x00, 0x3c, 0x66, 0x7e, 0x60, 0x3c, 0x00,
        0x00, 0x0e, 0x18, 0x3e, 0x18, 0x18, 0x18, 0x00,
        0x00, 0x00, 0x3e, 0x66, 0x66, 0x3e, 0x06, 0x7c,
        0x00, 0x60, 0x60, 0x7c, 0x66, 0x66, 0x66, 0x00,
        0x00, 0x18, 0x00, 0x38, 0x18, 0x18, 0x3c, 0x00,
        0x00, 0x06, 0x00, 0x06, 0x06, 0x06, 0x06, 0x3c,
        0x00, 0x60, 0x60, 0x6c, 0x78, 0x6c, 0x66, 0x00,
        0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00,
        0x00, 0x00, 0x66, 0x7f, 0x7f, 0x6b, 0x63, 0x00,
        0x00, 0x00, 0x7c, 0x66, 0x66, 0x66, 0x66, 0x00,
        0x00, 0x00, 0x3c, 0x66, 0x66, 0x66, 0x3c, 0x00,
        0x00, 0x00, 0x7c, 0x66, 0x66, 0x7c, 0x60, 0x60,
        0x00, 0x00, 0x3e, 0x66, 0x66, 0x3e, 0x06, 0x06,
        0x00, 0x00, 0x7c, 0x66, 0x60, 0x60, 0x60, 0x00,
        0x00, 0x00, 0x3e, 0x60, 0x3c, 0x06, 0x7c, 0x00,
        0x00, 0x18, 0x7e, 0x18, 0x18, 0x18, 0x0e, 0x00,
        0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3e, 0x00,
        0x00, 0x00, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x00,
        0x00, 0x00, 0x63, 0x6b, 0x7f, 0x3e, 0x36, 0x00,
        0x00, 0x00, 0x66, 0x3c, 0x18, 0x3c, 0x66, 0x00,
        0x00, 0x00, 0x66, 0x66, 0x66, 0x3e, 0x0c, 0x78,
        0x00, 0x00, 0x7e, 0x0c, 0x18, 0x30, 0x7e, 0x00,
        0x00, 0x18, 0x3c, 0x7e, 0x7e, 0x18, 0x3c, 0x00,
        0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
        0x00, 0x7e, 0x78, 0x7c, 0x6e, 0x66, 0x06, 0x00,
        0x08, 0x18, 0x38, 0x78, 0x38, 0x18, 0x08, 0x00,
        0x10, 0x18, 0x1c, 0x1e, 0x1c, 0x18, 0x10, 0x00,
    ];

    function makefont() {  //(PVB COM) //TODO// function empty and not used... should be a futur to do stuff

    }


    //===================================================================================================
    //  Drag and drop

    function drop_init(el, onfile, all_done) {
        
        function over(b) {
            set_class(_q("#toc"), "over", b); //(PVB COM) used to add "over" to the "nav#toc" class
        }

        function handleFiles(files) {

            function readAsArrayBuffer(file) {
                return new Promise((resolve, reject) => {
                    const fr = new FileReader();
                    fr.onerror = reject;
                    fr.onload = function (evt) {
                        onfile(file, evt.target.result);
                        resolve(fr.result);
                    }
                    fr.readAsArrayBuffer(file);
                });
            }

            // Load all the files, callback when done
            Promise.all(Array.prototype.map.call(files, readAsArrayBuffer))
                .then(urls => {
                    all_done();
                })
                .catch(error => {
                    console.log(error);
                });
        }

        function handleFileSelect(evt) {
            evt.stopPropagation();
            evt.preventDefault();
            over(0);
            handleFiles(evt.dataTransfer.files);

            // check for dragged urls of images
            var items = evt.dataTransfer.items;
            for (var i = 0; i < items.length; i++) {
                if (items[i].kind == 'string' && items[i].type == 'text/uri-list') {
                    items[i].getAsString(s => console.log(s));  // cross origin will make this useless
                }
            }
        }

        function handleDragOver(evt) {
            evt.stopPropagation();
            evt.preventDefault();
            evt.dataTransfer.dropEffect = 'copy'; // Explicitly show this is a copy.
        }
        //(PVB COM) drop_ini starts here
        el.addEventListener('dragover', handleDragOver, false);
        el.addEventListener('drop', handleFileSelect, false);
        el.addEventListener('dragenter', e => over(1), false); //(PVB) 'e' is a DragEvent
        el.addEventListener('dragleave', e => over(0), false); //(PVB) 'e' is a DragEvent

        _q("#fe").addEventListener("change", e => handleFiles(_q("#fe").files), false);

    }

    //===================================================================================================
    // http://www.atarimax.com/jindroush.atari.org/afmtbas.html
    // Disassemble m65

    var _mac65_table1 = [
        "ERROR -", ".IF", ".ELSE", ".ENDIF", ".MACRO", ".ENDM", ".TITLE", "",
        ".PAGE", ".WORD", ".ERROR", ".BYTE", ".SBYTE", ".DBYTE", ".END", ".OPT",
        ".TAB", ".INCLUDE", ".DS", ".ORG", ".EQU", "BRA", "TRB", "TSB",
        ".FLOAT", ".CBYTE", ";", ".LOCAL", ".SET", "*=", "=", ".=",
        "JSR", "JMP", "DEC", "INC", "LDX", "LDY", "STX", "STY",
        "CPX", "CPY", "BIT", "BRK", "CLC", "CLD", "CLI", "CLV",
        "DEX", "DEY", "INX", "INY", "NOP", "PHA", "PHP", "PLA",
        "PLP", "RTI", "RTS", "SEC", "SED", "SEI", "TAX", "TAY",
        "TSX", "TXA", "TXS", "TYA", "BCC", "BCS", "BEQ", "BMI",
        "BNE", "BPL", "BVC", "BVS", "ORA", "AND", "EOR", "ADC",
        "STA", "LDA", "CMP", "SBC", "ASL", "ROL", "LSR", "ROR",
        "", "STZ", "DEA", "INA", "PHX", "PHY", "PLX", "PLY",
    ];

    var _mac65_table2 = [
        null, null, null, null, null, "", "", "",
        "", null, "", "%$", "%", "*", null, null,
        null, null, "+", "-", "*", "/", "&", null,
        "=", "<=", ">=", "<>", ">", "<", "-", "[",
        "]", null, null, null, "!", "^", null, "\\",
        null, null, null, null, null, null, null, ".REF",
        ".DEF", ".NOT", ".AND", ".OR", "<", ">", ",X)", "),Y",
        ",Y", ",X", ")", "", null, ",", "#", "A",
        "(", '"', null, null, null, "NO", "OBJ", "ERR",
        "EJECT", "LIST", "XREF", "MLIST", "CLIST", "NUM", null, null,
    ];

    function mac65(a, i, len) {
        if (le16(a, i) != 0xFEFE)
            return null;
        if (le16(a, i + 2) != (len - 4))
            return null;
        var end = i + len;
        i += 4;

        var indent = 5;
        var asm = [];
        while (i < len) {
            var line_number = le16(a, i);
            var line_end = i + a[i + 2];
            i += 3;

            var s = line_number + ' ';
            var pad = ('' + line_number).length + indent;
            var c = a[i++];
            if (c & 0x80) {
                c -= 0x80;  // label
                while (c--)
                    s += String.fromCharCode(a[i++]);
                if (i == line_end) {
                    asm.push(s);
                    continue;
                }
                c = a[i++];
            } else if (c == 0 || c == 88) {
                while (i < line_end)
                    s += String.fromCharCode(a[i++]);   // raw
                asm.push(s);
                continue;
            } else if (c == 1) {
                indent++;           // IF
            } else if (c == 3) {
                indent--;           // ENDIF
            }

            if (c >= 96)
                return null;
            while (s.length < pad)
                s += ' ';
            if (s[s.length - 1] != ' ')
                s += ' ';
            s += _mac65_table1[c] + ' ';   // token

            while (i < line_end) {
                c = a[i++];
                switch (c) {
                    case 5: s += '$' + hex(le16(a, i), 4); i += 2; break;
                    case 6: s += '$' + hex(a[i++]); break;
                    case 7: s += le16(a, i); i += 2; break;
                    case 8: s += a[i++]; break;
                    case 10: s += "'" + String.fromCharCode(a[i++]); break;
                    case 59:
                        s += ' ';
                        while (i < line_end)
                            s += String.fromCharCode(a[i++]);   // comment
                        break;
                    default:
                        if (c & 0x80) {
                            c -= 0x80;
                            while (c--)
                                s += String.fromCharCode(a[i++]);
                        } else {
                            var t = _mac65_table2[c];
                            if (!t)
                                return null;
                            s += t;
                            if (c > 64)
                                s += ' ';   // not sure all of all the padding rules
                        }
                        break;
                }
            }
            asm.push(s);
        }
        return asm;
    }

    //===================================================================================================
    // http://www.atarimax.com/jindroush.atari.org/afmtbas.html
    // Disassemble atari basic

    var _basic_commands = [
        // 56 in classic Basic
        "REM", "DATA", "INPUT", "COLOR", "LIST", "ENTER", "LET", "IF", "FOR", "NEXT", "GOTO",
        "GO TO", "GOSUB", "TRAP", "BYE", "CONT", "COM", "CLOSE", "CLR", "DEG", "DIM", "END",
        "NEW", "OPEN", "LOAD", "SAVE", "STATUS", "NOTE", "POINT", "XIO", "ON", "POKE", "PRINT",
        "RAD", "READ", "RESTORE", "RETURN", "RUN", "STOP", "POP", "?", "GET", "PUT", "GRAPHICS",
        "PLOT", "POSITION", "DOS", "DRAWTO", "SETCOLOR", "LOCATE", "SOUND", "LPRINT", "CSAVE",
        "CLOAD", "LET_", "ERROR",

        // Turbo Basic
        "DPOKE ", "MOVE ", "-MOVE ", "*F", "REPEAT ", "UNTIL ", "WHILE ", "WEND ",
        "ELSE ", "ENDIF ", "BPUT ", "BGET ", "FILLTO ", "DO ", "LOOP ", "EXIT ",
        "DIR ", "LOCK ", "UNLOCK ", "RENAME ", "DELETE ", "PAUSE ", "TIME$= ", "PROC ",
        "EXEC ", "ENDPROC ", "FCOLOR ", "*L ",
        "------------------------------",
        "RENUM ", "DEL ", "DUMP ",
        "TRACE ", "TEXT ", "BLOAD ", "BRUN ", "GO# ", "# ", "*B ", "PAINT ",
        "CLS ", "DSOUND ", "CIRCLE ", "%PUT ", "%GET "
    ];

    var _basic_operators = [
        "_0", "_1", "_2", "_3", "_4", "_5", "_6", "_7", "_8", "_9", "_A", "_B", "_C", "_D",
        "NCONST", "SCONST", "NOUSE", "NOUSE", ",", "$", ":", ";", "EOL", " GOTO ", " GOSUB ", " TO ",
        " STEP ", " THEN ", "#", "<=", "<>", ">=", "<", ">", "=", "^", "*", "+", "-", "/", " NOT ", " OR ", " AND ",
        "(", ")", "=", "=", "<=", "<>", ">=", "<", ">", "=", "+", "-", "(", "(", "(", "(", "(", ",",
        "STR$", "CHR$", "USR", "ASC", "VAL", "LEN", "ADR", "ATN", "COS", "PEEK", "SIN", "RND", "FRE",
        "EXP", "LOG", "CLOG", "SQR", "SGN", "ABS", "INT", "PADDLE", "STICK", "PTRIG", "STRIG",

        // Turbo Basic
        "DPEEK", "&", "!", "INSTR", "INKEY$", " EXOR ", "HEX$", "DEC",
        " DIV ", "FRAC", "TIME$", "TIME", " MOD ", "EXEC ", "RND", "RAND",
        "TRUNC", "%0", "%1", "%2", "%3", "GO# ", "UINSTR", "ERR", "ERL"
    ];

    function ataribasic(a, i, len) {
        var indenting = _checks['indent']; //identing == 0 (off) or 1 (on)
        var b = {
            lomem: le16(a, i + 0),   // should be zero
            vnt: le16(a, i + 2),     // start of variable name table
            vnte: le16(a, i + 4),    // end of variable name table
            vvt: le16(a, i + 6),     // start of variable values table
            stmtab: le16(a, i + 8),  // start of token area
            stmcur: le16(a, i + 10), // current line (line 32768)
            starp: le16(a, i + 12),  // end of token area, start of stacks

            variable_names: [],
            variable_values: [],
            statements: []
        }

        function failed(reason) {
            reason = reason || "Bytes don't look like Basic";
            console.log("ataribasic (): =>"); //(PVB ADD)
            console.log(reason);
            console.log(b);
            console.log(listing);
            console.log("*end of ataribasic ()*"); //(PVB ADD)
            return null;
        }

        var origin = b.vnt - b.lomem - 14; // file offsets are weird?
        if (origin < 0)
            return failed();
        b.vnt -= origin;
        b.vnte -= origin;
        b.vvt -= origin;
        b.stmtab -= origin;
        b.stmcur -= origin;
        b.starp -= origin;
        if (b.vnt > b.vnte || b.vnte > b.vvt || b.vvt > b.stmtab || b.stmtab > b.stmcur || b.stmcur > b.starp)
            return failed();    // Not a basic file?

        function get_string(data, si, len) {
            var s = '';
            while (len--) {
                var c = String.fromCharCode(data[si++]);
                s += c;
                if (c == '"')
                    s += c;
            }
            return s;
        }

        function bcd(data, bi) {
            var n = 0;
            var e = data[bi++];
            if (e == 0)
                return 0;
            for (var j = 0; j < 5; j++) {
                var c = data[bi++];
                n *= 10;
                n += c >> 4;
                n *= 10;
                n += c & 0xF;
            }
            e = (e - 68) * 2;

            switch (e) {	// Math.pow was not producing integers
                case -1: return n / 10;
                case -2: return n / 100;
                case -3: return n / 1000;
                case -4: return n / 10000;
            }
            return n * Math.pow(10, e);
        }

        var vnt_begin = i + b.vnt;
        var vnt_end = i + b.vnte;
        var n = '';
        var nmap = {};
        var ncount = 0;
        for (var j = vnt_begin; j < vnt_end; j++) {
            if ((a[j] & 0x7F) < 0x21 ) return failed("Invalid Basic variable name"); //(PVB ADD)
            n += String.fromCharCode(a[j] & 0x7F);
            if (a[j] & 0x80) {
                if (n.length && n[n.length - 1] == '(')
                    n = n.substr(0, n.length - 1);	// 
                if (nmap[n])
                    console.log(`ataribasic(): reapeated variable name '${n}'`);
                nmap[n] = 1;
                ncount++;
                b.variable_names.push(n);
                n = '';
            }
        }

        if (Object.keys(nmap).length == 1) {
            console.log("ataribasic(): resetting variable names");
            b.variable_names = [];  // name table was set to the same value: reset it
        }

        var vvt_begin = i + b.vvt;	// NOT SURE WHY THESE ARE +1
        var tokens_begin = i + b.stmtab;
        var vid = 0;
        for (var j = vvt_begin; j < tokens_begin; j += 8) {
            var v = { name: b.variable_names[a[j + 1]] };

            if (!v.name) {  // someone got rid of all the variable names. make new ones
                var ch = String.fromCharCode(65 + (vid % 26));    // 'A'
                var n = Math.floor(vid++ / 26);
                if (n)
                    ch += n + 1;                              // A,B,C ... A2,B2...
                switch (a[j]) {
                    case 0x80:
                    case 0x81:
                        ch += '$';
                        break;
                }
                b.variable_names[a[j + 1]] = v.name = ch;     // make up a name if missing
            }

            var p0 = le16(a, j + 2);
            var p1 = le16(a, j + 4);
            var p2 = le16(a, j + 6);
            switch (a[j]) {
                case 0x00:
                    v.type = "scalar";
                    v.value = bcd(a, j + 2);
                    break;
                case 0x40:
                case 0x41:
                    v.type = "array";
                    break;
                case 0x80:
                case 0x81:
                    v.type = "string";
                    v.value = get_string(a, b.starp + i + p0, p1);
                    break;
                default:
                    v.type = a[j];
            }
            b.variable_values.push(v);
        }

        //var tokens_end = i+b.stmcur;
        var tokens_end = i + b.starp; // kings cribbage see https://www.atariarchives.org/mapping/memorymap.php STMCUR
        var turbo = false;

        var listing = [];
        var indent = 0;
        for (var j = tokens_begin; j < tokens_end;) {
            var s = { tok: [] };
            s.lineno = le16(a, j);
            var len = a[j + 2];

            if (s.lineno == 32768 || len == 0)
                break; // stmcur

            var line = s.lineno + " ";

            if (indent) {
                var cmd = a[j + 4];
                // Check if indent needs to decreased *before* the first command:
                //              NEXT           UNTIL          WEND           LOOP           ENDPROC        ENDIF     ELSE
                if (cmd == 0x09 || cmd == 0x3D || cmd == 0x3F || cmd == 0x46 || cmd == 0x51 || cmd == 0x41 || cmd == 0x40)
                    line = line + " ".repeat(2 * indent - 2);
                else
                    line = line + " ".repeat(2 * indent);
            }

            // Parse statements
            var k = 3;
            var op;
            while (k < len) {
                var end = a[j + k];
                var cmd = a[j + k + 1];
                k += 2;
                if (cmd >= 56) {
                    turbo = true;
                    if (cmd >= 101)
                        return failed("Unrecognized command index:" + cmd);    // not basic
                }

                s.tok.push(_basic_commands[cmd]);
                if (cmd != 0x36) {	// slient LET
                    line += _basic_commands[cmd];
                    if (line[line.length - 1] != ' ')
                        line += ' ';
                }

                if (cmd < 2) {	// REM,DATA
                    var txt = '';
                    while (k < end) {
                        var c = a[j + k++];
                        if (c == 0x9B)
                            break;
                        txt += String.fromCharCode(c);
                    }
                    s.tok.push(txt);
                    line += txt;
                    k = end;
                }

                // Check indent:
                //         FOR            REPEAT         WHILE          DO             PROC
                if (cmd == 0x08 || cmd == 0x3C || cmd == 0x3E || cmd == 0x45 || cmd == 0x4F)
                    indent += indenting;
                //              IF
                else if (cmd == 0x07) {
                    // Verify if there is THEN
                    var got_then = false;
                    for (var l = k; l < end; l++) {
                        var op = a[j + l];
                        if (op == 0x1B) {
                            got_then = true;
                            break;
                        }
                        else if (!op)
                            l++;
                        else if (op == 0x0F)
                            l += a[j + l + 1] + 1;
                        else if (op == 0x0E || op == 0x0D)
                            l += 6;
                    }
                    if (!got_then)
                        indent += indenting;
                }
                //              NEXT           UNTIL          WEND           LOOP           ENDPROC        ENDIF
                else if (cmd == 0x09 || cmd == 0x3D || cmd == 0x3F || cmd == 0x46 || cmd == 0x51 || cmd == 0x41)
                    indent = indent > 0 ? indent - 1 : 0;

                while (k < end) {
                    op = a[j + k++];
                    switch (op) {
                        case 0x0F: // SCONST
                            var txt = '';
                            var blen = a[j + k++];
                            while (blen--) {
                                c = a[j + k++];
                                if (c == 0x9B)
                                    break;
                                txt += String.fromCharCode(c);
                            }
                            s.tok.push(txt);
                            line += '"' + txt + '"';
                            break;
                        case 0x0D: // BCD hex const
                            var n = bcd(a, j + k);
                            var c = 1;
                            while (n >= (1 << c * 8))
                                c++;
                            s.tok.push(n);
                            k += 6;
                            line += '$' + hex(n, c * 2);
                            break;
                        case 0x0E: // NCONST
                            var n = bcd(a, j + k);
                            s.tok.push(n);
                            k += 6;
                            line += n;
                            break;
                        case 0x16: // EOL
                            k = end;
                            break;
                        default: {
                            var txt;
                            if (op & 0x80)
                                txt = b.variable_names[op & 0x7F];
                            else if (!op) {
                                turbo = true;
                                txt = b.variable_names[a[j + k++] ^ 0x80];    // thx dragonstomper
                            } else {
                                if (op >= 85) {
                                    turbo = true;
                                    if (op >= 110)
                                        return failed("Unrecognized operation:" + op);    // not basic
                                }
                                txt = _basic_operators[op];
                            }
                            if (txt == ":" || txt[0] == ' ')
                                line = line.trim();
                            line += txt;
                            s.tok.push(txt);
                        }
                    }
                }
            }
            b.statements.push(s);
            listing.push(line);
            j += len;
        }
        return { listing: listing, tokens: b }
    }

    //===================================================================================================
    // Atari syms equates : https://atariwiki.org/wiki/Wiki.jsp?page=Atari%20800%20Assembler%20Equates
    // also equates can be found in Atari OS Source listings
    // updated with information from Altirra Source Code, Disassembler DIS6502 https://sourceforge.net/p/dis6502/feature-requests/70/

    //(PVB ADD) 5200 EQUATES
    var _bShowA5200Equates = 0; //if set, A5200 disassembly equates instead of 800/XL/XE equates
    //for Atari 5200:
    //https://archive.org/details/analog-computing-magazine-15/page/n61/mode/2up?view=theater
    //commented by Dan Boris http://www.atarihq.com/danb/files/52analog.pdf
    var _A5200syms_zp = { //syms for Zero Page of Atari 5200
        //A5200 RAM is $0000 to $3FFF
        //PAGE zero $00-FF
        //$00 to $18 are reserved as follows
        '00':['POKMSK','SHADOW FOR IRQEN'],
        '01':['RTCLOKH','REAL TIME CLOCK (MSB)'],
        '02':['RTCLOKL','REAL TIME CLOCK (LSB)'],
        '03':['CRITIC','(ALSO NAMED CODFLG) IF NON-ZERO VBI ROUTINE IS SHORTEN'],
        '04':['ATRACT','ATRACT MODE TIME / FLAG'],
        '05':['SDLSTL','SHADOW FOR DLISTL'],
        '06':['SDLSTH','SHADOW FOR DLISTH'],
        '07':['SDMCTL','SHADOW FOR DMACTL'],
        '08':['PCOLR0','SHADOW FOR COLPM0'],
        '09':['PCOLR1','SHADOW FOR COLPM1'],
        '0A':['PCOLR2','SHADOW FOR COLPM2'],
        '0B':['PCOLR3','SHADOW FOR COLPM3'],
        '0C':['COLOR0','SHADOW FOR COLOR0'],
        '0D':['COLOR1','SHADOW FOR COLOR1'],
        '0E':['COLOR2','SHADOW FOR COLOR2'],
        '0F':['COLOR3','SHADOW FOR COLOR3'],
        '10':['COLOR4','SHADOW FOR COLBK'],
        '11':['PADDL0','SHADOW FOR POTO0'],
        '12':['PADDL1','SHADOW FOR POTO1'],
        '13':['PADDL2','SHADOW FOR POTO2'],
        '14':['PADDL3','SHADOW FOR POTO3'],
        '15':['PADDL4','SHADOW FOR POTO4'],
        '16':['PADDL5','SHADOW FOR POTO5'],
        '17':['PADDL6','SHADOW FOR POTO6'],
        '18':['PADDL7','SHADOW FOR POTO7'],
    }
    var _A5200syms = {
        //A5200 RAM is $0000 to $3FFF
        //PAGE 1 $100-1FF = 6502C CPU STACK
        '0100':["STACK", "6502C CPU STACK (256 BYTES UP TO $1FF)"],
        //$200 to $021B for the OS ROM Registers Shadows as follows
        '0200':['VIMIRQ ','IMMEDIATE IRQ VECTOR'],
        '0201':['VIMIRQ+1 ','...'],
        '0202':['VVBLKI ','IMMEDIATE VBI VECTOR'],
        '0203':['VVBLKI+1 ','...'],
        '0204':['VVBLKD ','DIFFERED VBI VECTOR'],
        '0205':['VVBLKD+1 ','...'],
        '0206':['VDLI ','VDSLST DLI VECTOR LOW'],
        '0207':['VDLI+1 ','VDSLST+1 DLI VECTOR HIGH'],
        '0208':['VKEYBD ','VKYBDI KEYBOARD IRQ VECTOR'],
        '0209':['VKEYBD+1 ','VKYBDI+1 KEYBOARD IRQ VECTOR'],
        '020A':['VKEYPAD ','VKYBDF KEYPAD ROUTINE CONTINUATION VECTOR'],
        '020B':['VKEYPAD+1 ','VKYBDF+1 KEYPAD ROUTINE CONTINUATION VECTOR'],
        '020C':['VBREAK ','VTRIGR BREAK KEY IRQ VECTOR'],
        '020D':['VBREAK+1 ','VTRIGR+1 BREAK KEY IRQ VECTOR'],
        '020E':['VBRK ','VBRKOP BREAK INSTRUCTION IRQ VECTOR'],
        '020F':['VBRK+1 ','VBRKOP+1 BREAK INSTRUCTION IRQ VECTOR'],
        '0210':['VSERIN ','SERIAL INPUT DATA READY IRQ VECTOR'],
        '0211':['VSERIN+1 ','...'],
        '0212':['VSEROR ','SERIAL OUTPUT DATA NEEDED IRQ VECTOR'],
        '0213':['VSEROR+1 ','...'],
        '0214':['VSEROC ','SERIAL OUTPUT FINISHED IRQ VECTOR'],
        '0215':['VSEROC+1 ','...'],
        '0216':['VTIMR1 ','POKEY TIMER 1 IRQ VECTOR'],
        '0217':['VTIMR1+1 ','...'],
        '0218':['VTIMR2 ','POKEY TIMER 2 IRQ VECTOR'],
        '0219':['VTIMR2+1 ','...'],
        '021A':['VTIMR4 ','POKEY TIMER 4 IRQ VECTOR'],
        '021B':['VTIMR4+1 ','...']
        //ROM CHAR SET is $F800 to $FBFF
        //ROM OS/MONITOR is $FC00 to $FFFF
    }
    //(PVB End Of ADD)

    //Atari 800/XL/XE equates
    //(PVB MOD) Update according to Altirra Source Equates & Disassembler
    var _A800syms_zp = { //zero page $00-FF
        '00': ["LINZBS", "[800]LINBUG STORAGE FOR ORIGINAL DEBUGGER"],
        '01': ["NGFLAG", "[XL]FOR POWER-UP SELF TEST"],
        '02': ["CASINI", "CASSETTE INIT LOC"],
        '03': ["CASINI+1", ""],
        '04': ["RAMLO", "RAM POINTER FOR MEM TEST"],
        '05': ["RAMLO+1", ""],
        '06': ["TRAMSZ", "TEMP LOC FOR RAM SIZE"],
        '07': ["TSTDAT", "RAM TEST DATA LOC"],
        '08': ["WARMST", "WARM START FLAG"],
        '09': ["BOOTQ", "SUCCESSFUL BOOT FLAG"],
        '0A': ["DOSVEC", "DOS START VECTOR (PROGRAM RUN VECTOR)"],
        '0B': ["DOSVEC+1", ""],
        '0C': ["DOSINI", "DOS INIT ADDRESS (PROGRAM INITIALIZATION)"],
        '0D': ["DOSINI+1", ""],
        '0E': ["APPMHI", "APPLICATION MEM HI LIMIT (DISPLAY LOW LIMIT)"],
        '0F': ["APPMHI+1", ""],
        '10': ["POKMSK", "SYSTEM MASK FOR POKEY IRQ ENABLE"],
        '11': ["BRKKEY", "BREAK KEY FLAG"],
        '12': ["RTCLOK", "REAL TIME CLOCK (60HZ OR 16.66666 MS) MSB"],
        '13': ["RTCLOK+1", "REAL TIME CLOCK MED BYTE"],
        '14': ["RTCLOK+2", "REAL TIME CLOCK LSB BYTE"],
        '15': ["BUFADR", "INDIRECT BUFFER ADDRESS REG"],
        '16': ["BUFADR+1", ""],
        '17': ["ICCOMT", "COMMAND FOR VECTOR HANDLER"],
        '18': ["DSKFMS", "DISK FILE MANAGER POINTER"],
        '19': ["DSKFMS+1", ""],
        '1A': ["DSKUTL", "DISK UTILITIES POINTER (DUP.SYS)"],
        '1B': ["DSKUTL+1", ""],
        '1C': ["PTIMOT/ABUFPT", "[800]PRINTER TIME OUT REGISTER /[XL]RESERVED"],
        '1D': ["PBPNT/ABUFPT+1", "[800]PRINT BUFFER POINTER /[XL]RESERVED"],
        '1E': ["PBUFSZ/ABUFPT+2", "[800]PRINT BUFFER SIZE /[XL]RESERVED"],
        '1F': ["PTEMP/ABUFPT+3", "[800]TEMPORARY REGISTER /[XL]RESERVED"],
        '20': ["ICHIDZ", "HANDLER INDEX NUMBER ($FF := IOCB FREE)"],//ZIOCB  = $20	; 32 ZERO PAGE IOCB
        '21': ["ICDNOZ", "DEVICE NUMBER (DRIVE NUMBER)"],
        '22': ["ICCOMZ", "COMMAND CODE"],
        '23': ["ICSTAZ", "STATUS OF LAST IOCB ACTION"],
        '24': ["ICBALZ", "BUFFER ADDRESS (LOW)"],
        '25': ["ICBAHZ", "BUFFER ADDRESS (HIGH)"],
        '26': ["ICPTLZ", "PUT BYTE ROUTINE ADDRESS-1 (LOW)"],
        '27': ["ICPTHZ", "PUT BYTE ROUTINE ADDRESS (HIGH)"],
        '28': ["ICBLLZ", "BUFFER LENGTH (LOW)"],
        '29': ["ICBLHZ", "BUFFER LENGTH (HIGH)"],
        '2A': ["ICAX1Z", "AUX INFO BYTE 1"],
        '2B': ["ICAX2Z", "AUX INFO BYTE 2"],
        '2C': ["ICSPRZ", "SPARE BYTE 1 (CIO LOCAL USE)"],
        '2D': ["ICSPRZ+1", "SPARE BYTE 1 (CIO LOCAL USE)"],
        '2E': ["ICIDNO", "IOCB LUMBER x 16"],
        '2F': ["CIOCHR", "CHARACTER BYTE FOR CURRENT OPERATION"],
        '30': ["STATUS", "INTERNAL STATUS STORAGE"],
        '31': ["CHKSUM", "CHECKSUM (SINGLE BYTE SUM WITH CARRY)"],
        '32': ["BUFRLO", "POINTER TO DATA BUFFER (LO BYTE)"],
        '33': ["BUFRHI", "POINTER TO DATA BUFFER (HI BYTE)"],
        '34': ["BFENLO", "NEXT BYTE PAST END OF BUFFER (LO BYTE)"],
        '35': ["BFENHI", "NEXT BYTE PAST END OF BUFFER (HI BYTE)"],
        '36': ["CRETRY/LTEMP", "[800]NBR OF COMMAND FRAME RETRIES /[XL]LOADER TEMP STORAGE"],
        '37': ["DRETRY/LTEMP+1", "[800]NBR OF DEVICE RETRIES/[XL]LOADER TEMP STORAGE"],
        '38': ["BUFRFL", "DATA BUFFER FULL FLAG"],
        '39': ["RECVDN", "RECEIVE DONE FLAG"],
        '3A': ["XMTDON", "XMIT DONE FLAG"],
        '3B': ["CHKSNT", "CHECKSUM SENT FLAG"],
        '3C': ["NOCKSM", "NO CHECKSUM FOLLOWS DATA FLAG"],
        '3D': ["BPTR", "BUFFER POINTER (CASSETTE)"],
        '3E': ["FTYPE", "FILE TYPE (SHORT IRG/LONG IRG)"],
        '3F': ["FEOF", "END OF FILE FLAG (CASSETTE)"],
        '40': ["FREQ", "FREQ COUNTER FOR CONSOLE SPEAKER"],
        '41': ["SOUNDR", "NOISY I/O FLAG (ZERO IS QUIET)"],
        '42': ["CRITIC", "CRITICAL CODE IF NON-ZERO (NO DEFFERED VBI)"],
        '43': ["FMSZPG", "DISK FILE MANAGER SYSTEM STORAGE (7 BYTES)"],
        '44': ["FMSZPG+1", ""],
        '45': ["FMSZPG+2", ""],
        '46': ["FMSZPG+3", ""],
        '47': ["FMSZPG+4", ""],
        '48': ["FMSZPG+5", ""],
        '49': ["FMSZPG+6", ""],
        '4A': ["CKEY/ZCHAIN", "[800]SET WHEN GAME START KEY PRESSED /[XL]HANDLER LOADER TEMP"],
        '4B': ["CASSBT/ZCHAIN+1", "[800]CASSETTE BOOT FLAG /[XL]HANDLER LOADER TEMP"],
        '4C': ["DSTAT", "DISPLAY STATUS"],
        '4D': ["ATRACT", "ATTRACT MODE FLAG"],
        '4E': ["DRKMSK", "DARK ATTRACT MASK"],
        '4F': ["COLRSH", "ATTRACT COLOR SHIFTER (XORED WITH PLAYFIELD)"],
        '50': ["TMPCHR", "TEMP CHAR STORAGE (DISPLAY HANDLER)"],
        '51': ["HOLD1", "TEMP STG (DISPLAY HANDLER)"],
        '52': ["LMARGN", "SCREEN LEFT MARGIN"],
        '53': ["RMARGN", "SCREEN RIGHT MARGIN"],
        '54': ["ROWCRS", "CURSOR COUNTERS (CURSOR ROW)"],
        '55': ["COLCRS", "CURSOR COUNTERS (CURSOR COLUMN), 2 BYTES"],
        '56': ["COLCRS+1", ""],
        '57': ["DINDEX", "DISPLAY INDEX (VARIOUS QUANTS)"],
        '58': ["SAVMSC", "SCREEN ADDRESS"],
        '59': ["SAVMSC+1", ""],
        '5A': ["OLDROW", "PREVIOUS ROW/COL (CURSOR BEFORE DRAW OR FILL)"],
        '5B': ["OLDCOL", ""],
        '5C': ["OLDCOL+1", ""],
        '5D': ["OLDCHR", "DATA UNDER CURSOR"],
        '5E': ["OLDADR", "CURSOR ADDRESS"],
        '5F': ["OLDADR+1", ""],
        '60': ["NEWROW/FKDEF", "[800]DRAWTO ROW DESTINATION /[XL]FUNCTION KEY POINTER"],
        '61': ["NEWCOL/FKDEF+1", "[800]DRAWTO COL DESTINATION /[XL]FUNCTION KEY POINTER"],
        '62': ["NEWCOL+1/PALNTS", "[800]DRAWTO COL DESTINATION /[XL]EUROPE/US TV FLAG"],
        '63': ["LOGCOL", "POINTS AT COLUMN IN LOGICAL LINE"],
        '64': ["ADRESS", "INDIRECT POINTER"],
        '65': ["ADRESS+1", ""],
        '66': ["MLTTMP", "MULTIPLY TEMP"],
        '67': ["TOADR+1", ""],
        '68': ["SAVADR", ""],
        '69': ["SAVADR+1", ""],
        '6A': ["RAMTOP", "RAM SIZE +1 DEFINED BY POWERON LOGIC (HIGH BYTE)"],
        '6B': ["BUFCNT", "BUFFER COUNT"],
        '6C': ["BUFSTR", "EDITOR GETCH POINTER"],
        '6D': ["BUFSTR+1", ""],
        '6E': ["BITMSK", "BIT MASK"],
        '6F': ["SHFAMT", "OUTCHR SHIFT"],
        '70': ["ROWAC", "USED BY \"DRAW\" 11 BYTES"],
        '71': ["ROWAC+1", ""],
        '72': ["COLAC", ""],
        '73': ["COLAC+1", ""],
        '74': ["ENDPT", ""],
        '75': ["ENDPT+1", ""],
        '76': ["DELTAR", ""],
        '77': ["DELTAC", ""],
        '78': ["DELTAC+1", ""],
        '79': ["ROWINC/KEYDEF", "[800] ROW /[XL]KEY DEFINITION POINTER"], //KEYDEF = 0x0079,	// XL/XE
        '7A': ["COLINC/KEYDEF+1", "[800] COL /[XL]KEY DEFINITION POINTER+1"],
        '7B': ["SWPFLG", "NON-0 IF TXT AND RAM SWAPPED"],
        '7C': ["HOLDCH", "CH BEFORE CNTL & SHFT PROCESSING IN KGETCH"],
        '7D': ["INSDAT", "INSERT CHAR SAVE"],
        '7E': ["COUNTR", "DRAW COUNTER"],
        '7F': ["COUNTR+1", ""],
        //$80 TO $FF ARE RESERVED FOR USER APPLICATION
        ///ZROFRE = $80-D3 ; FREE ZERO PAGE, OR 84 BYTES USED BY BASIC
        '80': ["LOMEM", "BASIC POINTER TO LOW MEMORY"],
        '81': ["LOMEM+1", ""],
        '82': ["VNTP", "BASIC VARIABLE NAME TABLE"],
        '83': ["VNTP+1", ""],
        '84': ["VNTD", "BASIC VARIABLE NAME TABLE END"],
        '85': ["VNTD+1", ""],
        '86': ["VVTP", "BASIC VARIABLE VALUE TABLE"],
        '87': ["VVTP+1", ""],
        '88': ["STMTAB", "BASIC STATEMENT TABLE"],
        '89': ["STMTAB+1", ""],
        '8A': ["STMCUR", "BASIC CURRENT STATEMENT POINTER"],
        '8B': ["STMCUR+1", ""],
        '8C': ["STARP", "BASIC STRING AND ARRAY POINTER"],
        '8D': ["STARP+1", ""],
        '8E': ["RUNSTK", "BASIC RUNTIME STACK"],
        '8F': ["RUNSTK+1", ""],
        '90': ["MEMTOP", "BASIC TOP OF MEMORY"],
        '91': ["MEMTOP+1", ""],
        '92': ["MEOLFLG", ""],
        '94': ["COX", ""],
        '95': ["POKADR", ""],
        '96': ["POKADR+1", ""],
        '97': ["SVESA", ""],
        '98': ["SVESA+1", ""],
        '99': ["MVFA", ""],
        '9A': ["MVFA+1", ""],
        '9B': ["MVTA", ""],
        '9C': ["MVTA+1", ""],
        '9D': ["CPC", ""],
        '9E': ["CPC+1", ""],
        '9F': ["LLNGTH", ""],
        'A0': ["TSLNUM", ""],
        'A1': ["TSLNUM+1", ""],
        'A2': ["MVLNG", ""],
        'A3': ["MVLNG+1", ""],
        'A4': ["ECSIZE", ""],
        'A5': ["ECSIZE+1", ""],
        'A6': ["DIRFLG", ""],
        'A7': ["STMLBD", ""],
        'A8': ["STINDEX", ""],
        'A9': ["OPSTKX", ""],
        'AA': ["ARSTKX", ""],
        'AB': ["EXSVOP", ""],
        'AC': ["EXSVPR", ""],
        'AD': ["LELNUM", ""],
        'AE': ["LELNUM+1", ""],
        'AF': ["STENUM", ""],
        'B0': ["COMCNT", ""],
        'B1': ["ADFLAG", ""],
        'B2': ["SVDISP", ""],
        'B3': ["ONLOOP", ""],
        'B4': ["ENTDTD", ""],
        'B5': ["LISTDTD", ""],
        'B6': ["DATAD", ""],
        'B7': ["DATALN", ""],
        'B8': ["DATALN+1", ""],
        'B9': ["ERRNUM", ""],
        'BA': ["STOPLN", ""],
        'BB': ["STOPLN+1", ""],
        'BC': ["TRAPLN", ""],
        'BD': ["TRAPLN+1", ""],
        'BE': ["SAVCUR", ""],
        'BF': ["SAVCUR+1", ""],
        'C0': ["IOCMD", ""],
        'C1': ["IODVC", ""],
        'C2': ["PROMPT", ""],
        'C3': ["ERRSAV", ""],
        'C4': ["TEMPA", ""],
        'C5': ["TEMPA+1", ""],
        'C6': ["ZTEMP2", ""],
        'C7': ["ZTEMP2+1", ""],
        'C8': ["COLOR", ""],
        'C9': ["PTABW", ""],
        'CA': ["LOADFLG", ""],
        'D2': ["VTYPE", ""],
        'D3': ["VNUM", ""],
        ///FPZRO  = $D4-$FF ; FLOATING POINT RAM, 43 BYTES
        'D4': ["FR0", "FP REGISTER 0 (6 BYTES)"],
        'D5': ["FR0+1", ""],
        'D6': ["FR0+2", ""],
        'D7': ["FR0+3", ""],
        'D8': ["FR0+4", ""],
        'D9': ["FR0+5", ""],
        'DA': ["FRE", "FP REGISTER EXP (6 BYTES)"],
        'DB': ["FRE+1", ""],
        'DC': ["FRE+2", ""],
        'DD': ["FRE+3", ""],
        'DE': ["FRE+4", ""],
        'DF': ["FRE+5", ""],
        'E0': ["FR1", "FP REGISTER 1 (6 BYTES)"],
        'E1': ["FR1+1", ""],
        'E2': ["FR1+2", ""],
        'E3': ["FR1+3", ""],
        'E4': ["FR1+4", ""],
        'E5': ["FR1+5", ""],
        'E6': ["FR2", "FP REGISTER 2 (6 BYTES)"],
        'E7': ["FR2+1", ""],
        'E8': ["FR2+2", ""],
        'E9': ["FR2+3", ""],
        'EA': ["FR2+4", ""],
        'EB': ["FR2+5", ""],
        'EC': ["FRX", "SPARE"],
        'ED': ["EEXP", "VALUE OF E"],
        'EE': ["NSIGN", "SIGN OF FP NUMBER"],
        'EF': ["ESIGN", "SIGN OF FP EXPONENT"],
        'F0': ["FCHRFLG", "FIRST CHARACTER FLAG"],
        'F1': ["DIGRT", "NUMBER OF DIGITS RIGHT OF DECIMAL POINT"],
        'F2': ["CIX", "INPUT INDEX"],
        'F3': ["INBUFF", "POINTER TO ASCII FP NUMBER"],
        'F4': ["INBUFF+1", ""],
        'F5': ["ZTEMP1", ""],
        'F6': ["ZTEMP1+1", ""],
        'F7': ["ZTEMP4", ""],
        'F8': ["ZTEMP4+1", ""],
        'F9': ["ZTEMP3", ""],
        'FA': ["ZTEMP3+1", ""],
        'FB': ["RADFLG", "0=RADIANS, 6=DEGREES"],
        'FC': ["FLPTR", "POINTER TO BCD FP NUMBER"],
        'FD': ["FLPTR+1", ""],
        'FE': ["FPTR2", ""],
        'FF': ["FPTR2+1", ""]
    }
    var _A800syms = {
        //PAGE 1 $100-1FF = 6502 CPU STACK
        '0100': ["STACK", "6502C CPU STACK (256 BYTES UP TO $1FF)"],
        //PAGE 2 $200-2FF
        ///INTABS = $200-232 ;INTERRUPT VECTOR TABLE
        '0200': ["VDSLST", "DISPLAY LIST NMI VECTOR"],
        '0201': ["VDSLST+1", ""],
        '0202': ["VPRCED", "PROCEED LINE IRQ VECTOR"],
        '0203': ["VPRCED+1", ""],
        '0204': ["VINTER", "INTERRUPT LINE IRQ VECTOR"],
        '0205': ["VINTER+1", ""],
        '0206': ["VBREAK", "\"BRK\" VECTOR"],
        '0207': ["VBREAK+1", ""],
        '0208': ["VKEYBD", "POKEY KEYBOARD IRQ VECTOR"],
        '0209': ["VKEYBD+1", ""],
        '020A': ["VSERIN", "POKEY SERIAL INPUT READY"],
        '020B': ["VSERIN+1", ""],
        '020C': ["VSEROR", "POKEY SERIAL OUTPUT READY"],
        '020D': ["VSEROR+1", ""],
        '020E': ["VSEROC", "POKEY SERIAL OUTPUT DONE"],
        '020F': ["VSEROC+1", ""],
        '0210': ["VTIMR1", "POKEY TIMER 1 IRQ"],
        '0211': ["VTIMR1+1", ""],
        '0212': ["VTIMR2", "POKEY TIMER 2 IRQ"],
        '0213': ["VTIMR2+1", ""],
        '0214': ["VTIMR4", "POKEY TIMER 4 IRQ (DO NOT USE)"],
        '0215': ["VTIMR4+1", ""],
        '0216': ["VIMIRQ", "IMMEDIATE IRQ VECTOR"],
        '0217': ["VIMIRQ+1", ""],
        '0218': ["CDTMV1", "COUNT DOWN TIMER 1"],
        '0219': ["CDTMV1+1", ""],
        '021A': ["CDTMV1", "COUNT DOWN TIMER 2"],
        '021B': ["CDTMV2+1", ""],
        '021C': ["CDTMV1", "COUNT DOWN TIMER 3"],
        '021D': ["CDTMV3+1", ""],
        '021E': ["CDTMV1", "COUNT DOWN TIMER 4"],
        '021F': ["CDTMV4+1", ""],
        '0220': ["CDTMV1", "COUNT DOWN TIMER 5"],
        '0221': ["CDTMV5+1", ""],
        '0222': ["VVBLKI", "IMMEDIATE VERTICAL BLANK NMI VECTOR"],
        '0223': ["VVBLKI+1", ""],
        '0224': ["VVBLKD", "DEFERRED VERTICAL BLANK NMI VECTOR"],
        '0225': ["VVBLKD+1", ""],
        '0226': ["CDTMA1", "COUNT DOWN TIMER 1 JSR ADDRESS"],
        '0227': ["CDTMA1+1", ""],
        '0228': ["CDTMA2", "COUNT DOWN TIMER 2 JSR ADDRESS"],
        '0229': ["CDTMA2+1", ""],
        '022A': ["CDTMF3", "COUNT DOWN TIMER 3 FLAG"],
        '022B': ["SRTIMR", "SOFTWARE REPEAT TIMER"],
        '022C': ["CDTMF4", "COUNT DOWN TIMER 4 FLAG"],
        '022D': ["INTEMP", "IAN'S TEMP (???)"],
        '022E': ["CDTMF5", "COUNT DOWN TIMER 5 FLAG"],
        '022F': ["SDMCTL", "SAVE DMACTL REGISTER (DMACTL SHADOW)"],
        '0230': ["SDLSTL", "SAVE DISPLAY LIST (DL SHADOW)(LOW)"],
        '0231': ["SDLSTH", "SAVE DISPLAY LIST (DL SHADOW)(HIGH)"],
        ///
        '0232': ["SSKCTL", "SKCTL REGISTER RAM"],
        '0233': ["LCOUNT", "[XL]LOADER TEMP"],
        '0234': ["LPENH", "LIGHT PEN HORIZ VALUE"],
        '0235': ["LPENV", "LIGHT PEN VERT VALUE"],
        ///[400/800] $236 - $239 SPARE
        '0236': ["BRKKY", "[XL]BREAK KEY VECTOR"],
        '0237': ["BRKKY+1", "[XL]BREAK KEY VECTOR"],
        '0238': ["VPIRQ/RELADR", "[XL]LOADER"],
        '0239': ["VPIRQ+1/RELADR+1", "[XL]LOADER"],
        ///
        '023A': ["CDEVIC", "COMMAND FRAME BUFFER - DEVICE"],
        '023B': ["CCOMND", "COMMAND"],
        '023C': ["CAUX1", "COMMAND AUX BYTE 1"],
        '023D': ["CAUX2", "COMMAND AUX BYTE 2"],
        '023E': ["TEMP", "TEMPORARY STORAGE"],
        '023F': ["ERRFLG", "ERROR FLAG (ANY DEVICE ERROR EXCEPT TIMEOUT)"],
        //$240-243 BOOT BYTES SHADOWS
        '0240': ["DFLAGS", "DISK FLAGS FROM BOOT SECTOR ONE (BYTE#00)"],
        '0241': ["DBSECT", "NUMBER OF DISK BOOT SECTORS (BYTE#01)"],
        '0242': ["BOOTAD", "LOW ADDRESS FOR DISK BOOT LOADER (BYTE#02)"],
        '0243': ["BOOTAD+1", "HIGH ADDRESS FOR DISK BOOT LOADER (BYTE#03)"],
        ///
        '0244': ["COLDST", "COLDSTART FLAG (1 = DOING COLDSTART)"],
        '0245': ["RECLEN", "[XL]LOADER"],
        '0246': ["DSKTIM", "[800]DISK TIME OUT REG"],
        ///[XL] $246-26E 39 BYTES RESERVED
        '0247': ["LINBUF/PDVMSK", "[800]CHAR LINE BUFFER (40 BYTES UP TO $26E) /[XL]PDVMSK"],
        '0248': ["SHPDVS", "[XL]"],
        '0249': ["PDMSK", "[XL]"],
        '024A': ["RELADR", "[XL]"],
        '024B': ["RELADR+1", "[XL]"],
        '024C': ["PPTMPA", "[XL]"],
        '024D': ["PPTMPX", "[XL]"],
        /// $24E-26A XL reserved
        '026B': ["CHSALT", "[XL]CHARACTER SET POINTER"],
        '026C': ["VSFLAG", "[XL]FINE SCROLL TEMPORARY"],
        '026D': ["KEYDIS", "[XL]KEYBOARD DISABLE"],
        '026E': ["FINE", "[XL]FINE SCROLL FLAG"],
        '026F': ["GPRIOR", "GLOBAL PRIORITY CELL (P-M PRIORITY AND GTIA MODES)"],
        ///[XL] 3 MORE PADDLES, (800) 6 MORE PADDLE
        '0270': ["PADDL0", "POT 0 SHADOW"],
        '0271': ["PADDL1", "POT 1 SHADOW"],
        '0272': ["PADDL2", "POT 2 SHADOW"],
        '0273': ["PADDL3", "POT 3 SHADOW"],
        '0274': ["PADDL4", "POT 4 SHADOW"],
        '0275': ["PADDL5", "POT 5 SHADOW"],
        '0276': ["PADDL6", "POT 6 SHADOW"],
        '0277': ["PADDL7", "POT 7 SHADOW"],
        ///[XL] 1 MORE STICK, (800) 3 MORE STICKS
        '0278': ["STICK0", "JOYSTICK 0 SHADOW"],
        '0279': ["STICK1", "JOYSTICK 1 SHADOW"],
        '027A': ["STICK2", "JOYSTICK 2 SHADOW"],
        '027B': ["STICK3", "JOYSTICK 3 SHADOW"],
        ///[XL] 3 MORE PADDLE TRIGGERS, (800) 6 MORE TRIGGERS
        '027C': ["PTRIG0", "PADDLE 0 TRIGGER"],
        '027D': ["PTRIG1", "PADDLE 1 TRIGGER"],
        '027E': ["PTRIG2", "PADDLE 2 TRIGGER"],
        '027F': ["PTRIG3", "PADDLE 3 TRIGGER"],
        '0280': ["PTRIG4", "PADDLE 4 TRIGGER"],
        '0281': ["PTRIG5", "PADDLE 5 TRIGGER"],
        '0282': ["PTRIG6", "PADDLE 6 TRIGGER"],
        '0283': ["PTRIG7", "PADDLE 7 TRIGGER"],
        ///[XL] 1 MORE STICK TRIGGER, (800) 3 MORE STICK TRIGGERS
        '0284': ["STRIG0", "JOYSTICK 0 TRIGGER"],
        '0285': ["STRIG1", "JOYSTICK 1 TRIGGER"],
        '0286': ["STRIG2", "JOYSTICK 2 TRIGGER"],
        '0287': ["STRIG3", "JOYSTICK 3 TRIGGER"],
        '0288': ["CSTAT", "[800](UNUSED)"],
        '0289': ["WMODE", "R/W FLAG FOR CASSETTE"],
        '028A': ["BLIM", "BUFFER LIMIT (CASSETTE)"],
        ///[400/800] $28B - $28F SPARE
        '028B': ["IMASK", "[XL]"],
        '028C': ["JVECK", "[XL]"],
        '028D': ["JVECK+1", "[XL]"],
        '028E': ["NEWADR", "[XL]LOADER RAM"],
        '028F': ["NEWADR+1", "[XL]LOADER RAM"],
        '0290': ["TXTROW", "TEXT ROWCRS"],
        '0291': ["TXTCOL", "TEXT ROWCOL"],
        '0292': ["TXTCOL+1", ""],
        '0293': ["TINDEX", "TEXT INDEX"],
        '0294': ["TXTMSC", "FOOLS CONVRT INTO NEW MSC"],
        '0295': ["TXTMSC+1", ""],
        '0296': ["TXTOLD", "OLDROW AND OLDCOL FOR TEXT (AND THEN SOME)"],
        '0297': ["TXTOLD+1", ""],
        '0298': ["TXTOLD+2", ""],
        '0299': ["TXTOLD+3", ""],
        '029A': ["TXTOLD+4", ""],
        '029B': ["TXTOLD+5", ""],
        '029C': ["TMPX1/CRETRY", " /[XL]NUMBER OF COMMAND FRAME RETRIES"],
        '029D': ["HOLD3", ""],
        '029E': ["SUBTMP", ""],
        '029F': ["HOLD2", ""],
        '02A0': ["DMASK", ""],
        '02A1': ["TMPLBT", ""],
        '02A2': ["ESCFLG", "ESCAPE FLAG"],
        '02A3': ["TABMAP", "TAB BUFFER 15 (BYTE BIT MAP FOR TAB SETTINGS)"],
        '02A4': ["TABMAP+1", ""],
        '02A5': ["TABMAP+2", ""],
        '02A6': ["TABMAP+3", ""],
        '02A7': ["TABMAP+4", ""],
        '02A8': ["TABMAP+5", ""],
        '02A9': ["TABMAP+6", ""],
        '02AA': ["TABMAP+7", ""],
        '02AB': ["TABMAP+8", ""],
        '02AC': ["TABMAP+9", ""],
        '02AD': ["TABMAP+A", ""],
        '02AE': ["TABMAP+B", ""],
        '02AF': ["TABMAP+C", ""],
        '02B0': ["TABMAP+D", ""],
        '02B1': ["TABMAP+E", ""],
        '02B2': ["LOGMAP", "LOGICAL LINE START BIT MAP (4 BYTES)"],
        '02B3': ["LOGMAP+1", ""],
        '02B4': ["LOGMAP+2", ""],
        '02B5': ["LOGMAP+3", ""],
        '02B6': ["INVFLG", "INVERSE VIDEO FLAG (ATARI KEY)"],
        '02B7': ["FILFLG", "RIGHT FILL FLAG FOR DRAW (FILL DIRING DRAW FLAG)"],
        '02B8': ["TMPROW", ""],
        '02B9': ["TMPCOL", ""],
        '02BA': ["TMPCOL+1", ""],
        '02BB': ["SCRFLG", "SET IF SCROLL OCCURS"],
        '02BC': ["HOLD4", "MORE DRAW TEMPS"],
        '02BD': ["HOLD5/DRETRY", "/[XL] NUMBER OF DEVICE RETRIES"],
        '02BE': ["SHFLOK", "SHIFT LOCK KEY"],
        '02BF': ["BOTSCR", "BOTTOM OF SCREEN (24 NORM, 4 SPLIT)"],
        '02C0': ["PCOLR0", "P0 COLOR"],
        '02C1': ["PCOLR1", "P1 COLOR"],
        '02C2': ["PCOLR2", "P2 COLOR"],
        '02C3': ["PCOLR3", "P3 COLOR"],
        '02C4': ["COLOR0", "COLOR 0"],
        '02C5': ["COLOR1", "COLOR 1"],
        '02C6': ["COLOR2", "COLOR 2"],
        '02C7': ["COLOR3", "COLOR 3"],
        '02C8': ["COLOR4", "BACKGROUND COLOR"],
        ///[400/800] $2C9 - $2DF SPARE
        '02C9': ["RUNADR", "[XL]LOADER VECTOR"],
        '02CA': ["RUNADR+1", "[XL]LOADER VECTOR"],
        '02CB': ["HIUSED", "[XL]LOADER VECTOR"],
        '02CC': ["HIUSED+1", "[XL]LOADER VECTOR"],
        '02CD': ["ZHIUSE", "[XL]LOADER VECTOR"],
        '02CE': ["ZHIUSE+1", "[XL]LOADER VECTOR"],
        '02CF': ["GBYTEA", "[XL]LOADER VECTOR"],
        '02D0': ["GBYTEA+1", "[XL]LOADER VECTOR"],
        '02D1': ["LOADAD", "[XL]LOADER VECTOR"],
        '02D2': ["LOADAD+1", "[XL]LOADER VECTOR"],
        '02D3': ["ZLOADA", "[XL]LOADER VECTOR"],
        '02D4': ["ZLOADA+1", "[XL]LOADER VECTOR"],
        '02D5': ["DSCTLN", "[XL]LOADER VECTOR"],
        '02D6': ["DSCTLN+1", "[XL]LOADER VECTOR"],
        '02D7': ["ACMISR", "[XL]RESERVED"],
        '02D8': ["ACMISR+1", "[XL]RESERVED"],
        '02D9': ["KRPDEL", "[XL]KEY AUTO REPEAT DELAY"],
        '02DA': ["KEYREP", "[XL]KEY AUTO REPEAT RATE"],
        '02DB': ["NOCLIK", "[XL]KEY CLICK DISABLE"],
        '02DC': ["HELPFG", "[XL]HELP KEY FLAG"],
        '02DD': ["DMASAV", "[XL]SDMCTL (DMA) SAVE"],
        '02DE': ["PBPNT", "[XL]PRINTER BUFFER POINTER"],
        '02DF': ["PBUFSZ", "[XL]PRINTER BUFFER SIZE"],
        ///[400/800] $2E0 - $2E3 SPARE
        '02E0': ["RUNAD", "DOS FILE RUN ADDRESS"],
        '02E1': ["RUNAD+1", ""],
        '02E2': ["INITAD", "DOS FILE INIT ADDRESS"],
        '02E3': ["INITAD+1", ""],
        '02E4': ["RAMSIZ", "RAM SIZE (HI BYTE ONLY)"],
        '02E5': ["MEMTOP", "TOP OF AVAILABLE MEMORY (END OF FREE RAM)"],
        '02E6': ["MEMTOP+1", ""],
        '02E7': ["MEMLO", "BOTTOM OF AVAILABLE MEMORY"],
        '02E8': ["MEMLO+1", ""],
        '02E9': ["HNDLOD", "[XL]HANDLER LOADER FLAG"],
        '02EA': ["DVSTAT", "STATUS BUFFER (4 BYTES)"],
        '02EB': ["DVSTAT+1", ""],
        '02EC': ["DVSTAT+2", ""],
        '02ED': ["DVSTAT+3", ""],
        '02EE': ["CBAUDL", "CASSETTE BAUD RATE (LO BYTE)"],
        '02EF': ["CBAUDH", "CASSETTE BAUD RATE (HI BYTE)"],
        '02F0': ["CRSINH", "CURSOR INHIBIT (0 = ON, 1 = INHIBIT)"],
        '02F1': ["KEYDEL", "KEY DELAY AND RATE"],
        '02F2': ["CH1", ""],
        '02F3': ["CHACT", "CHACTL REGISTER (SHADOW)"],
        '02F4': ["CHBAS", "CHBAS REGISTER (CHARACTER SET POINTER)(SHADOW)"],
        ///[400/800] $2F5 - $2F9 SPARE
        '02F5': ["NEWROW", "[XL]DRAW DESTINATION"],
        '02F6': ["NEWCOL", "[XL]DRAW DESTINATION"],
        '02F7': ["NEWCOL+1", "[XL]DRAW DESTINATION"],
        '02F8': ["ROWINC", "[XL]"],
        '02F9': ["COLINC", "[XL]"],
        '02FA': ["CHAR", ""],
        '02FB': ["ATACHR", "ATASCII CHARACTER FOR CIO"],
        '02FC': ["CH", "GLOBAL VARIABLE FOR KEYBOARD"],
        '02FD': ["FILDAT", "RIGHT FILL DATA (DRAW)(COLOR FOR SCREEN FILL)"],
        '02FE': ["DSPFLG", "DISPLAY CONTROL CHAR FLAG IF NON-ZERO"],
        '02FF': ["SSFLAG", "DISPLAY START/STOP FLAG (CNTL-1) FOR PAGING"],
        //PAGE 3 $300-3FF RESIDENT DISK HANDLER/SIO INTERFACE
        ///DCB = $300 DEVICE CONTROL BLOCK (DCB)
        '0300': ["DDEVIC", "BUS I.D. NUMBER"],
        '0301': ["DUNIT", "UNIT NUMBER"],
        '0302': ["DCOMND", "BUS COMMAND"],
        '0303': ["DSTATS", "COMMAND TYPE/STATUS RETURN"],
        '0304': ["DBUFLO", "DATA BUFFER POINTER (LO BYTE ADDR)"],
        '0305': ["DBUFHI", "DATA BUFFER POINTER (HI BYTE ADDR)"],
        '0306': ["DTIMLO", "DEVICE TIME OUT IN 1 SEC. UNITS"],
        '0307': ["DUNUSE", "UNUSED"],
        '0308': ["DBYTLO", "BYTE COUNT (SECTOR SIZE)(LO BYTE)"],
        '0309': ["DBYTHI", "BYTE COUNT (SECTOR SIZE)(HI BYTE)"],
        '030A': ["DAUX1", "COMMAND AUXILLARY BYTE 1 (SECTOR NBR)(LO BYTE)"],
        '030B': ["DAUX2", "COMMAND AUXILLARY BYTE 2 (SECTOR NBR)(HI BYTE)"],
        ///end-of DCB
        '030C': ["TIMER1", "INITIAL BAUD RATE TIMER VALUE"],
        '030D': ["TIMER1+1", ""],
        '030E': ["ADDCOR/JMPERS", "[800]ADDITION CORRECTION /[XE]OPTION JUMPERS"],
        '030F': ["CASFLG", "CASSETTE MODE WHEN SET"],
        '0310': ["TIMER2", "FINAL TIMER VALUE (USED TO COMPUTE BAUD RATE)"],
        '0311': ["TIMER2+1", ""],
        '0312': ["TEMP1", "TEMP LOCATION"],
        '0313': ["TEMP1+1", "TEMP LOCATION"],
        '0314': ["TEMP2/PTIMOT", "[800]TEMP2 /[XL]PRINTER TIME OUT"],
        '0315': ["TEMP3", ""],
        '0316': ["SAVIO", "SAVE SERIAL IN DATA PORT"],
        '0317': ["TIMFLG", "TIME OUT FLAG FOR BAUD RATE CORRECTION"],
        '0318': ["STACKP", "SIO STACK POINTER REGISTER"],
        '0319': ["TSTAT", "TEMP STATUS LOCATION"],
        /// $31A-$33F HATABS HANDLER ADDRESS TABLE (38 BYTES UP TO $33F)
        '031A': ["HATABS+0", "PRINTER DEVICE (P)"],
        '031B': ["HATABS+1", "PRINTER DEVICE ($30)"],
        '031C': ["HATABS+2", "PRINTER DEVICE ($E4)"],
        '031D': ["HATABS+3", "CASSETTE DEVICE (C)"],
        '031E': ["HATABS+4", "CASSETTE DEVICE ($40)"],
        '031F': ["HATABS+5", "CASSETTE DEVICE ($E4)"],
        '0320': ["HATABS+6", "DISPLAY EDITOR (E)"],
        //(PVB TODO) Check '0321': ["MAXDEV", "MAXIMUM HANDLER ADDRESS INDEX"],
        '0321': ["HATABS+7", "DISPLAY EDITOR ($00)"],
        '0322': ["HATABS+8", "DISPLAY EDITOR ($E4)"],
        '0323': ["HATABS+9", "SCREEN HANDLER (S)"],
        '0324': ["HATABS+A", "SCREEN HANDLER ($10)"],
        '0325': ["HATABS+B", "SCREEN HANDLER ($E4)"],
        '0326': ["HATABS+C", "KEYBOARD HANDLER (K)"],
        '0327': ["HATABS+D", "KEYBOARD HANDLER ($20)"],
        '0328': ["HATABS+E", "KEYBOARD HANDLER ($E4)"],
        // $329-$33F UNUSED HATABS
        '033D': ["PUPBT1", "[XL]POWER-UP/RESET"],
        '033E': ["PUPBT2", "[XL]POWER-UP/RESET"],
        '033F': ["PUPBT3", "[XL]POWER-UP/RESET"],
        /// $340-$3BF IOCB OFFSETS //there are 8 IOCB channels, from 0 to 7 //Comments are same
        '0340': ["ICHID", "IOCB0-ID INDEX OF I/O CONTROL BLOCK 0"],
        '0341': ["ICDNO", "IOCB0-DEVICE NUMBER (DRIVE NUMBER)"],
        '0342': ["ICCOM", "IOCB0-ICCMD COMMAND CODE"],
        '0343': ["ICSTA", "IOCB0-STATUS"],
        '0344': ["ICBAL", "IOCB0-BUFFER ADDRESS (LOW BYTE)"],
        '0345': ["ICBAH", "IOCB0-BUFFER ADDRESS (HIGH BYTE)"],
        '0346': ["ICPTL", "IOCB0-PUT BYTE ROUTINE ADDRESS-1 (LOW)"],
        '0347': ["ICPTH", "IOCB0-PUT BYTE ROUTINE ADDRESS-1 (HIGH)"],
        '0348': ["ICBLL", "IOCB0-BUFFER LENGTH (LOW BYTE)"],
        '0349': ["ICBLH", "IOCB0-BUFFER LENGTH (HIGH BYTE)"],
        '034A': ["ICAX1", "IOCB0-AUXILLARY INFO (1)"],
        '034B': ["ICAX2", "IOCB0-AUXILLARY INFO (2)"],
        '034C': ["ICSPR", "IOCB0-AUXILLARY INFO (3)"],
        '034D': ["ICAX4", "IOCB0-AUXILLARY INFO (4)"],
        '034E': ["ICAX5", "IOCB0-AUXILLARY INFO (5)"],
        '034F': ["ICAX6", "IOCB0-AUXILLARY INFO (6)"],
        '0350': ["IOCB1", "B1-ICHID I/O CONTROL BLOCK 1"],
        '0351': ["B1-ICDNO", ""],
        '0352': ["B1-ICCOM", ""],
        '0353': ["B1-ICSTA", ""],
        '0354': ["B1-ICBAL", ""],
        '0355': ["B1-ICBAH", ""],
        '0356': ["B1-ICPTL", ""],
        '0357': ["B1-ICPTH", ""],
        '0358': ["B1-ICBLL", ""],
        '0359': ["B1-ICBLH", ""],
        '035A': ["B1-ICAX1", ""],
        '035B': ["B1-ICAX2", ""],
        '035C': ["B1-ICAX3", ""],
        '035D': ["B1-ICAX4", ""],
        '035E': ["B1-ICAX5", ""],
        '035F': ["B1-ICAX6", ""],
        '0360': ["IOCB2", "B2-ICHID I/O CONTROL BLOCK 2"],
        '0361': ["B2-ICDNO", ""],
        '0362': ["B2-ICCOM", ""],
        '0363': ["B2-ICSTA", ""],
        '0364': ["B2-ICBAL", ""],
        '0365': ["B2-ICBAH", ""],
        '0366': ["B2-ICPTL", ""],
        '0367': ["B2-ICPTH", ""],
        '0368': ["B2-ICBLL", ""],
        '0369': ["B2-ICBLH", ""],
        '036A': ["B2-ICAX1", ""],
        '036B': ["B2-ICAX2", ""],
        '036C': ["B2-ICAX3", ""],
        '036D': ["B2-ICAX4", ""],
        '036E': ["B2-ICAX5", ""],
        '036F': ["B2-ICAX6", ""],
        '0370': ["IOCB3", "B3-ICHID I/O CONTROL BLOCK 3"],
        '0371': ["B3-ICDNO", ""],
        '0372': ["B3-ICCOM", ""],
        '0373': ["B3-ICSTA", ""],
        '0374': ["B3-ICBAL", ""],
        '0375': ["B3-ICBAH", ""],
        '0376': ["B3-ICPTL", ""],
        '0377': ["B3-ICPTH", ""],
        '0378': ["B3-ICBLL", ""],
        '0379': ["B3-ICBLH", ""],
        '037A': ["B3-ICAX1", ""],
        '037B': ["B3-ICAX2", ""],
        '037C': ["B3-ICAX3", ""],
        '037D': ["B3-ICAX4", ""],
        '037E': ["B3-ICAX5", ""],
        '037F': ["B3-ICAX6", ""],
        '0380': ["IOCB4", "B4-ICHID I/O CONTROL BLOCK 4"],
        '0381': ["B4-ICDNO", ""],
        '0382': ["B4-ICCOM", ""],
        '0383': ["B4-ICSTA", ""],
        '0384': ["B4-ICBAL", ""],
        '0385': ["B4-ICBAH", ""],
        '0386': ["B4-ICPTL", ""],
        '0387': ["B4-ICPTH", ""],
        '0388': ["B4-ICBLL", ""],
        '0389': ["B4-ICBLH", ""],
        '038A': ["B4-ICAX1", ""],
        '038B': ["B4-ICAX2", ""],
        '038C': ["B4-ICAX3", ""],
        '038D': ["B4-ICAX4", ""],
        '038E': ["B4-ICAX5", ""],
        '038F': ["B4-ICAX6", ""],
        '0390': ["IOCB5", "B5-ICHID I/O CONTROL BLOCK 5"],
        '0391': ["B5-ICDNO", ""],
        '0392': ["B5-ICCOM", ""],
        '0393': ["B5-ICSTA", ""],
        '0394': ["B5-ICBAL", ""],
        '0395': ["B5-ICBAH", ""],
        '0396': ["B5-ICPTL", ""],
        '0397': ["B5-ICPTH", ""],
        '0398': ["B5-ICBLL", ""],
        '0399': ["B5-ICBLH", ""],
        '039A': ["B5-ICAX1", ""],
        '039B': ["B5-ICAX2", ""],
        '039C': ["B5-ICAX3", ""],
        '039D': ["B5-ICAX4", ""],
        '039E': ["B5-ICAX5", ""],
        '039F': ["B5-ICAX6", ""],
        '03A0': ["IOCB6", "B6-ICHID I/O CONTROL BLOCK 6"],
        '03A1': ["B6-ICDNO", ""],
        '03A2': ["B6-ICCOM", ""],
        '03A3': ["B6-ICSTA", ""],
        '03A4': ["B6-ICBAL", ""],
        '03A5': ["B6-ICBAH", ""],
        '03A6': ["B6-ICPTL", ""],
        '03A7': ["B6-ICPTH", ""],
        '03A8': ["B6-ICBLL", ""],
        '03A9': ["B6-ICBLH", ""],
        '03AA': ["B6-ICAX1", ""],
        '03AB': ["B6-ICAX2", ""],
        '03AC': ["B6-ICAX3", ""],
        '03AD': ["B6-ICAX4", ""],
        '03AE': ["B6-ICAX5", ""],
        '03AF': ["B6-ICAX6", ""],
        '03B0': ["IOCB7", "B7-ICHID I/O CONTROL BLOCK 7"],
        '03B1': ["B7-ICDNO", ""],
        '03B2': ["B7-ICCOM", ""],
        '03B3': ["B7-ICSTA", ""],
        '03B4': ["B7-ICBAL", ""],
        '03B5': ["B7-ICBAH", ""],
        '03B6': ["B7-ICPTL", ""],
        '03B7': ["B7-ICPTH", ""],
        '03B8': ["B7-ICBLL", ""],
        '03B9': ["B7-ICBLH", ""],
        '03BA': ["B7-ICAX1", ""],
        '03BB': ["B7-ICAX2", ""],
        '03BC': ["B7-ICAX3", ""],
        '03BD': ["B7-ICAX4", ""],
        '03BE': ["B7-ICAX5", ""],
        '03BF': ["B7-ICAX6", ""],
        ///end-of IOCBs
        /// $3C0-3E9 PRINTER BUFFER (42 BYTES)
        '03C0': ["PRNBUF", "PRINTER BUFFER (42 BYTES UP TO $3E9)"],
        '03C1': ["PRNBUF+1", ""],
        '03E7': ["PRNBUF+39", ""],
        ///
        '03E8': ["SUPERF", "[XL]SCREEN EDITOR"],
        '03E9': ["CKEY", "[XL]START KEY FLAG"],
        ///[400/800] $3EA - $3FC SPARE
        '03EA': ["CASSBT", "[XL]CASSETTE BOOT FLAG"],
        '03EB': ["CARTCK", "[XL]CARTRIDGE CHECKSUM"],
        '03EC': ["DERRF", "[XL]"],
        '03ED': ["ACMVAR", "[XL]RESERVED, 6 BYTES"],
        '03F8': ["BASICF", "[XL]"],
        '03F9': ["MINTLK", "[XL]RESERVED"],
        '03FA': ["GINTLK", "[XL]CARTRIDGE INTERLOCK"],
        '03FB': ["CHLINK", "[XL]HANDLER CHAIN (2 BYTES)"],
        '03FC': ["CHLINK+1", "[XL]HANDLER CHAIN (2 BYTES)"],
        /// $3FD-47F CASSETTE BUFFER (131 BYTES)
        '03FD': ["CASBUF", "CASSETTE BUFFER (131 BYTES UP TO $47F)"],
        '03FE': ["CASBUF+1", ""],
        '047F': ["CASBUF+130", ""],
        /// USER AREA $480-57F 256 BYTES AREA FOR USER
        '0480': ["LBUFF", "TEMP BUFFER (384 BYTES UP TO $5FF)"],
        '0481': ["LBUFF+1", ""],
        '05FF': ["LBUFF+383", ""],
        //PAGE 6 $600 and above **** RAM ALWAYS FREE ABOVE $600 ***//
        //***CARTDRIDGE LOW MEM RIGHT SLOT ON ATARI 800 (B Cart. are $8000-9FFF)***//
        '9FFA': ["R-CARTCS", "R-CARTRIDGE COLD START ADDRESS (LSB)"],
        '9FFB': ["R-CARTCS+1", "R-CARTRIDGE COLD START ADDRESS (MSB)"],
        '9FFC': ["R-CART", "R-CARTRIDGE AVAILABLE FLAG BYTE"],
        '9FFD': ["R-CARTFG", "R-CARTRIDGE FLAG BYTE"],
        '9FFE': ["R-CARTAD", "R-CARTRIDGE START VECTOR ADDRESS (LSB)"],
        '9FFF': ["R-CARTAD+1", "R-CARTRIDGE START VECTOR ADDRESS (MSB)"],
        //***CART HIGH MEM (A Cart. are $A000-BFFF or $B000-BFFF***//
        'BFFA': ["CARTCS", "CARTRIDGE COLD START ADDRESS (LSB)"],
        'BFFB': ["CARTCS+1", "CARTRIDGE COLD START ADDRESS (MSB)"],
        'BFFC': ["CART", "CARTRIDGE AVAILABLE FLAG BYTE"],
        'BFFD': ["CARTFG", "CARTRIDGE FLAG BYTE"],
        'BFFE': ["CARTAD", "CARTRIDGE START VECTOR ADDRESS (LSB)"],
        'BFFF': ["CARTAD+1", "CARTRIDGE START VECTOR ADDRESS (MSB)"],
        //===$C000-CFFF 4K OS ROM for XL/XE===//
        //===$D000-D7FF is the hardware chip interface -> no RAM, nor ROM===//
        //NOTE : in ATARI XL/XE OS ROM CHIP, data from $D000 to D7FF are the resident diagnostic 2K ROM program, copied in RAM at $5000-57FF on request
        //***CTIA/GTIA CHIP $D000-D01F***//
        'D000': ["M0PF/HPOSP0", "M0 TO PLAYFIELD COLLISION(R)/P0 HORZ. POSITION(W)"],
        'D001': ["M1PF/HPOSP1", "M1 TO PLAYFIELD COLLISION(R)/P1 HORZ. POSITION(W)"],
        'D002': ["M2PF/HPOSP2", "M2 TO PLAYFIELD COLLISION(R)/P2 HORZ. POSITION(W)"],
        'D003': ["M3PF/HPOSP3", "M3 TO PLAYFIELD COLLISION(R)/P3 HORZ. POSITION(W)"],
        'D004': ["P0PF/HPOSM0", "P0 TO PLAYFIELD COLLISION(R)/M0 HORZ. POSITION(W)"],
        'D005': ["P1PF/HPOSM1", "P1 TO PLAYFIELD COLLISION(R)/M1 HORZ. POSITION(W)"],
        'D006': ["P2PF/HPOSM2", "P2 TO PLAYFIELD COLLISION(R)/M2 HORZ. POSITION(W)"],
        'D007': ["P3PF/HPOSM3", "P3 TO PLAYFIELD COLLISION(R)/M3 HORZ. POSITION(W)"],
        'D008': ["M0PL/SIZEP0", "M0 TO PLAYERS COLLISION(R)/P0 SIZE(W)"],
        'D009': ["M1PL/SIZEP1", "M1 TO PLAYERS COLLISION(R)/P1 SIZE(W)"],
        'D00A': ["M2PL/SIZEP2", "M2 TO PLAYERS COLLISION(R)/P2 SIZE(W)"],
        'D00B': ["M3PL/SIZEP3", "M3 TO PLAYERS COLLISION(R)/P3 SIZE(W)"],
        'D00C': ["P0PL/SIZEM", "P0 TO PLAYERS COLLISION(R)/ALL MISSILES SIZE(W)"],
        'D00D': ["P1PL/GRAFP0", "P1 TO PLAYERS COLLISION(R)/P0 GRAPHICS LATCH(W)"],
        'D00E': ["P2PL/GRAFP1", "P2 TO PLAYERS COLLISION(R)/P1 GRAPHICS LATCH(W)"],
        'D00F': ["P3PL/GRAFP2", "P3 TO PLAYERS COLLISION(R)/P2 GRAPHICS LATCH(W)"],
        'D010': ["TRIG0/GRAFP3", "JOYSTK0 TRIG. BUTTON(R)/P4 GRAPHICS LATCH(W)"],
        'D011': ["TRIG1/GRAFM", "JOYSTK1 TRIG. BUTTON(R)/ALL MISSILES GRAPHICS LATCH(W)"],
        'D012': ["TRIG2/COLPM0", "JOYSTK2 TRIG. BUTTON(R)/PLAYER-MISSILE0 COLOR(W)"],
        'D013': ["TRIG3/COLPM1", "JOYSTK3 TRIG. BUTTON(R)/PLAYER-MISSILE1 COLOR(W)"],
        'D014': ["PAL/COLPM2", "NTSC/PAL DETECT BITS(R)/PLAYER-MISSILE2 COLOR(W)"],
        'D015': ["COLPM3", "(no read)/PLAYER-MISSILE3 COLOR(W)"],
        'D016': ["COLPF0", "(no read)/PLAYFIELD0 COLOR(W)"],
        'D017': ["COLPF1", "(no read)/PLAYFIELD1 COLOR(W)"],
        'D018': ["COLPF2", "(no read)/PLAYFIELD2 COLOR(W)"],
        'D019': ["COLPF3", "(no read)/PLAYFIELD3 COLOR(W)"],
        'D01A': ["COLBK", "(no read)/BACKGROUND COLOR(W)"],
        'D01B': ["PRIOR", "(no read)/PRIORITY SELECT CONTROL(W)"],
        'D01C': ["VDELAY", "(no read)/VERTICAL DELAY(W)"],
        'D01D': ["GRACTL", "(no read)/GRAPHIC CONTROL(W)"],
        'D01E': ["HITCLR", "(no read)/COLLISION CLEAR STROBE(W)"],
        'D01F': ["CONSOL", "CONSOLE SWITCHES OPTION-SELECT-START(R&W)"],
        //***PBI Parallel bus interface CONTROL $D100***//
        'D100': ["PBI", ""],
        'D1FF': ["PDVI", ""],
        //***POKEY CHIP $D200-D20F***//
        'D200': ["POT0/AUDF1", "PAD0 POT POS VALUE(R)/AUDIO CHANNEL 1 FREQ(W)"], 
        'D201': ["POT1/AUDF2", "PAD1 POT POS VALUE(R)/AUDIO CHANNEL 2 FREQ(W)"],
        'D202': ["POT2/AUDF3", "PAD2 POT POS VALUE(R)/AUDIO CHANNEL 3 FREQ(W)"],
        'D203': ["POT3/AUDF4", "PAD3 POT POS VALUE(R)/AUDIO CHANNEL 4 FREQ(W)"],
        'D204': ["POT4/AUDC1", "PAD4 POT POS VALUE(R)/AUDIO CHANNEL 1 CONTROL(W)"],
        'D205': ["POT5/AUDC2", "PAD5 POT POS VALUE(R)/AUDIO CHANNEL 2 CONTROL(W)"],
        'D206': ["POT6/AUDC3", "PAD6 POT POS VALUE(R)/AUDIO CHANNEL 3 CONTROL(W)"],
        'D207': ["POT7/AUDC4", "PAD7 POT POS VALUE(R)/AUDIO CHANNEL 4 CONTROL(W)"],
        'D208': ["ALLPOT/AUDCTL", "PAD DIRECTION(R)/AUDIO CONTROL(W)"],
        'D209': ["KBCODE/STIMER", "KEYBOARD CODE(R)/START TIMER STROBE(W)"],
        'D20A': ["RANDOM/SKRES", "RANDOM NUMBER GENERATOR(R)/SERIAL KEYBOARD RESET(W)"],
        'D20B': ["POTGO", "(no read)/PADDLE POT READ START STROBE(W)"],
        'D20D': ["SERIN/SEROUT", "SERIAL IN DATA(R)/SERIAL OUT DATA(W)"],
        'D20E': ["IRQST/IRQEN", "IRQ INTERRUPT STATUS REGISTER(R)/IRQ INTERRUPT ENABLE(W)"],
        'D20F': ["SKSTAT/SKCTL", "SERIAL KEYBOARD STATUS(R)/SERIAL KEYBOARD CONTROL(W)"],
        //***PIA CHIP $D300-D303***//
        'D300': ["PORTA", "PORT A DATA DIRECTION JOYSTICKS(R&W)"],
        'D301': ["PORTB", "PORT B DATA DIRECTION(R&W)"],
        'D302': ["PACTL", "PORT A CONTROL(R&W)"],
        'D303': ["PBCTL", "PORT B CONTROL(R&W)"],
        //***ANTIC  $D400-D40F***//
        'D400': ["DMACTL", "(no read)/DMA CONTROL REGISTER(W)"],
        'D401': ["CHACTL", "(no read)/CHAR CONTROL REGISTER(W)"],
        'D402': ["DLISTL", "(no read)/DISPLAY LIST POINTER (LOW BYTE)(W)"],
        'D403': ["DLISTH", "(no read)/DISPLAY LIST POINTER (HIGH BYTE)(W)"],
        'D404': ["HSCROL", "(no read)/HORIZONTAL SCROLL REGISTER(W)"],
        'D405': ["VSCROL", "(no read)/VERTICAL SCROLL REGISTER(W)"],
        'D407': ["PMBASE", "(no read)/PLAYER MISSILE BASE ADDRESS(W)"],
        'D409': ["CHBASE", "(no read)/CHAR SET BASE ADDRESS(W)"],
        'D40A': ["WSYNC", "(no read)/WAIT FOR HBLANK SYNC(W)"],
        'D40B': ["VCOUNT", "VERTICAL LINE COUNTER(R)/(no write)"],
        'D40C': ["PENH", "LIGHT PEN H POSITION(R)/(no write)"],
        'D40D': ["PENV", "LIGHT PEN H POSITION(R)/(no write)"],
        'D40E': ["NMIEN", "(no read)/NMI INTERRUPT ENABLE(W)"],
        'D40F': ["NMIST/NMIRES", "NMI INTERRUPT STATUS REGISTER(R)/NMI INTERRUPT RESET(W)"],
        //***CARTRIDGE CONTROL $D500-D5FF => ROM BANK SWITCHING CONTROL***//
        'D500': ["BKSWITCH", "MEMORY BANK SWITCHING CONTROL"],
        //***PBI Paralel bus interface RAM $D600-$D7FF***//
        'D600': ["PBIRAM", ""],
        // $D700 -$D7FF no use
        //===$D800-DFFF MATH PACK (Floating Point FP) 2K OS ROM $D800-DFFF===//
        'D800': ["AFP", "ASCII TO FP CONVERT"],
        'D803': ["PDID1", ""],
        'D805': ["PDIOV", ""],
        'D806': ["PDIOV+1", ""],
        'D808': ["PDIRQV", ""],
        'D809': ["PDIRQV+1", ""],
        'D80B': ["PDID2", ""],
        'D80D': ["PDVV", ""],
        'D8E6': ["FASC", "FP TO ASCII CONVERT"],
        'D9AA': ["IFP", "INTEGER TO FP CONVERT"],
        'D9D2': ["FPI", "FP TO INTEGER CONVERT"],
        'DA44': ["ZFR0", "CLEAR FR0"],
        'DA46': ["ZF1", "CLEAR FP NUMBER"],
        'DA60': ["FSUB", "FP SUBSTRACT"],
        'DA66': ["FADD", "FP ADD"],
        'DADB': ["FMUL", "FP MULTIPLY"],
        'DB28': ["FDIV", "FP DIVIDE"],
        'DD40': ["PLYEVL", "FP POLYNOMIAL EVALUATION"],
        'DD89': ["FLD0R", "LOAD FP NUMBER D0"],
        'DD8D': ["FLD0P", "LOAD FP NUMBER D0"],
        'DD98': ["FLD1R", "LOAD FP NUMBER D1"],
        'DD9C': ["FLD1P", "LOAD FP NUMBER D1"],
        'DDA7': ["FST0R", "STORE FP NUMBER"],
        'DDAB': ["FST0P", "STORE FP NUMBER"],
        'DDB6': ["FMOVE", "MOVE FP NUMBER"],
        'DDC0': ["EXP", "FP BASE E EXPONENTIATION"],
        'DDCC': ["EXP10", "FP BASE 10 EXPONENTIATION"],
        'DECD': ["LOG", "FP BASE E LOGARITHM"],
        'DED1': ["LOG10", "FP BASE 10 LOGARITHM"],
        //***OS ROM 8K $E000-FFFF***//
        ///$E000-E3FF RESIDENT CHAR SET
        'E000': ["CHORG", "1K CHARACTER SET"],
        ///$E400-FFF9 OS ROM ROUTINES
        ////$E400 VECTBL => OS VERCTOR TABLE for CIO routines: +0 OPEN; +2 CLOSE; +4 GET; +6 PUT; +8 STATUS; +A SPECIAL; +C INIT
        'E400': ["EDITRV", "EDITOR (E)"],
        'E410': ["SCRENV", "TELEVISION SCREEN (S)"],
        'E420': ["KEYBDV", "KEYBOARD (K)"],
        'E430': ["PRINTV", "PRINTER (P)"],
        'E440': ["CASETV", "CASSETTE (C)"],
        ////Other Main OS Vectors (CIO is Central Input Output; SIO is Serial Input Output)
        'E450': ["DISKIV", "DISK INITIALIZATION"],
        'E453': ["DSKINV", "DISK INTERFACE"],
        'E456': ["CIOV", "CIO ROUTINE"],
        'E459': ["SIOV", "SIO ROUTINE"],
        'E45C': ["SETVBV", "SET VERTICAL BLANK VECTORS"],
        'E45F': ["SYSVBV", "SYSTEM VERTICAL BLANK ROUTINE"],
        'E462': ["XITVBV", "EXIT VERTICAL BLANK ROUTINE"],
        'E465': ["SIOINV", "SIO INITIALIZATION"],
        'E468': ["SENDEV", "SEND ENABLE ROUTINE"],
        'E46B': ["INTINV", "INTERRUPT HANDLER INITIALIZATION"],
        'E46E': ["CIOINV", "CIO INIT"],
        'E471': ["BLKBDV", "BLACKBOARD MODE"],
        'E474': ["WARMSV", "WARM START ENTRY POINT"],
        'E477': ["COLDSV", "COLD START ENTRY POINT"],
        'E47A': ["RBLOKV", "CASSETTE READ BLOCK ENTRY POINT VECTOR"],
        'E47D': ["CSOPIV", "CASSETTE OPEN FOR INPUT VECTOR"],
        ///Shortcut - memory routine direct access - should not be used, because depends on OS version (here listed is rev B)
        ////$E480 VCTABL => RAM VECTOR INITIAL VALUE TABLE
        'E480': ["PUPDIV", ""],
        'E483': ["SLFTSV", ""],
        'E486': ["PHENTV", ""],
        'E489': ["PHUNLV", ""],
        'E48C': ["PHINIV", ""],
        'E48F': ["GPDVV", ""],
        'E4A6': ["CIOORG", "CIO HANDLER"],
        'E6D5': ["INTORG", "INTERRUPT HANDLER"],
        'E944': ["SIOORG", "SIO DRIVER"],
        'EDEA': ["DSKORG", "DISK HANDLER"],
        'EE78': ["PRNORG", "PRINTER HANDLER"],
        'EF41': ["CASORG", "CASSETTE HANDLER"],
        'F0E3': ["MONORG", "MONITOR/POWER UP MODULE"],
        'F385': ["PUTLIN", "OUTPUT LINE TO IOCB#0"],
        'F3E4': ["KBDORG", "KEYBOARD/DISPLAY HANDLER"],
        'F6A4': ["EOUTCH", "OUTPUT CHAR TO SCREEN"],
        'F6E2': ["KGETCH", "GET CHAR FROM KEYBOARD"],
        //***6502 CPU RESIDENT 3 MANDATORY CPU VECTORS***/
        'FFFA': ["NMIVEC", "NMI NON MASKABLE INTERRUPT OS ROM VECTOR"],
        'FFFB': ["NMIVEC+1", "..."],
        'FFFC': ["RESETVEC", "RESET OS ROM VECTOR, POWER-UP VECTOR PVECT"],
        'FFFD': ["RESETVEC+1", "..."],
        'FFFE': ["IRQVEC", "IRQ INTERRUPT REQUEST OS ROM VECTOR"],
        'FFFF': ["IRQVEC+1", "..."],
    }

    //===================================================================================================
    // 6502 disassembler derived from
    // n. landsteiner, mass:werk / electronic tradion 2005; e-tradion.net
    //(PVB COM) see also https://www.masswerk.at/6502/6502_instruction_set.html
    var opctab = [
        ['BRK', 'imp'], ['ORA', 'inx'], ['???', 'imp'], ['???', 'imp'], //00--03
        ['???', 'imp'], ['ORA', 'zpg'], ['ASL', 'zpg'], ['???', 'imp'], //04--07
        ['PHP', 'imp'], ['ORA', 'imm'], ['ASL', 'acc'], ['???', 'imp'], //08--0B
        ['???', 'imp'], ['ORA', 'abs'], ['ASL', 'abs'], ['???', 'imp'], //0C--0F
        //10
        ['BPL', 'rel'], ['ORA', 'iny'], ['???', 'imp'], ['???', 'imp'],
        ['???', 'imp'], ['ORA', 'zpx'], ['ASL', 'zpx'], ['???', 'imp'],
        ['CLC', 'imp'], ['ORA', 'aby'], ['???', 'imp'], ['???', 'imp'],
        ['???', 'imp'], ['ORA', 'abx'], ['ASL', 'abx'], ['???', 'imp'],
        //20
        ['JSR', 'abs'], ['AND', 'inx'], ['???', 'imp'], ['???', 'imp'],
        ['BIT', 'zpg'], ['AND', 'zpg'], ['ROL', 'zpg'], ['???', 'imp'],
        ['PLP', 'imp'], ['AND', 'imm'], ['ROL', 'acc'], ['???', 'imp'],
        ['BIT', 'abs'], ['AND', 'abs'], ['ROL', 'abs'], ['???', 'imp'],
        //30
        ['BMI', 'rel'], ['AND', 'iny'], ['???', 'imp'], ['???', 'imp'],
        ['???', 'imp'], ['AND', 'zpx'], ['ROL', 'zpx'], ['???', 'imp'],
        ['SEC', 'imp'], ['AND', 'aby'], ['???', 'imp'], ['???', 'imp'],
        ['???', 'imp'], ['AND', 'abx'], ['ROL', 'abx'], ['???', 'imp'],
        //40
        ['RTI', 'imp'], ['EOR', 'inx'], ['???', 'imp'], ['???', 'imp'],
        ['???', 'imp'], ['EOR', 'zpg'], ['LSR', 'zpg'], ['???', 'imp'],
        ['PHA', 'imp'], ['EOR', 'imm'], ['LSR', 'acc'], ['???', 'imp'],
        ['JMP', 'abs'], ['EOR', 'abs'], ['LSR', 'abs'], ['???', 'imp'],
        //50
        ['BVC', 'rel'], ['EOR', 'iny'], ['???', 'imp'], ['???', 'imp'],
        ['???', 'imp'], ['EOR', 'zpx'], ['LSR', 'zpx'], ['???', 'imp'],
        ['CLI', 'imp'], ['EOR', 'aby'], ['???', 'imp'], ['???', 'imp'],
        ['???', 'imp'], ['EOR', 'abx'], ['LSR', 'abx'], ['???', 'imp'],
        //60
        ['RTS', 'imp'], ['ADC', 'inx'], ['???', 'imp'], ['???', 'imp'],
        ['???', 'imp'], ['ADC', 'zpg'], ['ROR', 'zpg'], ['???', 'imp'],
        ['PLA', 'imp'], ['ADC', 'imm'], ['ROR', 'acc'], ['???', 'imp'],
        ['JMP', 'ind'], ['ADC', 'abs'], ['ROR', 'abs'], ['???', 'imp'],
        //70
        ['BVS', 'rel'], ['ADC', 'iny'], ['???', 'imp'], ['???', 'imp'],
        ['???', 'imp'], ['ADC', 'zpx'], ['ROR', 'zpx'], ['???', 'imp'],
        ['SEI', 'imp'], ['ADC', 'aby'], ['???', 'imp'], ['???', 'imp'],
        ['???', 'imp'], ['ADC', 'abx'], ['ROR', 'abx'], ['???', 'imp'],
        //80
        ['???', 'imp'], ['STA', 'inx'], ['???', 'imp'], ['???', 'imp'],
        ['STY', 'zpg'], ['STA', 'zpg'], ['STX', 'zpg'], ['???', 'imp'],
        ['DEY', 'imp'], ['???', 'imp'], ['TXA', 'imp'], ['???', 'imp'],
        ['STY', 'abs'], ['STA', 'abs'], ['STX', 'abs'], ['???', 'imp'],
        //90
        ['BCC', 'rel'], ['STA', 'iny'], ['???', 'imp'], ['???', 'imp'],
        ['STY', 'zpx'], ['STA', 'zpx'], ['STX', 'zpy'], ['???', 'imp'],
        ['TYA', 'imp'], ['STA', 'aby'], ['TXS', 'imp'], ['???', 'imp'],
        ['???', 'imp'], ['STA', 'abx'], ['???', 'imp'], ['???', 'imp'],
        //A0
        ['LDY', 'imm'], ['LDA', 'inx'], ['LDX', 'imm'], ['???', 'imp'],
        ['LDY', 'zpg'], ['LDA', 'zpg'], ['LDX', 'zpg'], ['???', 'imp'],
        ['TAY', 'imp'], ['LDA', 'imm'], ['TAX', 'imp'], ['???', 'imp'],
        ['LDY', 'abs'], ['LDA', 'abs'], ['LDX', 'abs'], ['???', 'imp'],
        //B0
        ['BCS', 'rel'], ['LDA', 'iny'], ['???', 'imp'], ['???', 'imp'],
        ['LDY', 'zpx'], ['LDA', 'zpx'], ['LDX', 'zpy'], ['???', 'imp'],
        ['CLV', 'imp'], ['LDA', 'aby'], ['TSX', 'imp'], ['???', 'imp'],
        ['LDY', 'abx'], ['LDA', 'abx'], ['LDX', 'aby'], ['???', 'imp'],
        //C0
        ['CPY', 'imm'], ['CMP', 'inx'], ['???', 'imp'], ['???', 'imp'],
        ['CPY', 'zpg'], ['CMP', 'zpg'], ['DEC', 'zpg'], ['???', 'imp'],
        ['INY', 'imp'], ['CMP', 'imm'], ['DEX', 'imp'], ['???', 'imp'],
        ['CPY', 'abs'], ['CMP', 'abs'], ['DEC', 'abs'], ['???', 'imp'],
        //D0
        ['BNE', 'rel'], ['CMP', 'iny'], ['???', 'imp'], ['???', 'imp'],
        ['???', 'imp'], ['CMP', 'zpx'], ['DEC', 'zpx'], ['???', 'imp'],
        ['CLD', 'imp'], ['CMP', 'aby'], ['???', 'imp'], ['???', 'imp'],
        ['???', 'imp'], ['CMP', 'abx'], ['DEC', 'abx'], ['???', 'imp'],
        //E0
        ['CPX', 'imm'], ['SBC', 'inx'], ['???', 'imp'], ['???', 'imp'],
        ['CPX', 'zpg'], ['SBC', 'zpg'], ['INC', 'zpg'], ['???', 'imp'],
        ['INX', 'imp'], ['SBC', 'imm'], ['NOP', 'imp'], ['???', 'imp'],
        ['CPX', 'abs'], ['SBC', 'abs'], ['INC', 'abs'], ['???', 'imp'],
        //F0
        ['BEQ', 'rel'], ['SBC', 'iny'], ['???', 'imp'], ['???', 'imp'],
        ['???', 'imp'], ['SBC', 'zpx'], ['INC', 'zpx'], ['???', 'imp'],
        ['SED', 'imp'], ['SBC', 'aby'], ['???', 'imp'], ['???', 'imp'],
        ['???', 'imp'], ['SBC', 'abx'], ['INC', 'abx'], ['???', 'imp']
    ];

    var addrtab = {
        acc: 'A',
        abs: 'abs',
        abx: 'abs,X',
        aby: 'abs,Y',
        imm: '#',
        imp: 'impl',
        ind: 'ind',
        inx: 'X,ind',
        iny: 'ind,Y',
        rel: 'rel',
        zpg: 'zpg',
        zpx: 'zpg,X',
        zpy: 'zpg,Y'
    }

    var steptab = { //step is the number of bytes within the instruction line
        imp: 1,
        acc: 1,
        imm: 2,
        abs: 3,
        abx: 3,
        aby: 3,
        zpg: 2,
        zpx: 2,
        zpy: 2,
        ind: 3,
        inx: 2,
        iny: 2,
        rel: 2
    };

    //(PVB ADD) disassembly and hex dump display options variables //(PVB TODO) use bits in a byte rather than global variables ?
    var _bShowDisLinks = 1; // set to show disassembly links
    var _bShowDisFlags = 0; // set to show disassembly code flags
    var _bShowDisBRK = 0; // set for up to 2 x BRK in disassembly
    var _bShowAtasciiChar = 1; // set for Atascii code
    var _bShowDispChar = 1; // set for internal display code
    var _bShowROMBank = 0; //set for showing rom bank in disassembly

    var _bShowAtariFont = false; // true for atari font for the wall display
    var _bShowWebChar = false; // true for using normal monosapace for char dump
    var _bHexEd = false; //true for display the Hex Editor
    var _bModif = false; //true to memorize that ATR or XFD file was modified.
    
    // functions

    //(PVB ADD) the get_symbol(memadd, opc) function
    function get_symbol(memadd, opc) {
        var str1, str2, n1, n2, sym, a;
        var a5200eq = _bShowA5200Equates;
        if (memadd.length == 2) { //zero page
            return (a5200eq ? _A5200syms_zp[memadd] : _A800syms_zp[memadd]);
        }
        //(PVB TODO) : convert memadd for A5200 ?//
        a = Number("0x" + memadd);
        if (a < 0xC000)
            return (a5200eq ? _A5200syms[memadd] : _A800syms[memadd]);
        if (a5200eq) { //Hardware chip addressing in A5200
            if (a >= 0xC000 && a <= 0xC0FF ) //GTIA at $C000-C0FF, that is at $D000-D0FF for A800
                memadd = hex(((a & 0x001F) | 0xD000),4);
            if (a >= 0xE800 && a <= 0xEBFF ) //POKEY at $E800-EBFF (that can feature 4xPOKEY chips ?), that is at $D200-D2FF for A800
                memadd = hex(((a & 0x000F) | 0xD200),4);
            if (a >= 0xD400 && a <= 0xD4FF ) {//ANTIC at $D400-D4FF, that is also at $D400-D4FF for A800
                memadd = hex(((a & 0x000F) | 0xD400),4);
            }
            if (a >= 0xF800 && a <= 0xFFF9)
            //(PVB TODO) : EXPERIMENTAL : within the OS ROM, shows "A5200 ROM"//
                return [" ", "A5200 ROM"]; //EXPERIMENTAL
            //if (a in the 2KB ROM)
            //ROM CHARSET is $F800 to $FBFF
            //ROM MONITOR is $FC00 to $FFFF
        } 
        else { // for A800
            if (a < 0xD000 || a> 0xDFFF) //ROM
                return _A800syms[memadd];
        }
        //check and display the adequat READ or WRITE symbol and informative text
        sym = _A800syms[memadd];
        if (!sym) return sym;
        str1 = sym[0];
        n1 = str1.indexOf("/");
        str2 = sym[1];
        n2 = str2.indexOf("/");
        switch(opc) {
            // following case are "write to Hardware chips"
            case 0x8C: //STY abs
            case 0x8D: //STA abs
            case 0x8E: //STX abs
            case 0x99: //STA abs,Y
            case 0x9D: //STA abs,X
                // extract write text
                if (n1 > 1) {
                    str1 = str1.slice(n1+1);
                }
                if (n2 > 1) {
                    str2 = str2.slice(n2+1);
                }
                break;
            default:
                // else by default, this is a read from Hardware chips
                // extract read text
                if (n1 > 1) {
                    str1 = str1.slice(0,n1);
                }
                if (n2 > 1) {
                    str2 = str2.slice(0,n2);
                }
                break;
        }
        sym = [str1, str2];
        return sym;
    }
    //(PVB END OF ADD)

    //(PVB MOD) improvement of disassembleStep() function 
    //previously //function disassembleStep(pc, ram, asm, flags)// so it is added :
    //'lastopcode' for identifying the last opcode matter, and then to stop fetching from the memory
    //so number of remaining bytes to desassemble is given in 'lastopcode' variable (lastopcode is included !)
    //'inner' = true to avoid display of "End of data or max address reached" when it's note the case when reajusting disassembly in dissassemble()
    function disassembleStep(pc, ram, asm, flags, lastopcode, inner) {
        var instr, op1, op2, addr, ops, disas, adm, step;
        var symbol;
        // get instruction and ops, inc PC (PC = program counter)
        
        function u8(i) {
            return ram[i];
        }

        instr = u8(pc);
        addr = hex(pc, 4); //Convert PC into address like '$0A39'
        ops = hex(instr); //Convert the instruction byte into hex like 'A0'
        disin = opctab[instr][0]; //(PVB MOD) opcode instruction like 'LDA'
        disas = ""; //(PVB ADD) variable initialization for operand display string like '#$A0'
        adm = opctab[instr][1]; //(PVB COM) type of opcode instruction like "imm" for immediat
        step = steptab[adm]; //(PVB COM) number of step = number of opcode+operands including the instruction (like 3 for LDA $A039)
        //(PVB MOD) change the validity declaration
        var valid = true;
        var oldstep = step;
        //(PVB ADD) Check the remaining bytes in the data block to disassemble
        var r = lastopcode - pc; // if pc = lastopcode then r == 0; no more data to disassemble, it is OK with Step = 1
        if (step > 1) {
            if (r == 0) {
                op1 = op2 = '..'; //even if op2 not used
                step = 1; // reajust step by forcing opcode = last instruction
            }
            else if ((r == 1) && (step > 2)) {
                op2 = '..';
                step = 2; // // reajust step by forcing opcode & operand n°1 as last instructions
            }
        }
        if (step > 1) op1 = hex(u8(pc + 1)); // (PVB COM) get operand n°1
        if (step > 2) op2 = hex(u8(pc + 2)); //(PVB COM) get operand n°2
        //(PVB ADD) Priority to entry_points identified with a 0x84 flags at PC
        if (oldstep > 1) { // step = 2 or 3;
            if ((flags[pc + 1] & 0x84) == 0x84) { //entry_point flag
                op1 = op2 = '..'; //even if op2 not used
                flags[pc] &= 0xFE; //reset valid bit for a display in disassembly Data Block in case of
                step = 1; //force to last instruction before entry_point
                valid = false;
                }
            else if (oldstep == 3 && ((flags[pc + 2] & 0x84) == 0x84)) { //entry_point flag
                op2 = '..';
                flags[pc] &= 0xFE; //reset valid bit for a display in disassembly Data Block in case of
                step = 2; //force to 2 last instructions before entry_point
                valid = false;
                }
        }
        //(PVB MOD) disas and disin
        // format and output to listing
        switch (adm) {
            case 'imm':
                ops += ' ' + op1 + '   '; // 'ops' string looks like 'EA A0   '
                disas = '#$' + op1;
                break;
            case 'zpg':
                ops += ' ' + op1 + '   ';
                disas = '$' + op1;
                break;
            case 'acc':
                ops += '      ';
                disas = 'A';
                break;
            case 'abs':
                ops += ' ' + op1 + ' ' + op2; // 'ops' string looks like 'EA A0 00'
                disas = '$' + op2 + op1;
                break;
            case 'zpx':
                ops += ' ' + op1 + '   ';
                disas = '$' + op1 + ',X';
                break;
            case 'zpy':
                ops += ' ' + op1 + '   ';
                disas = '$' + op1 + ',Y';
                break;
            case 'abx':
                ops += ' ' + op1 + ' ' + op2;
                disas = '$' + op2 + op1 + ',X';
                break;
            case 'aby':
                ops += ' ' + op1 + ' ' + op2;
                disas = '$' + op2 + op1 + ',Y';
                break;
            case 'iny':
                ops += ' ' + op1 + '   ';
                disas = '($' + op1 + '),Y';
                break;
            case 'inx':
                ops += ' ' + op1 + '   ';
                disas = '($' + op1 + ',X)';
                break;
            case 'rel':
                //(PVB ADD & MOD)
                ops += ' ' + op1 + '   ';
                if (op1 == '..') { //no calculation of target address was possible
                    disas = '$----'; // so display  '$----' as target
                    break;
                }
                //(PVB end of ADD & MOD)
                var opv = u8(pc + 1); //(PVB COM) operand = displacement value
                var targ = pc + 2; //(PVB COM) min target for calculation
                if (opv & 0x80) { //(PVB COM) negative displacement if bit #7 is on
                    targ -= (opv ^ 255) + 1; //(PVB COM) compute the backward displacement = (displacement XOR $FF) + 1
                }
                else { //(PVB COM) forward displacement
                    targ += opv; //(PVB COM) target = jump length
                }
                targ &= 0xffff; //(PVB COM) clipping to 64K boundary
                disas = '$' + hex(targ, 4); // 'disas' string looks like 'BNE $targ' -> 'BNE $A000'
                break;
            case 'ind':
                ops += ' ' + op1 + ' ' + op2;
                disas = '($' + op2 + op1 + ')';
                break;
            case 'imp': //(PVB ADD) guess it was "imp" implied by default
            default: //(PVB ADD) in case of we miss an 'adm' type
                ops += '      '; // no ops string and 'disin' variable will contain the instruction
                break;
        }
        // add symbols
        // (PVB ADD) use the new function get_symbol():
        // - to retrieve memory equate symbol for XL, A800, A5200
        // - and for CHIP ROM, make the difference in Sym equate & displayed text if read (R) or if write (W) 
        switch (adm) {
            //zero page address instructions
            case 'zpg':
            case 'zpx':
            case 'zpy':
            case 'inx':
            case 'iny':
                symbol = get_symbol(op1);
                break;
            //normal address instructions
            case 'abs':
            case 'abx':
            case 'aby':
            case 'ind':
                if (op2 == '00') { //in case of 2-byte adress operand is in zero page like 'CMP $0052'
                    symbol = get_symbol(op1);
                }
                else {
                    symbol = get_symbol(op2+op1, instr);
                }
                break;
        }
        if (ops == '')
            ops = '        ';
        //(PVB MOD) change and improve the "valid" management
        //previously // var valid = instr && disas != '???';
        if (disin == '???') valid = false; //disin = disassembled instruction like 'CMP'
        //mark validity, entry and exit points:
        //in the memory flag chart: 
        // 0x01 = opcode is valid
        // 0x02 = "BRK" opcode (PVB ADD)
        // 0x04 = entry_point, with 0x80 = 0x84 (PVB ADD)
        // + 0x08 = end of block => request empty line after block
        // 0x10 = "RTS" opcode
        // 0x20 = "RTI" opcode
        // 0x40 = "JMP" opcode
        // + 0x80 = start of block => request empty line before block - target of relative instruction (BEQ..) are flagged with 0x80 to start a new block
        //(PVB MOD) mark validity in flags improvment as described below
        if (valid) { 
            for (var i = 0; i < step; i++){
                flags[i + pc] |= 1;    // valid code
            }
            var a = (step > 2) ? (ram[pc + 1] + (ram[pc + 2] << 8)) : -1; //a = destination address, -1 if not valid (in case of end-of-file was reached)
            switch (instr) {
                case 0x20: // jsr JSR
                    //check the validity of the destination address, for JSR opcode $20 it is mandatory as data $20 $20 $20... are also space chars in code !
                    if ((a >= 0) && (opctab[u8(a)][0] != '???')) { //instruction at target is valid (zero is valid because somewhere in the memory but not loaded at that time),
                        if ((r > 2) && (opctab[u8(pc+3)][0] != '???')) //if there is remaining code to dissassemble && next instruction after JSR is valid
                            if (!_bShowDisBRK && !(flags[a] & 0x02)) //if not already a BRK 
                                flags[a] |= 0x81; //target is validated 
                    }
                    break; 
                case 0x4C: // jump JMP
                    //check validity of destination address
                    if (a >= 0 && opctab[u8(a)][0] != '???') { //instruction at target is valid (zero is valid)
                        flags[a] |= 0x81; //target is validated
                    }
                    flags[pc] |= 0x48; // + 0x08 jump a ligne after
                    break;
                case 0x6C:  //JMP (indirect)
                    a = -1; //no destination since it's an indirect, like JMP (DOSINI) => DOSINI is not the destination address, but its content yes
                    flags[pc] |= 0x48; // + 0x08 jump a ligne after
                    break;
                case 0x40: flags[pc] |= 0x28; a = -1; break; // rti // + 0x08 jump a ligne after
                case 0x60: flags[pc] |= 0x18; a = -1; break; // rts // + 0x08 jump a ligne after
                case 0x00: flags[pc] |= 0x02; a = -1; break; // brk instruction
                default:
                    a = -1;
            }
            // (PVB ADD) create hyperlink to destination and display in bold if OPTION '_bShowDisLinks' is true
            if (_bShowDisLinks)
                if (a != -1) { //for JMP & JSR if destination 'a' is valid
                    disin = '<b>' + disin;
                    disas = '<a href="#PCn' + _nBankId + '$' + hex(a,4) + '">' + disas + '</a></b>';
                }
                else {
                    if (flags[pc] & 0x08) { //make it display in bold for RTS, RTI et JMP (ADD)
                        disin = '<b>' + disin;
                        disas = disas + '</b>';
                    }
                }
            // (PVB ADD) handle the 'rel' instruction (BEQ, BNE, Bxx...) validity and target validity
            if (adm == 'rel' && step > 1) { //if step == 1, there was no operand because end of file was reached, so no check exit 'if' statement
                //by default, invalid the 'rel' instruction, and seek and set validity...
                flags[pc] &= 0xFE;
                flags[pc+1] &= 0xFE;
                valid = false;
                var c = false;
                while (true) { //PVB says there nothing like an infinite loop to break ;-)
                    if ((pc != 0) && !(flags[pc-1] & 0x01)) break; // previous is not valid (seen if the flag) => exit
                    //check the next instruction validity
                    if (flags[pc] & 0x08) { //if there is already a flag set, it means we are at the second 'rel' in the pair like BEQ/BNE
                        c = true; //so 'rel' is valid
                        break; //and exit without any other verification
                    } 
                    if (pc > 0xFFFD) break; // if so, checking of the next instruction at pc+2 is not possible, so exit
                    if (ram[pc+2] == ram[pc]) break; // next is the same 'rel' instruction, like BNE xx BNE xx, we assume not possible, exit
                    if ((pc > 1) && ((ram[pc-2] == 0xA9) || (ram[pc-2] == 0xA0) || (ram[pc-2] == 0xA2))) {
                        //the previous instruction is a load imm like LDA #$00, the load imm sets the 'rel' status
                        flags[pc] |= 0x08; //valid 'rel' jump => so we set the flag for a line feed to create a block before
                    } //(PVB TODO) we could validate the same with "store" & "transfer" instruction, and 6502 flag set instruction like SEC/BCS & CLC/BCC
                    if (opctab[u8(pc + 2)][0] == '???') break; // if the next instruction at PC+2 is unknown => exit
                    if (!_bShowDisBRK && opctab[u8(pc + 2)][0] == 'BRK') break; //if the next instruction at PC+2 is BRK instruction => exit
                    //note : same as "if (!_bShowDisBRK && !ram[pc+2])"
                    if (!c && (opctab[u8(pc + 2)][1] == 'rel') && ((ram[pc] & 0xC0) == (ram[pc+2] & 0xC0))) { //check i's a pair with the next instruction like BEQ/BNE
                        //for a pair, 'rel' have same bits #7 #6 (0xC0), they only differ on bit #5, remaining bits are always 0x10.
                        flags[pc + 2] |= 0x08; //valid 'rel' jump pair => so we set the flag for a line feed to create a block
                    }
                    //at this point we have a valid 'rel' instruction, next instruction is OK (or it is a BRK that is accepted)
                    //or next is not OK but 'rel' is OK thanks to previous instruction like in "LDA #$00 BEQ XXX"
                    //or next instruction is also a 'rel' pair like BEQ/BNE..
                    c = true; //so set 'rel' as a valid instruction
                    break; //and exit loop
                }      
                //and now, let's check the target...
                if ((c && (opctab[u8(targ)][0] == '???') || (!_bShowDisBRK && !ram[targ]))) {
                    //if instruction at target is unknown or is equal to zero (BRK) memory not accepted)
                    c = false; //'rel' is no more valid
                }
                if (c) { //validation of 'rel' instruction if c = true
                    flags[targ] |= 0x81; // target set to valid
                    if (_bShowDisLinks) {
                        disas = '<a href="#PCn' + _nBankId + '$' + hex(targ,4) + '">' + disas + '</a>'; //create hyperlink to destination
                    }
                    flags[pc] |= 1;
                    flags[pc+1] |= 1;
                    valid = true;
                }   
            } 
        }
        //(PVB ADD) mark the end of disassembly
        if ((valid && (op1 == ".." || op2 == ".."))) {
            flags[pc] &= 0xFE;
            valid = false;
            if (!inner)
                disas += ' <span style="color:red;">[!End of data or max address reached!]</span>';
        }
        //(PVB ADD) Add the ROM bank number id for ROM disassembly
        if (_bShowROMBank && _nBankId)
            addr = "n" + _nBankId + ":" + addr;
        // then finaly make the asm listing
        asm.push({
            pc: pc, step: step, valid: valid,
            s: addr + '   ' + ops + '   ' + disin + ' ' + disas + (symbol ? " ; " + symbol[0] + (symbol[1] ? (" <i>" + " >" + symbol[1] + "</i>") : "") : "")
         });
        return (pc + step);
    }

    //  First disassembly pass
    //(PVB MOD) improvement of disassemble() function 
    function disassemble(addr, data, i, len, ram, flags) {
        //(PVB COM) "addr" = disassembly start address, "data" = data to disassemble (bytes array), "len" = number of bytes to disassemble 
        //array of variables : "ram" byte array that is the 64KB Atari memory (0-$FFFF) where data are copied, and corresponding byte array of "flags"
        var asm = []; //asm is the disassembly result (string of text)
        //(PVB ADD) add a protection in order not to overpass the 0xFFFF in the "ram" byte array !
        if ((addr + len) > 0x10000) { //len + start address should not be greater than 0xFFFF otherwise there is a bug
            len = 0x10000 - addr; //if it is the case, len is decreased (clipped) to max 64K memory = 0xFFFF
            console.log("disassemble() => has limited the lenght of block to disassemble for not overpass 0xFFFF");
        }
        //(PVB end of ADD)
        for (var j = 0; j < len; j++) //(PVB COM) 'data[]' are stored in the corresponding 'ram[]' 64K buffer at the real starting address
            ram[addr + j] = data[i + j];
        var pc = addr;
        var lastopcode =  addr + len; //(PVB ADD) Adde the 'lastopcode' variable feature for handling the last opcode issue & stop fetching from the memory, 
        while (pc < lastopcode) {
            //(PVB MOD) pc = lastopcode for the last instruction byte
            pc = disassembleStep(pc, ram, asm, flags, lastopcode-1, false); //inner = false
        }
        return asm;
    }
    
    // Two pass: disassembly then basic blocks
    //(PVB MOD) improvement of disassemble2() function
    // _nBankId global variable (initialized in xex_dump() function) is used
    // _nBankId = "" if no rom, or _nBankId = number of bank to disassemble if rom
    // nSeg for the segment number for tagging disassembly links
    // segData, segStart for retrieving data from the segments and not from the "ram" that can be overloaded by segments
    function disassemble2(asm, str, ram, flags, nSeg, segData, segStart) {
        var start = 0xFFFF; //overall of asm
        var end = 0;        //overall of asm
        var blocks = [];
        var block = { lines: [], errs: 0, bll: 0 };
        var nbrk = 0;
        //(PVB HINT! ) ***************** here Javascript variable for dev. *************************************
        var _sh = false; //if true => valids the console.log() for displaying disassembling hints in the console

        //(PVB MOD) initialization of the "asm" array
        function asmlist_add_flags(asmlist) {
            asmlist.forEach(a => { // for each desassembly lines
                a.flags = flags[a.pc];
                start = Math.min(start, a.pc);
                end = Math.max(end, a.pc + a.step); //(PVB MOD)
                if (_bShowDisFlags)
                    a.s = "["+ hex(a.flags) + "]" + a.s; //(PVB COM) show the flag for each line
            });
        }

        function separator() {
        if (str[str.length - 1] == "")
                return;
            str.push("");
        }

        function end_of_lines(lines) {
            return lines[lines.length - 1].pc + lines[lines.length - 1].step;
        }

        function runny(lines) {
            if (lines === undefined)
                return false;
            if (!lines[0].pc)
                console.log("disassemble2()/runny() =>Huston we've got a problem: lines[0].pc = " + lines[0].pc);
            var start = lines[0].pc;
            var end = end_of_lines(lines); //end is not included (end is the 1st instruction of next block)
            if ((end - start) < 4) //(PVB MOD) Runny lines are considered only after 3 instructions (i.e. 4C 4C4C is valid within a block)
                return;
            for (var i = start + 1; i < end; i++)
                if (ram[start] != ram[i])
                    return false;
            return true;    // All data is the same value in all the lines
        }

        function as_data(blocks) { //(PVB COM) "Show as Code" = as data; create Hexdump to display in case of non disassembled code
            var from = blocks[0].lines[0].pc;
            var to = end_of_lines(blocks[blocks.length - 1].lines);
            var di = to - from; //(PVB ADD) to simplify

            var key = hex(from, 4);
            var stmp = '' + (nSeg ? hdx(nSeg) : _nBankId); //(PVB ADD) segment or rom bank add
            //(PVB ADD) the _nBankId in the "show as code" id selector
            str.push(`; Data block of $${hdx(di)} (${di}) bytes at $${key}:${hex(to - 1, 4)}<em class='showcode' onclick='toggle("#C${stmp}_${key}")'>Show As Code</em>`);
            //  stick all the code in too
            str.push(`<div id='C${stmp}_${key}' style='color:#00F; display:none'>;`); //(PVB MOD) color set to blue instead of red
            blocks.forEach(block => block.lines.forEach(line => str.push(line.s)));
            str.push(`</div>;`);

            while (from < to) {
                var mx = 16 - (from & 0xF);
                var n = Math.min(mx, to - from);
                //(PVB ADD) display the _nBankId if _bShowROMBank flag and _nBankId not empty
                stmp = _bShowROMBank && _nBankId ? ('n' + _nBankId + ':') : '';
                //(PVB ADD) if segments, then use data from the segments and not from the "ram"
                stmp += segData ? hex_line(from, segData, (from - segStart), n, 4) : hex_line(from, ram, from, n, 4);
                str.push(stmp);
                from += n;
            }
            str.push(";");
            separator(); //line feed in the disassembly
        }

        // slice into blocks, mark those
        function flush_block() {
            //(PVB COM) create a block
            if (block.lines.length) {
                block.bll = block.lines.length;
                blocks.push(block);   
            }
            block = { lines: [], errs: 0, bll: 0}; //and initialize new empty block
        }
        //(PVB ADD)
        function make_disas_anchor(a) {
            if ((a.flags & 0x01) && _bShowDisLinks) {
                a.s = a.s.replace(' ', ' </strong>');
                a.s = '<strong id="PCn' + _nBankId + '$' + hex(a.pc,4) + '">' + a.s; //create destination HTML anchor for disassembly address hyperlinks
            }
        }
        //(PVB END OF ADD)
        
        //(PVB MOD & ADD) disassemble2() starts now here
        asmlist_add_flags(asm);
        nbrk = 0;
        asm.forEach(a => {
            //(PVB ADD) add a tolerance of 2 errors when this is a BRK instruction if _bShowDisBRK
            if (a.flags & 0x02) { //BRK instruction
                if (_bShowDisBRK && (nbrk < 3)) {
                    nbrk++;
                }
                else {
                    block.errs++;
                    nbrk = 0;
                }     
            }
            //else { //else activated = BRK can not be a jump Target
                if (a.flags & 0x80) { //if the asm listing encounter a 0x80 then create a new block
                    make_disas_anchor(a);
                    if (a.flags & 0x04) //if 0x84 then this is an entry point
                        a.s = ";<i><b>[Entry_Point]</i></b><br />"+ a.s;
                    flush_block(); //creat new block starting with 0x81
                }
            //}
            block.lines.push(a); //put asm listing in a new block lines

            if (!a.valid)
                block.errs++; //(PVB COM) errs++ counts the number of error in the block, that is the number of "valid = false"
            
            //if the asm listing encounter a 0x08 then create a new block
            if ((a.flags & 0x08) && !block.errs)
                flush_block();
        });

        flush_block(); // the last block is created
        separator(); //line feed in the disassembly
        
        // determine if each block is ASM or DATA

        //(PVB MOD) block analysis and adjust disassembly listing if needed
        var tmpb = [];
        var blen, pcmax, pcmin;
        var b = 0;
        var b2;
        var f = 0;
        var lb, nbe, pbe;

        //check each 'b' blocks for validity set in the above "asm.forEach" loop
        for (b = 0; b < blocks.length; b++) { //for each block in blocks
            if (runny(blocks[b].lines)) {
                blocks[b].errs = 1; //RULE : the current block shall not contain the same bytes value
            }
            //if (b > 0 && b < (blocks.length - 1)) { //not the first block, neither the last => replaced by 'lb'
            lb = (b == (blocks.length - 1)) ? true : false;
            if (b > 0) pbe = blocks[b - 1].errs ? true : false; else pbe = false;
            if (!lb) nbe = blocks[b + 1].errs ? true : false; else nbe = false;
            //checking validity of blocks...
            while (true) { //PVB says there is nothing like a while(true) loop to avoid chaining the if/else...
                tmpb = blocks[b]; //copy of current block
                if (!tmpb.bll) {
                    if (_sh) console.log("Skipping block b=" + b + " that is empty...");
                    break; //if empty block then exit the loop (and go to next block)
                }
                if (tmpb.errs) {
                    //if (_sh) console.log("Skipping block b=" + b + " that has " + tmpb.errs + " errors...");
                    break; //if non valid block then exit the loop (and go to next block)
                }
                if (!nbe && !pbe) {
                    //if (_sh) console.log("Skipping block b=" + b + " that has no error, like next and previous");
                    break; //exit the loop (and go to next block)
                }
                blen = tmpb.lines.length; //block number of lines
                f = tmpb.lines[0].flags;
                if (blen != tmpb.bll) console.log("disassemble2() Huston we've got a problem: 'blen' is not equal to 'tmpb.bll'");
               
                if (_sh) console.log("!>Chekking block b=" + b + ", errs=" + tmpb.errs + ", lines length=" + tmpb.lines.length + ", PC=" + hex(tmpb.lines[0].pc,4));

                if (blen == 1) { // RULE for a single line block //
                    if (_sh) console.log(" ...one line checking...");
                    //RULE: if a block is a valid one-line instruction, before an invalid block [nbe],
                    //it must be the end of block, hence containing the 0x08 flag (JMP, RTI, RTS, BXX pair) => otherwise invalid current block
                    if (nbe && !(f & 0x08)) { //if next block invalid && the single block is not "a end of block" like JMP, RTI, RTS, BXX couple
                        tmpb.errs = 1;
                        if (_sh) console.log(" --1- >>single line block before invalid block shall end with JMP, RTI, RTS or Bxx pair!")
                        if (!pbe && b > 0) { //if previous was valid...
                            b = b - 2; // re-check previous block by decreasing b (-2 because the for loop increase by 1)
                        }
                        break;
                    }
                    //RULE: if the one-line valid block containing a single RTI, RTS ou JMP (that is a 0x70)
                    // => cannot be after an invalid block [pbe] (except if containing the 0x80 flag)
                    // => cannot follow a valid block that already ends with RTI, RTS instruction (that is a 0x30) (except if containing the 0x80 flag)
                    if ((f & 0x70) && !(f & 0x80)) { //the single line is RTS, RTI, JMP; and does not contain a 0x80 flag
                        if (pbe) { //if previous block is not valid
                            tmpb.errs = 1; //then block not valid
                            if (_sh) console.log(" --2- >>cannot have a single line RTS/RTI/JMP without 0x80 flag after invalid block!");
                            break;
                        }
                        else { // if previous block is valid
                            if ((b>0) && (blocks[b - 1].lines[(blocks[b - 1].lines.length - 1)].flags & 0x30)) { //if previous block also ends with RTS or RTI
                                tmpb.errs = 1; //then block not valid
                                if (_sh) console.log(" --3- >>cannot have a single line RTS/RTI/JMP without 0x80 flag after a block ending with RTS/RTI/JMP!");
                                if (!pbe && b>0) { //if previous was valid...
                                    b = b - 2; // re-check previous block by decreasing b (-2 because the for loop increase by 1)
                                }
                                break;
                            }
                        }
                    }
                    //RULE: the one-line valid block cannot have the same instruction as the previous block
                    if (b>0 && pbe) { //if previous block is not valid
                        var s0 = tmpb.lines[0].s.substring((tmpb.lines[0].s.indexOf('  ')))
                        var s1 = blocks[b-1].lines[0].s.substring((blocks[b-1].lines[0].s.indexOf('  ')));
                        if (s0 && s1 && (s0 == s1)) { //the single ligne is same as the previous (instruction & operands)
                            tmpb.errs = 1; //then block not valid
                            if (_sh) console.log(" --4- >>2 lines of instruction identical found!");
                            break;
                        }
                    }
                    break;    
                }//END OF RULE for a single line block

                //RULE for normal current valid & previous invalid
                if (pbe && !(f & 0x81 == 0x81)) { //if no 0x81 flag at the beginning of block, then invalidate
                    tmpb.errs = 1;
                    if (_sh) console.log(" --5- => current block shall start with valid 0x81 flag when previous is not valid")
                    break;
                }
                //RULE for normal current valid, next invalid and last line of current valid block not ending with 0x08
                var r = false;
                if (!lb)
                    r = runny(blocks[b+1].lines);
                if ((r || nbe) && !(tmpb.lines[(blen-1)].flags & 0x08)) {
                    tmpb.errs = 1;
                    if (_sh) console.log(" --6- => cannot have a next block invalid and current block not ending with RTS/RTI/JMP 0x08 flag")
                    if (!pbe && b>0) { //if previous was valid...
                        b = b - 2; // re-check previous block by decreasing b (-2 because the for loop increase by 1)
                    }
                    break;
                }
                
                if (_sh) console.log("  => end of block " + b + " verification---");
                break; //security
            } //end Of while(true) for checking validity of blocks...
        } //end of 'for' loop for all blocks  

        //Code loop for Searching for 0x80 flags in previous unvalid block, and rajust disassembly listing block
        for (b = 1; b < blocks.length; b++) { //for each block in blocks starting at block #1
            //if current block is valid, but previous is not, then
            //seek the 0x81 hidden flag in the previous and if needed reajust block disassembly
            pbe = blocks[b - 1].errs ? true : false;
            b2 = b; //save b in b2
            if (!blocks[b].errs && pbe) { //RULE for current valid block && previous invalid;
                tmpb = blocks[b-1]; //tmpb = previous

                var pc, i, pc_flag, b2;
                var errs, ite = 0;
                var tmpasm =[];
                var m = false;

                blen = tmpb.lines.length
                pcmax = tmpb.lines[blen - 1].pc + tmpb.lines[blen - 1].step; //pcmax not included, it is the pc of next block
                pcmin = tmpb.lines[0].pc;
                while (true) { // as long as we find 0x80 flags in the non-valid current block
                    if (!blen) break; //protection just in case
                    ite ++;
                    if (_sh) console.log("!>Seek 0x80 flags in previous Block b-1=" + (b-1) + " of "+ blocks.length + ", line len=" + blen + ", iteration #" + ite + ", PC=" + hex(pcmin,4) + "-" + hex(pcmax,4));
                    //search a hidden 0x81 from the end of block
                    if (m) //if m then a first one has been found but was wrong
                        i = pc_flag - 1;
                    else
                        i = pcmax - 1 ; //i is set to PcMax of the block
                    m = false; //reset
                    while (i > pcmin) {
                        if (flags[i] & 0x80) {
                        //if ((flags[i] & 0x81) == 0x81) {
                            pc_flag = i;
                            m = true;
                            break; // exit the "while" loop
                        }
                    i--;
                    }
                    if (!m) {
                        if (_sh) console.log("  >>Nothing found !");
                        break;
                    } // flag 0x81 not find, so exi0 &&
                    tmpasm =[];
                    pc = i;
                    while (pc < pcmax) {
                        pc = disassembleStep(pc, ram, tmpasm, flags, pcmax-1, true);
                    }
                    if (pc != pcmax) { // disassembly does not match the current disassembly, so exit the while (true) loop!
                        if (_sh) console.log("  >>but no recovery with current block b=" + b + " ! ..continue..");
                        continue;
                        //break;
                    } 
                    //prepare new asm list and check the validity (errs)
                    errs = 0;
                    tmpasm.forEach(a => {
                        a.flags = flags[a.pc];
                        if (_bShowDisFlags)
                            a.s = "[" + hex(a.flags) + "]" + a.s;
                        if (a.flags & 0x80)
                            make_disas_anchor(a);
                        if (!a.valid)
                            errs++;
                    });
                    if (errs) {
                        if (_sh) console.log("  >>but previous Block b-1=" + (b-1) + " has errors! ..continue..");
                        // if there is non-valid in the disassembly, return to the beginnning of loop to find another 0x81
                        continue; 
                    }
                    if (_sh) {
                        console.log("  >>Previous Block b-1=" + (b-1) + " making OK >>tmplines :");
                        console.log(tmpasm);
                    }
                    //push new valid block into the blocks list at next position
                    blocks.splice(b, 0, {lines: tmpasm, errs: 0, bll: tmpasm.length});
                    b2++; //index of the current block is +1
                    if (_sh) console.log("  >>Block b=" + b + " created in the block chart !!, Nbr of blocks=" + blocks.length);
        
                    // reajust the first part of the current block (before the found 0x81)
                    pc = pcmin; //pc for the 1st line
                    tmpasm = []; //reset
                    while (pc < pc_flag) {
                        pc = disassembleStep(pc, ram, tmpasm, flags, pc_flag-1, true);
                    }
                    errs = 0;
                    tmpasm.forEach(a => {
                        a.flags = flags[a.pc];
                        if (_bShowDisFlags)
                            a.s = "[" + hex(a.flags) + "]" + a.s;
                        if (!a.valid)
                             errs++;
                    });
                    blocks[b-1].lines = tmpasm;
                    blocks[b-1].errs = errs;
                    blocks[b-1].bll = blocks[b-1].lines.length;
                    
                    //adjust the block
                    tmpb = blocks[b-1]; //copy of current block
                    blen = tmpb.lines.length;
                    if (!blen) break;
                    pcmax = tmpb.lines[blen - 1].pc + tmpb.lines[blen - 1].step;
                    m = false; // to analyse new remaining block
                    //back to the beginning of the while(true) loop
                }
                b = b2; //update block pointer after having added the previous blocks
            }
        }//end of for loop

        // determine if each block is ASM or DATA
        var first_code = true;
        separator();
        var data = [];
        if (_sh) console.log("!>making block of Data");
        blocks.forEach(block => {
            if (block.errs || runny(block.lines)) {
                data.push(block);           // start of data
            } else {
                if (first_code) {
                    str.push("; <b>Disassembly listing from $" + hex(start, 4) + " to $" + hex(end - 1, 4) + ":</b>\n");
                    first_code = false;
                }
                if (data.length) {
                    as_data(data);    // end of data
                    data = [];
                }
                block.lines.forEach(a => str.push(a.s));
            }
            separator();
        });
        if (_sh) console.log("  => end of block of Data making!");
        if (data.length)
            as_data(data);
        separator();
    }

    // eof

    //===================================================================================================
    //===================================================================================================

    function le16(a, i) {
        return a[i] | ((a[i + 1]) << 8);
    }

    function le24(a, i) {
        return a[i] | ((a[i + 1]) << 8) | ((a[i + 2]) << 16);
    }

    function le32(a, i) {
        return a[i] | ((a[i + 1]) << 8) | ((a[i + 2]) << 16) | ((a[i + 3]) << 24);
    }

    function is_zero(d, i, len) { //function is_zero() returns true if there is len 00 bytes from d[i]
        while (len--)
            if (d[i++])
                return false;
        return true;
    }

    function toAscii(a, i, len) {
        var s = '';
        while (len--)
            s += String.fromCharCode(a[i++] & 0x7F); //(PVB MOD) add the 0x7F mask to force the inverted Atari char into normal ($80-$FF => $00-$7F)
        return s;
    }
    
    //(PVB ADD) isAtariNameChar(str, md) function used in one_dir() to check if the DOS filename is valid
    function isAtariNameChar(str, md) { //isAtariText // valid filename char are 'space' 0-9 A-Z a-z; and '@' and '_' for myDOS fileName
        var er = 1;
        if (str[0] == 0x20 || (str[0] >= 0x30 && str[0] <= 0x39)) er = -1; // invalid filename because starts with a 'space', or by a number
        for (var i = 0; i < str.length; i++) {
            if (str[i] & 0x80) er = -1; //use of unsual inverted chars (not a guenuine DOSx filename)
            var c = str[i] & 0x7F; //convert inverse char
            if (!(c == 0x20 || (c >= 0x30 && c <= 0x39) || (c >= 0x41 && c <= 0x5A) || (c >= 0x61 && c <= 0x7A))) { //not OK if not alphabet
                if (c == 0x2A || c == 0x2D || c == 0x2E)
                    er = -1; //unsual '*', '-' and '.' chars, not in genuine DOSx filename
                else if (!(md && (c == 0x40 || c == 0x5F)))
                    return 0; //not OK if not '@' or '_' (for myDOS fileName)
            }
        }
        return er;
    }
    //(PVB END OF ADD)

    function err(e) {
        _m("#err", "#toc", { err: e });
    }

    function ataritext(a) { //called by show_txt(f) to read txt, just before show_ataritext(f, t)
        var s = '';
        var lst = [];
        for (var i = 0; i < a.length; i++) {
            if (a[i] == 0x9B) {
                lst.push(s);
                s = '';
            } else
                s += String.fromCharCode(a[i]);
        }
        if (s.length)
            lst.push(s);
        return lst;
    }

    function parse_failed(f) {
        return [`Can't parse ${f.name} as a ${f.ext} file`]; //'
    }

    function show_m65(f) {
        var asm = mac65(f.data, 0, f.data.length);
        // expand tabs?
        show_ataritext(f, asm ? asm : parse_failed(f));
    }

    function show_bas(f) {
        var t = ataribasic(f.data, 0, f.data.length);
        show_ataritext(f, t ? t.listing : parse_failed(f));
    }

    function show_txt(f) {
        var t = ataritext(f.data, 0, f.data.length);
        show_ataritext(f, t);
    }

    // 160*192 2 bit + [4 byte palette]
    function show_img(f) {
        render_file(f);
        var c = _q("#show");
        var aspect = render_image(c, f);
        resize_parent(c, aspect[0], aspect[1]);
    }

    // https://github.com/TheRobotFactory/EightBit-Atari-Fonts
    function show_fnt(f) {
        var pal = _reload_palette ? [0, 5, 10, 15] : _palette.slice();
        var multicolor = _checks['multicolor'];

        function fnt(n, len) {
            var space = (n & 0x80) ? String.fromCharCode(128 + 32) : ' ';
            var s = space;
            for (var i = 0; i < len; i++)
                s += String.fromCharCode(n + i);
            return s + space;
        }
        var inverted = '';
        for (var i = 0; i < 34; i++)
            inverted += String.fromCharCode(32 + 128);

        var t = [];
        t.push("");
        t.push(fnt(32, 32)); t.push("");
        t.push(fnt(64, 32)); t.push("");
        t.push(fnt(0, 32)); t.push("");
        t.push(fnt(96, 32)); t.push("");
        t.push(inverted);
        t.push(fnt(32 + 128, 32)); t.push(inverted);
        t.push(fnt(64 + 128, 32)); t.push(inverted);
        t.push(fnt(0 + 128, 32)); t.push(inverted);
        t.push(fnt(96 + 128, 32)); t.push(inverted);
        var s = [
            "",
            "YOU ARE IN A MAZE OF TWISTY",
            "LITTLE PASSAGES, ALL ALIKE.",
            "",
            " - Crowther & Woods",
            "",
            "",
            "Never argue with an idiot.",
            "They will drag you down to their",
            "level and beat you with",
            "experience.",
            "",
            " - Mark Twain",
            "",
            "",
            "Nobody ever figures out what",
            "life is all about, and it doesn't",
            "matter. Explore the world. Nearly",
            "everything is really interesting",
            "if you go into it deeply enough.",
            "",
            " - Richard P. Feynman",
            "",
        ];
        s.forEach(line => t.push(' ' + line));
        t.push("");
        show_font(f, t, f.data, multicolor ? _palette : null);
    }

    //(PVB MOD) update the list of possible extensions
    var _exts = {
        "atr": { name: "ATR Disk Image", is_disk: true },
        "atx": { name: "ATX Disk Image", is_disk: true },
        "pro": { name: "PRO Disk Image", is_disk: true },
        "xfd": { name: "XFD Disk Image", is_disk: true },
        "dcm": { name: "DCM Disk Image", is_disk: true }, //(PVB ADD)
        "dsk": { name: "Raw Sectors for Disk Image File", is_disk: true }, //(PVB MOD)

        "dat": { name: "Raw Data or DAT Image File (default)", is_dat: true }, //(PVB MOD)
        "arc": { name: "ARC Archive of Image File"},

        "--0": { name: "Languages (formated text files)" }, //(PVB MOD)
        "bas": { name: "Atari Basic/Turbo Basic XL", is_txt: true },
        "lst": { name: "Atari Basic Listing", is_txt: true },
        "asm": { name: "Assembly Listing", is_txt: true },
        "m65": { name: "MAC/65 Assembly Listing", is_txt: true },
        "lis": { name: "Listing", is_txt: true },
        "doc": { name: "Document", is_txt: true },
        "ata": { name: "ATASCII Text File", is_txt: true },
        "txt": { name: "Text File", is_txt: true },
        "bat": { name: "Batch File", is_txt: true },
        "man": { name: "Manual", is_txt: true },

        "--1": { name: "Font & Graphics" },
        "fnt": { name: "Font File", is_fontset: true }, //(PVB MOD)
        "chr": { name: "Font File", is_fontset: true }, //(PVB MOD) chr instead of set

        "gr7": { name: "Graphics 7 Image", is_img: true },
        "gr8": { name: "Graphics 8 Image", is_img: true },
        "gr9": { name: "Graphics 9 Image", is_img: true },
        "g10": { name: "Graphics 10 Image", is_img: true },

        "mic": { name: "Micropainter Image", is_img: true },
        "mcp": { name: "McPainter/Paradox Image", is_img: true },
        "apc": { name: "APAC 256 Color Image", is_img: true },
        "plm": { name: "Plasma 256 Color Image", is_img: true },
        "pzm": { name: "Pryzm Artist Image", is_img: true },
        "ilc": { name: "Digi Paint Image", is_img: true },
        "inp": { name: "InterPainter Image", is_img: true },
        "cin": { name: "Champions' Interlace", is_img: true },
        "pic": { name: "Koala MicroIllustrator", is_img: true },
        "raw": { name: "XL-Paint MAX Image", is_img: true },
        "scr": { name: "Atari Graphics Works Image", is_img: true },
        "ist": { name: "Interlace Studio Image", is_img: true },
        "rip": { name: "Rocky Interlace Picture", is_img: true },
        "hip": { name: "Hard Interlace Picture", is_img: true },
        "tip": { name: "Taquart Interlace Picture", is_img: true },
        //(PVB MOD & ADD) here after file are 'code' an not 'text'; add the "is_romdump" flag; add the "a52" extension
        //(PVB COM) all "is_code" files are either binary DOS file or ROM (memory dump) file; check is done in load_one() and load_data()
        "--2": { name: "Executable Atari DOS Files & Dumps" },
        "sys": { name: "DOS System file", is_code: true, has_header: true }, //(PVB MOD) "sys" are special DOS files and can have $FFFF header that is checked in xex_dump()
        "obj": { name: "Object Code (data or executable)", is_code: true, has_header: true }, //(PVB MOD) 'OBJ' can have header 0xFFFF
        "xex": { name: "Load and Go Executable", is_code: true, has_header: true }, //(PVB MOD) usually has 0xFFFF header
        "exe": { name: "Load and Go Executable", is_code: true, has_header: true }, //(PVB MOD) usually has 0xFFFF header
        "com": { name: "Load and Go Executable", is_code: true, has_header: true }, //(PVB MOD) usually has 0xFFFF header
        "bin": { name: "Atari Raw Binary Dump File", is_code: true, is_romdump: true }, //(PVB ADD) "bin" is a DOS file of raw binary bytes without header; or ROM dump
        "rom": { name: "ROM Dump Image File", is_code: true, is_romdump: true }, //(PVB MOD) ROM dump, or binary equivalent 'BIN' if in a DOS File
        "a52": { name: "Atari 5200 Rom Dump Image File", is_code: true, is_romdump: true }, //(PVB ADD) ROM dump of Atari 5200 ROM
        "car": { name: "Cartridge Image File with CART header", is_code: true, is_romdump: true } //(PVB MOD) ROM dump with CART header
    };
    
    //(PVB ADD) Added the ROM Types table from
    //https://github.com/atari800/atari800/blob/master/DOC/cart.txt
    var _romtypes = {
        "Type_##" : {machine : "on Machine...", size : "Size in KB...", name : "Cart name..."}, //memmap: [size (in page HB), start address (in page HB), number of bank at same address]
        "Type_00" : {machine : "Unknown", size : "0", name : "Unknown CART cartridge", memmap : [0, 0, 0]},
        "Type_01" : {machine : "800/XL/XE", size : "8", name : "Standard 8 KB cartridge", memmap : [0x20, 0xA0, 1]},
        "Type_02" : {machine : "800/XL/XE", size : "16", name : "Standard 16 KB cartridge", memmap : [0x40, 0x80, 1]},
        "Type_03" : {machine : "800/XL/XE", size : "16", name : "OSS two chip 16 KB cartridge (034M)", memmap : [0x10, 0xA0, 3, 0x10, 0xB0, 1]},
        "Type_04" : {machine : "5200", size : "32", name : "Standard 32 KB 5200 cartridge", memmap : [0x80, 0x40, 1]},
        "Type_05" : {machine : "800/XL/XE", size : "32", name : "DB 32 KB cartridge", memmap : [0x20, 0x80, 3, 0x20, 0xA0, 1]},
        "Type_06" : {machine : "5200", size : "16", name : "Two chip 16 KB 5200 cartridge", memmap : [0x20, 0x60, 1, 0x20, 0xA0, 1]}, //todo : handle copie bank (address duplicate)
        "Type_07" : {machine : "5200", size : "40", name : "Bounty Bob Strikes Back 40 KB 5200 cartridge", memmap : [0x10, 0x40, 4, 0x10, 0x50, 4, 0x20, 0xA0, 1]}, //todo : handle copie bank (address duplicate)
        //It exists an alternate Type_07 in Altirra : "Same as cart mapper 7 except that the fixed bank is first" as per Altirra sources "cartridgetypes.h"; that would be :
        //"Type_07" : {machine : "5200", size : "40", name : "Bounty Bob Strikes Back 40 KB 5200 cartridge (Alt Layout)", memmap : [0x20, 0xA0, 1, 0x10, 0x40, 4, 0x10, 0x50, 4]},
        "Type_08" : {machine : "800/XL/XE", size : "64", name : "64 KB Williams cartridge", memmap : [0x20, 0xA0, 8]},
        "Type_09" : {machine : "800/XL/XE", size : "64", name : "Express 64 KB cartridge", memmap : [0x20, 0xA0, 8]},
        "Type_10" : {machine : "800/XL/XE", size : "64", name : "Diamond 64 KB cartridge", memmap : [0x20, 0xA0, 8]},
        "Type_11" : {machine : "800/XL/XE", size : "64", name : "SpartaDOS X 64 KB cartridge", memmap : [0x20, 0xA0, 8]},
        "Type_12" : {machine : "800/XL/XE", size : "32", name : "XEGS 32 KB cartridge", memmap : [0x20, 0x80, 3, 0x20, 0xA0, 1]},
        "Type_13" : {machine : "800/XL/XE", size : "64", name : "XEGS 64 KB cartridge", memmap : [0x20, 0x80, 7, 0x20, 0xA0, 1]},
        "Type_14" : {machine : "800/XL/XE", size : "128", name : "XEGS 128 KB cartridge", memmap : [0x20, 0x80, 15, 0x20, 0xA0, 1]},
        "Type_15" : {machine : "800/XL/XE", size : "16", name : "OSS one chip 16 KB cartridge", memmap : [0x10, 0xB0, 1, 0x10, 0xA0, 3]},
        "Type_16" : {machine : "5200", size : "16", name : "One chip 16 KB 5200 cartridge", memmap : [0x40, 0x80, 1]},
        "Type_17" : {machine : "800/XL/XE", size : "128", name : "(decoded) Atrax 128 KB cartridge", memmap : [0x20, 0xA0, 16]},
        "Type_18" : {machine : "800/XL/XE", size : "40", name : "Bounty Bob Strikes Back 40 KB cartridge", memmap : [0x10, 0x80, 4, 0x10, 0x90, 4, 0x20, 0xA0, 1]},
        "Type_19" : {machine : "5200", size : "8", name : "Standard 8 KB 5200 cartridge", memmap : [0x20, 0xA0, 1]},
        "Type_20" : {machine : "5200", size : "4", name : "Standard 4 KB 5200 cartridge", memmap : [0x10, 0xB0, 1]},
        "Type_21" : {machine : "800", size : "8", name : "Right slot 8 KB cartridge", memmap : [0x20, 0x80, 1]},
        "Type_22" : {machine : "800/XL/XE", size : "32", name : "32 KB Williams cartridge", memmap : [0x20, 0xA0, 4]},
        "Type_23" : {machine : "800/XL/XE", size : "256", name : "XEGS 256 KB cartridge", memmap : [0x20, 0x80, 31, 0x20, 0xA0, 1]},
        "Type_24" : {machine : "800/XL/XE", size : "512", name : "XEGS 512 KB cartridge", memmap : [0x20, 0x80, 63, 0x20, 0xA0, 1]},
        "Type_25" : {machine : "800/XL/XE", size : "1024", name : "XEGS 1 MB cartridge", memmap : [0x20, 0x80, 127, 0x20, 0xA0, 1]},
        "Type_26" : {machine : "800/XL/XE", size : "16", name : "MegaCart 16 KB cartridge", memmap : [0x40, 0x80, 1]},
        "Type_27" : {machine : "800/XL/XE", size : "32", name : "MegaCart 32 KB cartridge", memmap : [0x40, 0x80, 2]},
        "Type_28" : {machine : "800/XL/XE", size : "64", name : "MegaCart 64 KB cartridge", memmap : [0x40, 0x80, 4]},
        "Type_29" : {machine : "800/XL/XE", size : "128", name : "MegaCart 128 KB cartridge", memmap : [0x40, 0x80, 8]},
        "Type_30" : {machine : "800/XL/XE", size : "256", name : "MegaCart 256 KB cartridge", memmap : [0x40, 0x80, 16]},
        "Type_31" : {machine : "800/XL/XE", size : "512", name : "MegaCart 512 KB cartridge", memmap : [0x40, 0x80, 32]},
        "Type_32" : {machine : "800/XL/XE", size : "1024", name : "MegaCart 1 MB cartridge", memmap : [0x40, 0x80, 64]},
        "Type_33" : {machine : "800/XL/XE", size : "32", name : "Switchable XEGS 32 KB cartridge", memmap : [0x20, 0x80, 3, 0x20, 0xA0, 1]},
        "Type_34" : {machine : "800/XL/XE", size : "64", name : "Switchable XEGS 64 KB cartridge", memmap : [0x20, 0x80, 7, 0x20, 0xA0, 1]},
        "Type_35" : {machine : "800/XL/XE", size : "128", name : "Switchable XEGS 128 KB cartridge", memmap : [0x20, 0x80, 15, 0x20, 0xA0, 1]},
        "Type_36" : {machine : "800/XL/XE", size : "256", name : "Switchable XEGS 256 KB cartridge", memmap : [0x20, 0x80, 31, 0x20, 0xA0, 1]},
        "Type_37" : {machine : "800/XL/XE", size : "512", name : "Switchable XEGS 512 KB cartridge", memmap : [0x20, 0x80, 63, 0x20, 0xA0, 1]},
        "Type_38" : {machine : "800/XL/XE", size : "1024", name : "Switchable XEGS 1 MB cartridge", memmap : [0x20, 0x80, 127, 0x20, 0xA0, 1]},
        "Type_39" : {machine : "800/XL/XE", size : "8", name : "Phoenix 8 KB cartridge", memmap : [0x20, 0xA0, 1]},
        "Type_40" : {machine : "800/XL/XE", size : "16", name : "Blizzard 16 KB cartridge", memmap : [0x40, 0x80, 1]},
        "Type_41" : {machine : "800/XL/XE", size : "128", name : "Atarimax 128 KB Flash cartridge", memmap : [0x20, 0xA0, 16]},
        "Type_42" : {machine : "800/XL/XE", size : "1024", name : "Atarimax 1 MB Flash cartridge", memmap : [0x20, 0xA0, 128]},
        "Type_43" : {machine : "800/XL/XE", size : "128", name : "SpartaDOS X 128 KB cartridge", memmap : [0x20, 0xA0, 16]},
        "Type_44" : {machine : "800/XL/XE", size : "8", name : "OSS 8 KB cartridge", memmap : [0x10, 0xB0, 1, 0x10, 0xA0, 1]},
        "Type_45" : {machine : "800/XL/XE", size : "16", name : "OSS two chip 16 KB cartridge (043M)", memmap : [0x10, 0xA0, 3, 0x10, 0xB0, 1]},
        "Type_46" : {machine : "800/XL/XE", size : "4", name : "Blizzard 4 KB cartridge", memmap : [0x10, 0xB0, 1]},
        "Type_47" : {machine : "800/XL/XE", size : "32", name : "AST 32 KB cartridge", memmap : [0x01, 0xBF, 256]},
        "Type_48" : {machine : "800/XL/XE", size : "64", name : "Atrax SDX 64 KB cartridge", memmap : [0x20, 0xA0, 8]},
        "Type_49" : {machine : "800/XL/XE", size : "128", name : "Atrax SDX 128 KB cartridge", memmap : [0x20, 0xA0, 16]},
        "Type_50" : {machine : "800/XL/XE", size : "64", name : "Turbosoft 64 KB cartridge", memmap : [0x20, 0xA0, 8]},
        "Type_51" : {machine : "800/XL/XE", size : "128", name : "Turbosoft 128 KB cartridge", memmap : [0x20, 0xA0, 16]},
        "Type_52" : {machine : "800/XL/XE", size : "32", name : "Ultracart 32 KB cartridge", memmap : [0x20, 0xA0, 4]},
        "Type_53" : {machine : "800/XL/XE", size : "8", name : "Low bank 8 KB cartridge", memmap : [0x20, 0x80, 1]},
        "Type_54" : {machine : "800/XL/XE", size : "128", name : "SIC! 128 KB cartridge", memmap : [0x40, 0x80, 8]}, //to check
        "Type_55" : {machine : "800/XL/XE", size : "256", name : "SIC! 256 KB cartridge", memmap : [0x40, 0x80, 16]}, //to check
        "Type_56" : {machine : "800/XL/XE", size : "512", name : "SIC! 512 KB cartridge", memmap : [0x40, 0x80, 32]}, //to check
        "Type_57" : {machine : "800/XL/XE", size : "2", name : "Standard 2 KB cartridge", memmap : [0x08, 0xB8, 1]},
        "Type_58" : {machine : "800/XL/XE", size : "4", name : "Standard 4 KB cartridge", memmap : [0x10, 0xB0, 1]},
        "Type_59" : {machine : "800", size : "4", name : "Right slot 4 KB cartridge", memmap : [0x10, 0x90, 1]},
        "Type_60" : {machine : "800/XL/XE", size : "32", name : "Blizzard 32 KB cartridge", memmap : [0x20, 0xA0, 4]},
        "Type_61" : {machine : "800/XL/XE", size : "2048", name : "MegaMax 2 MB cartridge", memmap : [0x40, 0x80, 128]}, //bank 0 first
        "Type_62" : {machine : "800/XL/XE", size : "128M", name : "The!Cart 128 MB cartridge", memmap : [0, 0, 0]}, //bank 0 first //(PVB TODO) =>not supported yet
        "Type_63" : {machine : "800/XL/XE", size : "4096", name : "Flash MegaCart 4 MB cartridge", memmap : [0x40, 0x80, 255]}, //bank 254 is ennable, no 255 bank
        "Type_64" : {machine : "800/XL/XE", size : "2048", name : "MegaCart 2 MB cartridge", memmap : [0x40, 0x80, 128]},
        "Type_65" : {machine : "800/XL/XE", size : "32M", name : "The!Cart 32 MB cartridge (!not supported yet)", memmap : [0, 0, 0]}, //bank 0 first //(PVB TODO) =>not supported yet
        "Type_66 ": {machine : "800/XL/XE", size : "64M", name : "The!Cart 64 MB cartridge (!not supported yet)", memmap : [0, 0, 0]}, //bank 0 first //(PVB TODO) =>not supported yet
        "Type_67" : {machine : "800/XL/XE", size : "64", name : "XEGS 64 KB cartridge (banks 8-15)", memmap : [0x20, 0x80, 7, 0x20, 0xA0, 1]}, //bank 0 first
        "Type_68" : {machine : "800/XL/XE", size : "128", name : "Atrax 128 KB cartridge", memmap : [0x20, 0xA0, 16]}, //coded cartridge of type 17
        "Type_69" : {machine : "800/XL/XE", size : "32", name : "aDawliah 32 KB cartridge", memmap : [0x20, 0xA0, 4]}, //bank 0 first 
        "Type_70" : {machine : "800/XL/XE", size : "64", name : "aDawliah 64 KB cartridge", memmap : [0x20, 0xA0, 8]}, //bank 0 first 
        // ALTIRRA V3.90 does not support next types ?
        "Type_71" : {machine : "5200", size : "64", name : "Super Cart 64 KB 5200 cartridge (32K banks)", memmap : [0x80, 0x40, 2]},
        "Type_72" : {machine : "5200", size : "128", name : "Super Cart 128 KB 5200 cartridge (32K banks)", memmap : [0x80, 0x40, 4]},
        "Type_73" : {machine : "5200", size : "256", name : "Super Cart 256 KB 5200 cartridge (32K banks)", memmap : [0x80, 0x40, 8]},
        "Type_74" : {machine : "5200", size : "512", name : "Super Cart 512 KB 5200 cartridge (32K banks)", memmap : [0x80, 0x40, 16]},
        "Type_75" : {machine : "800/XL/XE", size : "1024", name : "Atarimax 1 MB Flash cartridge (new)", memmap : [0x20, 0xA0, 128]},
        //(PVB TODO) Add futur type above type_75 : https://github.com/atari800/atari800/blob/master/DOC/cart.txt
    };
    //(PVB end of ADD)

    //(PVB ADD) "_extractedfile" = default values in the disk file extract to be disassembled
    var _extracted_disk = {start_sect: 1, start_sect_off: 6, end_sect: 3, start_add: 0x706 };
    var _extracted_file = {start_offset: 0, end_offset: 0, start_add: 0x1000 };
    //(PVB end of ADD)

    // guess the file type
    //(PVB MOD) improvement of get_ext() function
    function get_ext(name, a, imgTag, dosfileTag) { //(PVB COM get_ext() is called by load_data() function and returns, the loaded file extension "xxx"
        //(PVB COM) name = file name; a = the file byte data; imgTag = is set with the image (type/mime) extension; dosfileTag is set to force ROM or disk images as DOS file
        //(PVB MOD) read the file header...
        var sig = le16(a, 0); //(PVB COM)  sig = signature or file header (2 first bytes)
        var n = name.lastIndexOf("."); //(PVB COM) is there a file extension (a dot) ? n is the number of char before the extension dot "."
        if (n != -1) { //(PVB COM) an extension has been found in the loaded file name
            var ext = name.substr(n + 1).toLowerCase(); //(PVB COM) ext is set to lowercase
            if (dosfileTag) { //force any extension as Atari DOS file, so convert ROM or disk images
                if (ext == "rom" || ext == "a52" || ext == "car") { // .rom .a52 and .car files are in a DOS disk image file
                    ext = "bin"; //so force extension type to 'bin' DOS file
                    console.log(" get_ext() has forced orignal extension of file " + name + " to 'bin', for not to confuse it with ROM image file");
                }
                if (ext == "atr" || ext == "atx" || ext == "pro" || ext == "xfd" || ext == "dsk") { //disk image file extensions as Atari DOS files, this is not possible
                    ext = "???"; //so force extension type to '???'' to escape the _exts[ext] known extension here after
                    console.log(" get_ext() has forced orignal extension of file " + name + " to '???', for not to confuse it with Disk image file");
                }
            }
            if (ext == "atr" || ext == "pro" || ext == "atx" ||ext == "xfd") { //check siDisk Disk Image
                var te = "";
                if (ATR.is_atr(a)) te = 'atr'
                else if (PRO.is_pro(a)) te = 'pro';
                else if (ATX.is_atx(a)) te = 'atx';
                else if (XFD.is_xfd(a)) te = 'xfd';
                else { //none of them
                    console.log(">get_ext() '" + name + "'' is not an ATR file, nor a PRO, nor ATX, nor XFD => show it as 'DAT'!");
                    return 'ere';
                }
                return te;
            }
            if (ext == "dcm") { //check DCM Disk Image
                if (a[0] == 0xF9 || a[0] == 0xFA) return 'dcm';
                console.log(">get_ext() has not found the DCM signature for file " + name + ", so force it to 'DAT'");
                return 'ere';
            }
            if (_exts[ext]) { //(PVB COM) returns the extension if found in the table of extensions
                console.log(" get_ext() has found extension '" + ext + "' for file " + name + " in the _exts table");
                return ext;
            }
        } //else no extension or unknown extension in the filename
        //(PVB COM) no ext in the file name, or unknown extension from the table... is it a type/mime image ?
        if (imgTag) {
            console.log(" get_ext() has found imgTag for image in file " + name);
            return imgTag.width == 320 ? "gr8" : "gr7"; //(PVB COM) if yes, the ext is forced to gr8 or gr7
        }
        //(PVB COM) no ext in the file name, or unknown extension from the table, or not a type/mime image
        if (!dosfileTag) { //check disk image type....
            console.log(" get_ext() checks if " + name + " is a disk image like ATR, ATX, PRO or XFD...");
            if (ATR.is_atr(a)) //(PVB MOD) function is_atr() has been added, so use it to check is it is an ATR
                //(previously) if (sig == 0x0296) //(PVB COM) $0296 (sum of 'NICKATARI') return "atr";) => this check is now in is_atr()
                return "atr";
            if (ATX.is_atx(a)) //(PVB COM) note : static function call is done by CLASS.funtion()
                return "atx";
            if (PRO.is_pro(a))
                return "pro";
            if (XFD.is_xfd(a))  //(PVB COM) XFD is identified thanks to the disk image file size that shall correspond to real Atari disk size
                return "xfd";
        }
        //(PVB MOD) use a switch function to check the file header to identify the file type
        console.log(" get_ext() checks if " + name + " is an Atari file with a specific header...");
        switch (sig) {
            case 0xFFFF:
                if (le16(a, 2) <= le16(a, 4)) {
                    return "xex"; //(PVB COM) it is a valid executable Atari file with 0xFFFF header and the 2 segment address vector are consistent
                }
                break;
            case 0x80FF:
                if (le16(a, 2) == 0xC7C9) {
                    return "pic";
                }
                break;
            case 0x4952:
                return "rip";
            case 0xFEFE:
                return "m65";
            case 0x081A:
            case 0x041A:
                return "arc";
        }
        //(PVB COM) check for Basic file...
        console.log(" get_ext() checks if " + name + " is an Atari BASIC file ...");
        try {
            if (ataribasic(a, 0, a.length)) {
                console.log(" get_ext()... yes it is BASIC file !");
                return "bas";
            }
        }
        catch (err) {
            console.log(err);   // guess it wasn't basic because ataribasic() returns an error
        }
        //still not find the file type here, so check for general LST file (basic listing)
        console.log(" get_ext() checks if " + name + " is an Atari LST or Text file ...");
        var s = '';
        var tx = true;
        for (var i = 0; i < a.length; i++) { //(PVB COM) searching in the file for keywords "REM, GOTO, THEN" that should be in an Atari LST file
            var d = a[i];
            s += String.fromCharCode(d);
            d = (d == 0x9B) ? 0x20 : (d & 0x7F); //check if it's a valid 0x9B EOL char and replace it by a space
            if ((d >= 0x1B && d <= 0x1F) || (d >= 0x7D && d <= 0x7F)) //is it a control char ?
                tx = false; //then it's not a text file !
        }
        if ((s.indexOf("REM") != -1) || (s.indexOf("GOTO") != -1) || (s.indexOf("THEN") != -1)) {
            console.log(" get_ext() ... looks like a LST file because contains REM, or GOTO, or THEN words!");
            return "lst";
        }
        if (tx) {
            console.log(" get_ext() ... looks like a Text file as it does not contain control char (except EOL $9B)!");
            return "txt";
        }
        //still not find the file type here, so it will be shown as a .DAT RAW file (just a binary dump, no disassembly)
        console.log(" get_ext() has not found a known Atari file, so ext of  " + name + " is set to '???'");
        return "???"; //(PVB MOD) ext = "???" that is an unknown type, displayed as a DAT file
    }

    //(PVB ADD) get_type() function to get the overall type among isFile, isRomdump, isDisk, isRaw adn isArc. This will be used by ext_option(f) 
    function get_type(ext, flfile) { //flfile set to true for "isFile" for DOS file
        var e = _exts[ext];
        if (!e || ext == "???" || ext == "dat" || ext == "ere") {
            console.log(" ...get_type() has set file with extension '" + ext + "' to Raw file");
            return "isRaw";
        }
        if (!flfile) {
            if (ext == "arc")
                return "isArc";
            if (e.is_romdump)
                return "isRomdump";
            if (e.is_disk)
                return "isDisk";
        }
        if (e.is_txt || e.is_img || e.is_fontset) //these are not displayed as listing
            return "isTxtImg";
        console.log(" ...get_type() assume that file with extension '" + ext + "' is an Atari DOS File (isFile)");
        return "isFile"; //displayed as listing
    }
    //(PVB END OF ADD)

    var _id = 1;
    var _container_id = 1;
    var _containers = [];
    function get_file(id) {
        var f;
        _containers.forEach(c => c.files.forEach(i => { if (i.id == id) f = i }));
        return f;
    }
    var _shown;

    function save(as_lst) { //saving Buttons that are valid for text only, not for img, nor font 
        var f = _shown;
        if (as_lst == 2) { //(PVB ADD) [Save as UTF text] Button on the Client, so lowercase extension must be used
            var lst = editor().innerText.split("\n");
            lst = ascii2print(lst);
            save_bytes(f.name + ".txt", lst); //Add .txt extension whatever what was filename.ext
        }
        else if (as_lst == 1) { //(PVB COM) [Save as Atari LST] Button 
            var data = get_ataritext(); //get text from Editor, including text edition & modifications
            var n = f.name;
            if (n.substr(n.length - 4).toLowerCase() == ".bas" || n.substr(n.length - 4).toLowerCase() == ".lst")
                n = n.substr(0, n.length - 4);     // trim ".BAS" // or trim .LST to replace extension by LST
            save_bytes(n + ".LST", data); //no need to add .LST if it is already a LST
        }
        else { //(PVB COM) [Download original Atari file] Button (as_lst == 0)
            if (f.packed_img) { //TODO Test it
                if (f.rgb)
                    save_bytes(f.name + ".rgb", f.rgb); //rgb on the Client
                else
                    save_bytes(f.name + "." + f.ext, f.packed_img);
            }
            else save_bytes(f.name, f.data); //extension is already in the file name
        }
    }
    //(PVB ADD) new save_as_xxx() function
    function mod_ext(name, ne) { //function mod_ext() used to modify current file extension according to saving purpose
        var xt = ""; //variable for current extension
        if (name.substring(name.length - 4, name.length - 3) == ".")  {
            xt = name.substring(name.length - 3, name.length); //get current ext
            name = name.substring(0, name.length - 4); //remove ext
        }
        if ((ne == 'ATR' || ne == 'XFD') && (xt == 'ATR' || xt == 'XFD'))
            return name + "." + ne; //change ATR from XFD and inversement
        if (ne == 'MERGED') //filename-MERGED.XEX //force XEX extension if merged
            return name + "-" + ne + ".XEX";
        if (xt && !(xt == 'XEX' && ne == 'xex')) name += "_" + xt; //filename_"current extension" //put current extention in name
        if (ne == 'EXTRACT') return name + "-" + ne;//filename_"original ext"-EXTRACT //put original ext in bracket
        else return name + "." + (ne == '???' ? 'DAT' : ne.toUpperCase());; //filename-"original ext"."new EXT" //standard way of changing extension
    }
    function save_as_new() { //[Download new file] saving button in case of new extension
        save_bytes(mod_ext(_shown.name, _shown.ext), _shown.data);
    }
    function save_as_extract(opt) { //Extract saving buttons in Extract menu
        var f = _shown;
        var fe = ".DAT";
        if (!f.extractedData) return;
        var sa = f.type == "isDisk" ? f.extracted_disk.start_add : f.extracted_file.start_add;
        var data_to_save = f.extractedData;
        if (opt == 1) { // 1: Save extract to OBJ file (convert)
                data_to_save = make_OBJ(data_to_save, sa);
                fe = ".OBJ";
                console.log("save_as_extract()==> make_OBJ() file done!");
        }
        else if (opt == 2 || opt == 3) {
            // 2: Save extract convert to ATR boot (add 6 bytes of boot header)
            // 3: Save extract as ATR boot (boot header bytes already in extract - but number of sectors will be adjusted)
            data_to_save = make_ATR(data_to_save, sa, opt == 2); //make_ATR(d, sect_size, badd)
            fe = ".ATR";
            console.log("save_as_extract()==> make_ATR() file done! Start Addr: $" + hdx(sa));
        } //else (opt == 4) (or other case): do nothing on the data, save them as raw with extension "dat"
        //then now save bytes
        save_bytes(mod_ext(f.name, "EXTRACT") + fe, data_to_save);
    }
    function save_as_dsk(ext) { //used by [Download ATR file], [Download XFD file], and [Download all valid files] buttons
        var f = _shown;
        if (ext == "ATR" || ext == "XFD") {
            var d = ext == "XFD" ? f.atr.d.slice(16) : f.atr.d; //if XFD then remove 16-bytes ATR header
            save_bytes(mod_ext(f.name, ext), d);
        }
        if (ext == "ALL") { //Save (download) all the valid DOS files // Experimental because limited by the Browser and OS like windows
            var ct;
            if (f.dosdir && f.dosdir.length) {
                _containers.forEach((c, t) => c.files.forEach(i => { if (i.id == f.id) ct = t }));
                var n = _containers[ct].files[_containers[ct].files.length - 1].name; // name of the disk
                _containers[ct].files.forEach((i, t) => {
                    if (i.type != "spacer" && i.type != "isDisk") {
                        var e ='';
                        if (i.ext == 'bat') e = ".TXT"; //windows OS Client protection, as bat extension is reserved, so add .txt extension
                        if (i.ext == 'sys') e = ".OBJ"; //windows OS Client protection, as sys extension is reserved, so add .obj extension
                        if (i.ext == 'com' || i.ext == 'exe') e = ".XEX"; //windows OS protection, as com & exe extension are reserved, so add ".xex"
                        e = n + "_" + t + "_" + i.name + e;
                        save_bytes(e, i.data);
                        console.log("save_as_dsk() =>Saving file #" + t + " named " + e + " !");
                    }
                });     
            }
        }
    }
    function save_as_cart() { //used by [Download new CART] button
        var f = _shown;
        save_bytes(mod_ext(f.name, "CAR"), f.rom.romData);
        /*if (f.rom.tmpData) save_bytes(f.name, f.rom.tmpData); //Saving the new bank map : See apply_rommap(id)*/
    }
    function save_wo_header() { //used by [Download raw ROM] button
        var f = _shown;
        var d = f.rom.romData.slice(16);
        save_bytes(mod_ext(f.name, "ROM"), d);
    }
    function save_disassembly(h) { //used by [Save listing] buttons
        var f = _shown;
        var s = "Atari 8-bit rom image file explorer - Listing";
        if (!h) { //request to save in txt format: _txt("#show") get the text (inner text) of the listing display in the html page
            var str = s + "\n\n" + f.name + "\n\n" + _txt("#show") + "\n\nThis text listing is given without any warranty\n";
            str += "PVBestInFoo on @github https://github.com/pvbestinfoo/Atari_8-Bit_Rom_Image_File_Explorer";
            save_bytes(f.name + ".txt", str);
        }
        else { //request to save in html format: get the (inner html) of the listing display in the html page
            var strhtml = `<!DOCTYPE html>
            <html lang="en">
            <head><title>${s}</title>
            <style>`;
            if (h == 2) { //save with the atari font and style, go get the style
                var ff = document.getElementsByTagName("STYLE");
                strhtml += ff[0].innerHTML;
            }
            strhtml += `</style>
            <body>
                <h2>${s}</h2><h3>${f.name}</h3><br />
                <div><pre>`;
            strhtml += document.querySelector("#show").innerHTML;
            strhtml += `</div></pre><br />
            This HTML page may have bugs and is given without any warranty<br />
            <a href="https://github.com/pvbestinfoo/Atari_8-Bit_Rom_Image_File_Explorer">PVBestInFoo on @github</a> 
            </body>
            </html>`;
            save_bytes(f.name + ".html", strhtml);
        }
    }
    //(PVB END OF ADD)
    
    //===================================================================================================
    //===================================================================================================
    // xex/obj disassembly

    //(PVB ADD) the hdx(x) function to shorten the "x.toString(16).toUpperCase()" function !
    function hdx(x) {
        return x.toString(16).toUpperCase();
    }
    //(PVB MOD) improvement of get_xex_segs(): accept several 0xFFFF headers in same file, check segment validity and set error text in segs.ers
    function get_xex_segs(a, i, len) {
        //(PVB COM) a = file data, i = 0 (index = offset from beginning of file data) //len = file size
        var segs = [];
        var segnum = 0; //(PVB ADD) segment counter
        var e = i + len; // e is the index of the last byte of the file (+1)
        var ers = ""; //(PVB ADD) segment error string
        //(PVB MOD) put the variable declaration before code
        //(PVB COM) test the first 2 bytes
        if (le16(a, i) != 0xFFFF) //(PVB COM) header shall be 0xFFFF for Atari Executable files (COM, EXE, XEX)
            return null; //(PVB COM) This is not an executable file, so return !
        //(PVB COM) 2 following 0xFFFF header at the beggining of a file is not allowed (it could be a file filled with $FF...), so return !
        if (le16(a, i+2) == 0xFFFF) { 
            console.log("get_xex_segs() => 2 following 0xFFFF header are not allowed at beginning of executable file!");
            return null;
        }
        mainlp: while (i < e) {
            segnum ++; //increase the segment counter, it starts at 1
            while (le16(a, i) == 0xFFFF) { //(PVB COM) header 0xFFFF is okay.
                //(PVB COM) 2 consecutive 0xFFFF header should not appear in executable file. If the file must be invalidated, uncomment following code
                /*if (le16(a, i+2) == 0xFFFF) {
                    ers = "ERROR in segment header! (offset $" + hdx(i+2) + "): 2 consecutive $FFFF header found!";
                    break mainlp;
                }*/
                //(PVB ADD)(PVB MOD) 0xFFFF segments are stored in the 'segs' array, with the number 0xFFFF. Add the "segid" in the 'segs' array.
                seg = { segid: 0xFFFF, start: 0, end: 0, offset: i, len: 2 };
                segs.push(seg); //push the seg in the segs table
                //(PVB end of ADD)
                i += 2; // increase of 2
            }
            if ((e - i) < 4) {
                ers = "EOF ERROR in Segment #" + segnum + " definition! (offset $" + hdx(i) + "): not enough data to make a new header";
                ers += "\n;  (a header must have 4 bytes, and only " + (e-i) + " bytes left in file!)";
                break; //exit the while loop
            }
            // i is lower that e, this should be a valid segment
            var start = le16(a, i); // then the start address of segment
            var end = le16(a, i + 2); // then the end address of segment
            i += 4; // then at +4 there are the segment data
            var slen = end + 1 - start; // length of data formula, shall be from 1 to max length of file
            console.log("get_xex_segs() => Info: Found segment #" + segnum + " (index $" + hdx(i) + "): $" + hex(start,4) + ":" + hex(end,4) + ", length $" + hex(slen,4) + " bytes");
            if ((slen < 1) || (i + slen > e)){ //check if segment is inconsistent : length shall be 1 at least
                //(PVB ADD)(PVB MOD) check the segment validity
                if (!segs){ //(PVB) in case of there is no segment found after the $FFFF header (should not appear in real life for binary file!)
                    console.log("get_xex_segs() => Info: no valid segment found!"); //(PVB CONSOLE HINT)
                    return null; //(PVB) first segment is not OK, we do nothing and return
                }
                else { //(PVB) in case of there are some segments found
                    //(PVB) save this last not-OK segment with the segs.ers error text and return
                    ers = "Code segment #" + segnum + " ERROR! $[" + hex(start,4) + ":" + hex(end,4) + "] (offset $" + hdx(i-4) + ")";
                    if (slen < 1)
                        ers += ": segment start address is greater that end address!";
                    if (i + slen > e) {
                        ers += ": $" + hdx(slen) + " bytes required, but only $" + hdx(e-i) +" bytes left in file!"
                        ers += "\n;  ($"+ hdx(i+slen - e) +" bytes are missing in file; expected file size should be $" + hdx(i+slen) + ")";
                    }
                    break;
                }
            } 
            //(PVB end Of add)
            //(PVB MOD) added : "segid" in the 'segs' array
            var seg = { segid:segnum, start: start, end: end, offset: i, len: slen }; //(PVB COM) offset is the memory pointer of the first byte in the segment
            segs.push(seg); //push the seg in the segs table
            i += slen; // i is set for next segment
        } //end of while loop
        if (ers) { //if ers then save the segment with the error string
            segs.push({ segid:segnum, start: 0, end: 0, offset: i, len: 0, ers: ers });
            console.log("get_xex_segs() => !" + ers); //ers contains the error description
        }
        return segs;
    }

    //(PVB ADD) for upgrading the xex_dump() function
    var _nBankId = ""; 
    function seg_data(aData, aSeg) {
        var sData = [];
        for (var i = 0; i < aSeg.len; i++) {
            sData[i] = aData[aSeg.offset + i];
        }
        return sData;
    }
    //(PVB MOD) improvement of xex_dump(): handle ROM, entry_points, dump types, disassembly origin
    var _hr = "; ===============================================================================";
    function xex_dump(name, a, i, len, dump_type, org, entry_points) {
        //previously //function xex_dump(name, a, i, len, expect_header, org, entry) { //(PVB COM) expect_header & entry have no use!
        //"name" is name of file; "a" is the UintArray of Data; "i" is the offset index in the Data; "len" is the length of Data to disassemble
        //"dump_type" is the string of the type of Data to disassemble : "HEAD" for binary file with 0xFFFF headers (and "BIN" if no header), "ROM" for ROM, "BOOT" for boot sector
        //"org" = address origin of the disassembly // for dump_type = "BOOT", "org" is the "BLDADDR" boot loading address
        //"entry_points" = array of important addresses to highlight in the disassembly listing:
        // => BCONT address of boot continuation after JUMP $4C (like $714 for DOS); "BINTAD" for Boot Initializarion Address (after a SEC + RTS)
        // => rom_coldstart = CARTCS (cold start at len-6); rom_init = CARTAD (initialisation start vector at len-2) for the "ROM"
        // note : RUNAD (DOS RUN ADDRESS) at $2E0; and INITAD (DOS INIT ADDRESS) at $2E2 for "HEAD" are set in the present function and not pass in entry_points
        var so =""; //(PVB ADD)
        if (name == "DOS.SYS") { //http://data.atariwiki.org/DOC/Inside_Atari_DOS_GBXL.pdf
            org = _shown.dosType == 1 ? 0x0780 : 0x07CB;   //DOS.SYS start loading address according to DOS type
            entry_points = _shown.dosType == 1 ? [0x1300] : [0x1540]; //DOS.SYS entry run address
            so = "; <i>Normal loading address of DOS.SYS set to $" + hex(org,4) + "</i>"; //(PVB ADD)
        }
        else if (dump_type == 'BIN' && name.lastIndexOf(".ROM") >= 0) { //(PVB WIP)// this is a rom calculation for the start address //TODO// maybe add a form input field to enter start address ?
            if ((len & 0xFFF) == 0 && (len >> 12) <= 12) { //len is a multiple of 0x1000, which is 4KB; len >> 12 is number of 4KB, max 48kB in the RAM
                org = (0xC000 - len) & 0xFFFF; //RAM is from 0 to $BFFF
                so = "; <i>Memory Dump binary loading address set to $" + hex(org,4) + "</i>"; //(PVB ADD)
            }
        }
        if (org === undefined || org === 0 ) { //(PVB MOD) check the 'org' disassembly start address 
            org = 0x700;
            so = "; <i>Default loading address set to $0700 for the binary object file</i>"; //(PVB ADD)
        }
        //(PVB COM) memory array for flags and ram
        var flags = new Uint8Array(0x10000);
        var ram = new Uint8Array(0x10000);
        //(PVB ADD) seems to be better to erase arrays, in case of...
        flags.fill(0); 
        ram.fill(0);
        if (org >= 0xFFFF) {
            console.log("xex_dump()=> 'org' error ! value was :" + org);
            org = 0;
        }
        //(PVB MOD & ADD)
        //(PVB MOD) here declaration of the segheader
        var segheader = false;
        //(PVB ADD) here declaration of the is_rom
        var is_rom = false;
        //(PVB ADD) "dump_type" managment
        if (dump_type.lastIndexOf("ROM") >= 0) {
            _nBankId = dump_type.slice(dump_type.indexOf("_") + 1);
            is_rom = true;
        }
        else _nBankId = "";
        if (dump_type == 'HEAD') { //(PVB ADD) if it is "HEAD" => seek the headers; it is not necessary for "SEL", "BOOT", "EXTRACT", and "BIN"
            var segs = get_xex_segs(a, i, len);
            //(PVB COM) segs is an array of n seg (n = 0, 1, ...); Segments are count in "seg.segid", which is is set to $FFFF for header
            //(PVB COM) if segheader is true, there are headers in the "has_header" file type, ohterwise display a direct disassembling starting from "org"
            segheader = segs && (segs.length > 1); //(PVB COM) segheader is OK if segments found above the $FFFF header which is the first 
            //(PVB WIP)//TODO// maybe do a better check of the header validity ? need to check Atari Exe file Spec from DOS...
            if (!segheader) console.log("xex_dump()=> No segment found, this is not a standalone executable file!");
            else {
                console.log("xex_dump()=> OK, " + segs.length + " segments found, this is a standalone executable file!");
                console.log("xex_dump()=> Check if segments of exe file can be merged...");
                var mergedfile = segs_merging(a, segs); //check if segments can be merged, and inner $FFFF cancelled
                if (mergedfile) console.log("xex_dump()=> Segments of exe file can be optimized and merged!");
            }
        }
        var lines = [];
        //(PVB ADD) more displayed informations
        /*showDisOption(); ==> now put in render_file()*/
        if (dump_type == 'BOOT') {
            lines.push(_hr);
            lines.push("; <b>Disk Boot program is $" + hdx(len) + " (" + len + ") bytes on " + name + " sectors </b>");
        }
        else if (!is_rom) {
            lines.push("; <b>File '" + name + "' is $" + hdx(len) + " (" + len + ") bytes</b>");
            if (mergedfile) {
                _shown.mergedfile = mergedfile;
                lines.push("; Click if you want to merge nearby segments and make a new file ==> <em class='showcode' onclick='open_mergedfile()'>Merge segments into a new file</em>");
            }
            if (_shown.start && (dump_type == 'HEAD' || dump_type == 'BIN' || !dump_type)) {
                lines.push("; [Start sector: " + _shown.start + " ($" + hex(_shown.start, 3) + "); " + _shown.total + " ($" + hex(_shown.total, 3) + ") blocks]");
            }
            if (dump_type == 'HEAD' && !segheader && name != "DOS.SYS")
                lines.push("; <i>Header and segment were expected in the binary file, nothing valid found</i>");
            if (!segheader) lines.push(so);
            lines.push("");
        }
        //else //(PVB COM) there we are in a ROM here
            //lines.push("; <b>Disassembly of ROM bank at $" + hex(org, 4) + ", size: " + len + " ($" + len.toString(16).toUpperCase() + ") bytes</b>"); //no need to display this
        if (!segheader) { //(PVB COM) if no segments, it is not a binary file with header.
            if (dump_type == "BOOT") {
                flags[org + 6] = 0x84; //add the address (org + 6) as an entry_points (flags = 0x84 to for the disassembly address)
                console.log("xex_dump()=> Origin address entry point is: $" + hex(org + 6, 4)); //(PVB CONSOLE HINT)
            }
            if (entry_points) {
                var n = entry_points.length;
                console.log("xex_dump()=> Other entry_points (length=" + n + ") array is:"); //(PVB CONSOLE HINT)
                while (n--) {
                    console.log("   " + n + ": $" + hex(entry_points[n], 4)); //(PVB CONSOLE HINT)
                    flags[entry_points[n]] = 0x84;
                }
            }
            var asms = [];
            asms.push(disassemble(org, a, i, len, ram, flags));
            if (!is_rom)
                lines.push(_hr); //(PVB ADD)
            asms.forEach(asm => disassemble2(asm, lines, ram, flags, false));
        }
        else { //(PVB COM) There are segments
            var s;
            // walk segments, collect entry points
            // draw them all at head, repeat them in body
            segs.forEach(seg => {
                //(PVB MOD) Adding the hyperlinks display 
                var stmp = seg.segid; //(PVB) segment number
                if (stmp == 0xFFFF) { //(PVB) this is an header 
                    s="; Header 0xFFFF at file offset $" + hdx(seg.offset);  //(PVB ADD)
                }
                else if (!seg.ers) { // this is not a header but a displayable segment of code without error
                    s = "; Code <a id='BKTOSEG" + stmp + "' href='#FWTOSEG" + stmp + "'>segment \#" + stmp + "</a>";  // hyperlink to the segment disassembly
                    s += "  $[" + hex(seg.start, 4) + ":" + hex(seg.end, 4) + "]";
                    s += ", total $" + hdx(seg.len) + " (" + seg.len + ") bytes, at offset $" + hdx(seg.offset); //(PVB) ajout hexa $ et valeur
                }
                else s = ""; //here (stmp == -1) nothing to display for the faultly indisplayable segment (except error text below)
                switch (seg.start) {
                    case 0x2E0: //RUNAD (DOS RUN ADDRESS) at $2E0 (736)
                        flags[seg.run = le16(a, seg.offset)] = 0x84; //(PVB ADD) flagged as an entry point for disassembly listing
                        if (seg.len == 4) { // if the len is 4, then 2E0 to 2E3 are initialized within the same segment
                            flags[seg.initialize = le16(a, seg.offset + 2)] = 0x84;
                            seg.note = " -> initialize at $" + hex(seg.initialize, 4) + ", run at $" + hex(seg.run, 4); // (PVB) rajout hexa $ et valeur hexa
                        } else
                            seg.note = " -> run at $" + hex(seg.run, 4); //(PVB MOD) hexa $ display
                        break;
                    case 0x2E2: //INITAD (DOS INIT ADDRESS) at $2E2 (738)
                        flags[seg.initialize = le16(a, seg.offset)] = 0x84; //(PVB ADD) flagged as an entry point for disassembly listing
                        seg.note = " -> initialize at $" + hex(seg.initialize, 4); //(PVB MOD) hexa $ display
                        break;
                }
                if (seg.note) s += seg.note;
                if (s) lines.push(s);
                if (seg.ers) lines.push(';<span style="color:red;"> => ' + seg.ers + '</span>'); //display the error if there is an error in segment
            });
            lines.push('');

            // Do the disassembly, first pass
            var asms = {};
            console.log("xex_dump()=> Time for 1st PASS !");
            segs.forEach(seg => {
                if (seg.segid != 0xFFFF && !seg.ers) { //(PVB) if segment number is not the header, and not a faultly not-displayable segment
                    console.log("xex_dump()=> DISASS 1st PASS of SEGMENT #" + seg.segid + " > " + hex(seg.start, 4) + ":" + hex(seg.end, 4));
                    asms[seg.segid] = disassemble(seg.start, a, seg.offset, seg.len, ram, flags);  // disassemble the segment with first pass
                }
            });
            console.log("xex_dump()=> Time for 2nd PASS !");
            // Complete the disassembly, second pass
            segs.forEach(seg => {
                //(PVB MOD) Adding the hyperlinks display
                var stmp = seg.segid; //(PVB COM) segment display
                if (seg.segid != 0xFFFF) { //&& !seg.ers) { //(PVB COM) if segment number is not the header, and not a faultly not-displayable segment
                    lines.push(_hr);
                    s = "<span id='FWTOSEG" + stmp + "'>; Code segment \#" + stmp + "<a href='#BKTOSEG" + stmp + "'>(back)</a></span>";  // hyperlink to the segement
                    s = s + ": $" + hdx(seg.len) + " (" + seg.len + ") bytes at $" + hex(seg.start, 4) + ":" + hex(seg.end, 4); // (PVB) hexa $ and value display
                    if (seg.note)
                        s += seg.note;
                    lines.push(s);
                    if (seg.ers)
                        lines.push(';<span style="color:red;"> => ' + seg.ers + '</span>');
                    lines.push(_hr); //(PVB ADD) more char
                    lines.push('');
                    if (asms[seg.segid]) {
                        console.log("xex_dump()=> DISASS 2nd PASS of SEGMENT #" + seg.segid + " > " + hex(seg.start, 4) + ":" + hex(seg.end, 4));
                        disassemble2(asms[seg.segid], lines, ram, flags, seg.segid, seg_data(a, seg), seg.start); // disassemble the segment with 2nd pass
                    }
                }
            });
        }
        if (!is_rom)
            lines.push(';<i>End of disassembly \><a href="#top">Back to top</a></i>');
        return lines.join("\n");
    }

    //===================================================================================================
    //(PVB ADD) Disk Images size in bytes
    const _SD = 720*128; //92160; Single Density disk SD: 720 sectors @ 128B/sector ($16800 bytes)
    const _ED = 1040*128; //133120; Enhanced Density disk ED: 1040 sectors x 128B/sector ($20800 bytes)
    const _DD = 720*256 - 384; //183936; Double Density disk DD: 3x128B + 717 sectors x 256B/sector ($2CE80 bytes)
    const _DS = 1440*256 - 384; //368256; Double Sided, Double Density disk DSDD: 3x128B + (717+720) sectors x 256B/sector ($59E80 bytes)

    function sectorIndex(nsec, density) {
        return (nsec < 4) ? (nsec - 1) * 128 : ((nsec - 4) * density + 384);
    }
    // (PVB COM) Class declaration of the different possible Disk Images
    class PRO {
        static
        is_pro(d) {
            var s = toAscii(d, 2, 2);
            return s == "P2" || s == "P3";
        }

        static
        to_atr(d) {
            var sector_total = (d[0] << 8) | d[1];
            var sector_count = (d[6] << 8) | d[7];
            if (sector_count == 0)
                sector_count = 720; // p2?
            var sector_size = 128;
            var size = sector_count * sector_size;

            var atr = new Uint8Array(16 + size);
            atr[0] = 0x96; //150 //(PVB COM) $0296 (checksum of 'NICKATARI')
            atr[1] = 0x02; //02
            atr[2] = (size >> 4) & 0xFF;
            atr[3] = (size >> 4) >> 8;
            atr[4] = sector_size & 0xFF;
            atr[5] = sector_size >> 8;
            atr[6] = (size >> 4) >> 16;
            var dst = 16;
            for (var i = 0; i < sector_count; i++) {
                var src = 16 + 12 + (12 + sector_size) * i;
                var n = sector_size;
                while (n--)
                    atr[dst++] = d[src++];
            }
            return atr;
        }
    }
    
    //(PVB ADD) the calChkSum(d, i) for calculating the checksum of data array "d" from position "i"
    function calChkSum(d, i) {
            var chksm = 0;
            while (i < d.length)
                chksm += d[i++];
            return chksm;
    }
    //(PVB ADD) add the ROM class, its constructor and additional functions
    class ROM {
        is_cart(d) {
            if (le32(d,0) == 0x54524143) // 'ATASCII code of Cart signature 'C' 'A' 'R' 'T'
                if ((d.length - 16) && 0x3FF) {
                     //var i = 0;
                    var tchksm = (d[8] << 24) | ((d[9]) << 16) | ((d[10]) << 8) | (d[11]);
                    var chksm = calChkSum(d, 16);
                    console.log("ROM Constructor ==>checksum in rom $" + tchksm.toString(16) + " vs $" + chksm.toString(16));
                    if (tchksm != chksm)
                         console.log("ROM Constructor ==>Error : checksum does not match !!");
                    return true;
                    }
            return false;
        }
        to_cart(d, len) { //len varaible is set only if size must be forced
            len = len ? len : d.length; // else len = d.lenght = ROM image size
            var cartRom = new Uint8Array(len + 16); // add 16 for the cart header
            cartRom[0] = 0x43; //67 "C"
            cartRom[1] = 0x41; //61 "A"
            cartRom[2] = 0x52; //82 "R"
            cartRom[3] = 0x54; //84 "T"
            for (var i = 4; i < 16; i++)
                cartRom[i] = 0; //at this stage : unkown type is 00 in header [7]
            //set the checksum
            var chksm = calChkSum(d, 0);
            console.log("ROM Constructor ==>calculated checksum is $" + chksm.toString(16));
            cartRom[8] = (chksm >> 24) & 0xFF;
            cartRom[9] = (chksm >> 16) & 0xFF;
            cartRom[10] = (chksm >> 8) & 0xFF;
            cartRom[11] = chksm & 0xFF;
            cartRom.set(d, 16);
            return cartRom;
        }
        constructor(d, name) {
            var re;
            var len = d.length;
            this.romData = d;
            this.isCart = this.is_cart(d);
            if (this.isCart) { // this is a CART due to size and CART signature
                if (d[7] > 0 && d[7] < 76) { //signature = type if CART ROM, according to https://github.com/atari800/atari800/blob/master/DOC/cart.txt
                    this.romType = d[7];
                    console.log("ROM Constructor ==>Cart Rom Type is " + this.romType);
                }
                else { //no valid signature
                    this.romType = 0;
                    console.log("ROM Constructor ==>Cart Rom Type is unknown in the CART !!");
                }
                re = ( (this.romType < 10) ? "Type_0" : "Type_" ) + this.romType;
                //TODO//check if "re" is in the _romtypes list, and alert if not
                this.romName = _romtypes[re].name;
                this.romMachine = _romtypes[re].machine;
                this.romKBSize = _romtypes[re].size;
                if (this.romKBSize != (d.length >> 10)) //TODO//check the tool behaviour with this issue
                    console.log("ROM Constructor ==>CART Rom size in KB mismatch as not a KB multiple !!");
                else
                    console.log("ROM Constructor ==>OK CART Rom type is valid with size...");
                this.romMachine = _romtypes[re].machine;
                this.romMap = _romtypes[re].memmap;
                this.romTypeTxt = re;
            }
            else { //this is not a CART, so there are no 16 bytes header
                console.log("ROM Constructor ==>This is not a CART ROM");
                if (len & 0x7FF) { //this is not a full 2KB multiple ROM image size, or some data are missing
                    console.log("ROM Constructor ==>ROM size " + len + " is not a multiple of 2KB, so set missing bytes to $00 up to 2KB !!");
                    len = ((len >> 11) + 1) * 0x800; //2KB round up
                    this.restructured = true;
                }
                this.romData = this.to_cart(d, len); //conversion into CART is the base for the display (like ATR conversion for disk image)
                this.romType = 0;
                this.romTypeTxt = "Type_00";
                if (name.includes(".a52")) //first set machine type with extension
                    this.romMachine = "5200"; //TODO//check consistancy of setting 5200 here and below
                else
                    this.romMachine = "800/XL/XE";
                this.romKBSize = '' + (len >> 10);
                switch (len) { //romMap = memmap: [size in page, start address in page, number of bank at same address]
                    case 0x0800: //2K use for A5200 ROM
                        this.romMap = [0x08, 0xF8, 1];
                        this.romMachine = "5200"; //fix extension
                        console.log("ROM Constructor ==>Using the 2K ROM Mapping for A5200!");
                        break;
                    case 0x1000: //4K default 
                        this.romMap = [0x10, 0xB0, 1];
                        break;
                    case 0x2000: //8K use for ATARI BASIC ROM ROM 
                        this.romMap = [0x20, 0xA0, 1];
                        break;
                    case 0x2800: //10K use for ATARI OS A/B 
                        this.romMap = [0x28, 0xD8, 1];
                        console.log("ROM Constructor ==>Using the 10K ROM Mapping for OS A/B ROM!");
                        break;
                    case 0x4000: //16k use for XE/XL OS ROM
                        this.romMap = [0x40, 0xC0, 1];
                        console.log("ROM Constructor ==>Using the 16K ROM Mapping for XL/XE OS ROM!");
                        break;
                    case 0x8000: //32k only works for an A5200 ROM that can start at $4000; 32KB OS for XEGS not supported yet due to its special mapping
                        this.romMap = [0x80, 0x40, 1];
                        break;
                    default: //how to display unknown ROM format //TODO//try it, use it, and validate the features
                        if (this.restructured && len < 0xB000 ) { //restructured ROM, for rom image data exploration
                            this.romMap = [(len >> 8), 0x10, 1]; //one bank, fills memory from $1000; max $BFFF
                            console.log("ROM Constructor ==>Using default mapping for restructured ROM (1 bank from $1000)!");
                        }
                        else if (len & 0x0800) { //2KB multiple n 2K banks in B800-BFFF, for rom image data exploration
                            this.romMap = [0x08, 0xB8, len >> 11]; //'>> 11' is eq to divide by 0x0800
                            console.log("ROM Constructor ==>Using default mapping (n 2K banks in B800-BFFF)!");
                        }
                        else { //4KB multiple, use a default mapping, n 4K banks in B000-BFFF
                            this.romMap = [0x10, 0xB0, len >> 12]; //'>> 12' is eq to divide by 0x1000
                            console.log("ROM Constructor ==>Using default mapping (n 4K banks in B000-BFFF)!");
                        }
                }
                this.romName = "Unknown cartridge for " + this.romMachine + "? => set to default / OS ROM";
            }
        }
    }
    //(PVB end of ADD)

    class XFD {
        static
        is_xfd(d) {
            //(PVB MOD) Modified : no rule for data in XFD image, since it's just an Atari raw disk image file.
            //Hence to be an XFD, image size shoud only be equal a disk size.
            //note : 256*720 stands for buggy image that considers the 3 first sectors may be 256 bytes on double density disk
            //https://forums.atariage.com/topic/123109-atr-format-reference/
            //https://forums.atariage.com/topic/293817-first-3-disk-sectors-always-128-bytes/
            //previously //return (le16(d,0) == 0x0300) && (le16(d,2) == 0x0700);    
            if ((d.length == _SD) || (d.length == _ED) || (d.length == _DD) || (d.length == 256*720) || (d.length == _DS))
                return true;
            //(PVB end of MOD)
        }

        static
        to_atr(d) {  // (PVB MOD) append header to raw atrs or new raw XFD = convert the XFD into ATR
            //(PVB COM) assume the defaut is Single Density disk
            var sctr_total = 720; // raw image was 702 sectors... typo of 720? PVB: yes!
            var sctr_size = 128;
            var dsize = d.length;
            switch (dsize) {
                case _ED: //Enhanced Density disk
                    sctr_total = 1040; break;
                case 184320: //Double Density buggy disk: 720 sectors x 256B/sector ($2D000 184320 bytes)
                    console.log("ATR Constructor => XFD to_ATR() => the XFD has a buggy size of 720x256B bytes (3 first sectors should be 128 Bytes)!!");
                case _DD: //Double Density disk
                    sctr_size = 256; break;
                case _DS: //Double Side, Double Density
                    sctr_total = 1440; sctr_size = 256; break;
                case _SD: //Single Density disk
                    break; //default
                default: //if different, set to default ! ///WIP// Check it because this should not occur
                    dsize = _SD; //default = Single Density
                    console.log("ATR Constructor => XFD to_ATR() => has modify " + dsize + " bytes disk to the default 92160B Single Density disk image!");
            }
            //(PVB end of ADD) ATR disk image format https://forums.atariage.com/topic/123109-atr-format-reference/
            var atr = new Uint8Array(16 + dsize);
            dsize = (dsize >> 4) & 0xFFFFFFFF; //2 words = 4 bytes for the length
            atr[0] = 0x96; // (PVB COM) $0296 (sum of 'NICKATARI')
            atr[1] = 0x02;
            atr[2] = dsize & 0xFF;
            atr[3] = dsize >> 8 & 0xFF;
            atr[4] = sctr_size & 0xFF;
            atr[5] = sctr_size >> 8;
            atr[6] = dsize >> 16 & 0xFF;
            atr[7] = dsize >> 24 & 0xFF; //useless, as the maximum size of a real atari disk can't exceed 0xFFFD80 (65535 sectors, double density)
            atr.set(d, 16);
            return atr;
        }
    }

    class ATX {
        static
        is_atx(d) {
            return toAscii(d, 0, 4) == "AT8X";
        }

        static
        to_atr(d) {
            if (!ATX.is_atx(d))
                return null;
            var atx = new ATX(d);
            var atr = new Uint8Array(16 + atx.size);
            var sector_count = 720;

            atr[0] = 0x96;   //(PVB COM) $0296 (sum of 'NICKATARI')
            atr[1] = 0x02;
            atr[2] = (atx.size >> 4) & 0xFF;
            atr[3] = (atx.size >> 4) >> 8;
            atr[4] = atx.sector_size & 0xFF;
            atr[5] = atx.sector_size >> 8;
            atr[6] = (atx.size >> 4) >> 16;
            var dst = 16;
            for (var i = 0; i < sector_count; i++)
                dst = atx.readsector(i, atr, dst);
            return atr;
        }

        constructor(d) {
            this.d = d;
            this.sector_size = 128;
            this.tracks = [];
            var t = le32(d, 28);
            while (t > 0 && t < d.length) {
                var track = { toff: [] };
                track.offset = t;
                track.size = le32(d, t);
                track.type = le16(d, t + 4);
                track.tracknum = d[t + 8];
                track.sectorcount = le16(d, t + 10);
                track.headersize = le32(d, t + 20);
                track.sectorlistsize = le32(d, t + 32) - 8;
                for (var i = 0; i < 16; i++)
                    track.toff[i] = 0;
                var sl = t + 40;
                for (var i = 0; i < track.sectorlistsize; i += 8) {
                    var dat = le32(d, sl + i + 4);
                    if (dat && d[sl + i])
                        track.toff[d[sl + i] - 1] = dat;
                }
                this.tracks.push(track);
                t += track.size;
            }
            this.size = 720 * this.sector_size;
        }

        readsector(n, dst, dsti) {
            var d = this.d;
            var track = n / 18 | 0;
            var ss = this.sector_size;
            this.tracks.forEach(t => {
                if (t.tracknum == track) {
                    var dat = t.toff[n % 18];
                    if (dat) {
                        for (var i = 0; i < ss; i++)
                            dst[dsti + i] = d[t.offset + dat++];
                    }
                }
            });
            return dsti + this.sector_size;
        }
    }
    
    //(PVB MOD & ADD) improvement of the features of the SpartaDOS class functions
    class SpartaDOS { //(PVB COM) see http://atariki.krap.pl/index.php/Format_SpartaDOS for details
        constructor(atr) {
            var d = atr.d;
            this.atr = atr;
            this.boot = {
                sector_map: le16(d, 16 + 9),       // $09-$0A/Sector, where is the first Sector map of the main directory.
                sector_count: le16(d, 16 + 11),    // $0B-$0C/Number of every sectors on the disk
                free_sectors: le16(d, 16 + 13),    // $0D-$0E/Number of free sectors
                bitmaps: d[16 + 15],               // $0F/Number of sectors of the Bitmaps
                first_bitmap: le16(d, 16 + 16),    // $10-$11/Sector used for the first Bitmap.
                sector_file: le16(d, 16 + 18),     // $12-$13/The first sector, where may be allocated a data sector for a file
                sector_dir: le16(d, 16 + 20),      // $14-$15/The first sector, where may be allocated a data sector for a directory
                volume_name: toAscii(d, 16 + 22, 8).trim(),  //$16-$1D/Volume name
                tracks: d[16 + 30],                // $1E/Number of tracks; when the bit D7 is set, then the drive is double
                sector_size: d[16 + 31] ? 128 : 256,// $1F/Size of sectors ($80 = 128 bytes; 0 == 256 bytes) [NOTE if 1 == 512 bytes -- not handled by the Tool !]
                version: d[16 + 32],               // $20/version ($11 - created by SpartaDOS 1.x; $20 for SpartaDOS 2.x, 3.x, DOS X 4.1x/4.2x
                                                   // SpartaDOS X >= 4.39 gives $21 here (version 2.1 filesystem)...
                sequential: d[16 + 38],            // $26/This number is incremented every time you're making any changes on the disk
                random: d[16 + 39],                // $27/Random number of the disk. This number is created while formatting the disk.
                boot_sector: le16(d, 16 + 40)      // $28-$29/Sector of the DOS file, where is the first Sector map of file specified for booting
            } //$21-$25/other significant bytes; $2A/diskette write protection indicator ($00 - unlocked, $FF - protected) 
            this.file_info = {};
            this.fcount = 0;
        }

        // first entry in directory is information about the directory itself
        // start == parent;
        get_dir(sector_map, dir_name) {
            sector_map = sector_map || this.boot.sector_map;
            if (!dir_name) dir_name = "MAIN"; 
            var dir = this.read_file(sector_map); // sector_map is the sector map of a directory
            var files = [];
            var dir_info;
            var isMain = false;
            var sector_size = this.boot.sector_size;
            console.log(`SPARTA => ...entering directory at ${sector_map}, nammed ${dir_name}`);
            //this is a directory
            for (var i = 0; i < dir.length && dir[i+6]; i += 23) { //if dir[i+6] == 0, there is no more entry when empty entry
                if (i == 0) { //first entry is for MAIN dir, it contains information about the directory itself
                    dir_info = {
                        flags: dir[i],              //$00/value $00 in SpartaDOS 3 and BW DOS, $A8 in Sparta 4.2x; $28 in Sparta 4.4x
                        parent: le16(dir, i + 1),   //$01-$02/parent directory sector map, $0000 if main disk directory (MAIN)
                        len: le24(dir, i + 3),      //$3-$05/length of directory file in bytes, 00036A for exemple
                        name83: toAscii(dir, i + 6, 8), //$6-$10/dir name, "MAIN" for the first
                        name: toAscii(dir, i + 6, 8).trim(),
                    }
                    //(PVB ADD)
                    if (!this.main_dir_info) { //just for MAIN
                        isMain = true; //just to get MAIN as a file to display it
                        dir = dir.slice(0, dir_info.len);
                        this.main_dir_info = dir_info;
                    }
                    else continue; //skip the following file identification because it's a DIR
                }
                //else// at byte offset 23/46/69...$17/$2E/...
                /* (PVB MOD) 0x00 > End of Directory
                0x01 > entry is protected;    0x02 > hidden (Sparta>4.0)
                0x04 > archived (Sparta>4.0); 0x08 > entry (file or dir) in use (not deleted)
                0x10 > Erased (not is use);   0x20 > entry is a (sub)directory
                0x40 > (res. Sparta 4.49e);   0x80 > entry open for writing */
                /*previously// var flags = (dir[i] & 0x04) ? 0 : 0x42;*/ //convert flags to standard DOS ?
                var flags = dir[i];
                /*previously//if (dir[i] & 1) flags |= 0x20;  // locked*/ //convert flags to standard DOS ?
                var f = {
                    numidf: this.fcount++, //(PVB ADD)
                    flags: flags,
                    valid: 2, //(PVB MOD) previously //valid: true, 2 is file OK, 1 is for beeing displayed only in #show
                    start: isMain ? sector_map : le16(dir, i + 1),    //start sector for file map or subdirectory
                    len: le24(dir, i + 3),      //len in bytes (PVB TODO) check if it can be cancelled because of fsize
                    fsize: le24(dir, i + 3),    //(PVB ADD)
                    name83: toAscii(dir, i + 6, 11),
                    name: toAscii(dir, i + 6, 8).trim(),
                    date: le24(dir, i + 17),    //$11-$13/entry creation date in DD/MM/YY
                    time: le24(dir, i + 20),    //$14-$16/entry creation time in HH/MM/SS
                    dir_name: isMain ? "NO PARENT" : dir_name,  //(PVB ADD) parent directory name 
                    is_dir: (dir[i] & 0x20) || isMain    //is it a (sub)directory ? true or false
                }
                var ext = toAscii(dir, i + 14, 3).trim();
                if (ext.length)  //make full name with dot like "TOTO.BAS"
                    f.name += '.' + ext;

                f.sectors = [];
                f.maps = []; //(PVB ADD)
                    //(PVB ADD) Adding the deleted file handling
                if (flags & 0x10) {
                    f.valid = 1;
                    f.erf = "==>SpartaDOS deleted file ($10 flag)";
                }
                else {
                    this.file_info[f.start] = f; // we know the length
                    var sec = this.get_sectors(f.start);
                    for (var j = 0; j < sec.sectors_file.length; j++) {
                        f.sectors.push({
                            sector: sec.sectors_file[j],
                            slen: Math.min(sector_size, f.len - j * sector_size),
                            offset: j,
                            fbloc: j, //(PVB ADD)
                            snext: j == (sec.sectors_file.length - 1) ? 0 : sec.sectors_file[j+1],
                        });
                    }
                    //(PVB ADD)
                    for (var j = 0; j < sec.sectors_map.length; j++) {
                        f.maps.push({
                            map: sec.sectors_map[j],
                            fbloc: j,
                            snext: j == (sec.sectors_map.length - 1) ? 0 : sec.sectors_map[j+1],
                        });
                    }
                }
                f.total = f.sectors.length;
                f.total_map = f.maps.length; //(PVB ADD)
                files.push(f);
                console.log(`SPARTA => File #${f.numidf} ${f.name} with flag $${hex(flags,2)} recorded !`);
                // recurse get_dir if a file is a subdirectory
                if (f.is_dir && !isMain) {
                    console.log(`SPARTA => Directory #${f.numidf} ${f.name} exploration...`);
                    files = files.concat(this.get_dir(f.start, f.name));
                }
                isMain = false; //reset MAIN "as a file"
            }
            return files;
        }

        // get all the sectors associated with a file or a directory
        get_sectors(sector_map) {
            var atr = this.atr;
            var d = atr.d;
            var sector_size = this.boot.sector_size;
            // format of sector_map is next:prev:s:s:s.... 16 bit entries
            // next == 0 this is last sector map; prev == 0 this is first sector
            var sectors_file = [];
            var sectors_map = []; //(PVB ADD)
            while (sector_map) {
                var sm = atr.sector_offset(sector_map);
                sectors_map.push(sector_map); //(PVB ADD)
                for (var i = 2; i < sector_size / 2; i++) {
                    var s = le16(d, sm + i * 2);
                    if (!s) //stop fetching sector map if sector == $0000
                        break;
                    sectors_file.push(s);
                }
                sector_map = le16(d, sm);    // next sector of sector map
            }
            return {sectors_file : sectors_file, sectors_map : sectors_map}; //(PVB MOD)
        }

        read_file(sector_map) {
            var atr = this.atr;
            var file_info = this.file_info[sector_map];
            var d = atr.d;
            var dst = [];
            this.get_sectors(sector_map).sectors_file.forEach(s => { //(PVB MOD)
                var src = atr.sector_offset(s);
                for (var i = 0; i < this.boot.sector_size; i++)
                    dst.push(d[src + i]);
            });
            if (file_info && !file_info.is_dir) //(PVB COM) not for directory
                dst.length = file_info.len;   // clip it if we know the size
            return new Uint8Array(dst);
        }
    }
    //(PVB ADD) the DOS XE Class, see http://atariki.krap.pl/index.php/Format_AtariDOS_XE for details
    class DosXE { // Class is called by atr.get_dir() if the DOS on disk has been identified as DOS XE
        constructor(atr) { //set Boot and essential information
            var d = atr.d;
            this.atr = atr;
            this.boot = { //note: some info already retreived from identify_dos() function
                dos_write_date: this.dosxe_date(d, 16 + 0x0E), //$70E DOS write date to disk
                disk_code: atr.dosXEType,       //$710 The string code for the density (or disk type) used
                total_clusters: atr.totalBlock,  //$718 Total number of clusters on the floppy disk
                free_clusters: atr.freeBlock,    //$71A Maximum (initial) number of free clusters on the floppy disk
                root_dir_cluster: d[16 + 0x1D],  //$71D The first cluster number of the root directory.
                VTOC_number_of_clusters: d[atr.vtoc_off],  //VTOC+0 Number of clusters occupied by VTOC
                VTOC_disk_total_clusters: le16(d, atr.vtoc_off+2), //VTOC+2 Total number of clusters on disk, increased by 1
                VTOC_disk_free_clusters: le16(d, atr.vtoc_off+4),  //VTOC+4 Current number of free clusters on disk
                VTOC_number_of_files_and_dirs: le16(d, atr.vtoc_off+6),//VTOC+6 The number of files and subdirectories on the disk
                VTOC_disk_number: le16(d, atr.vtoc_off+8), //VTOC+8 random disk number
            }
            this.maxCluster = this.atr.sector_size == 128 ? (atr.sector_count / 2 - 1) : atr.sector_count ;  // cluster number must be <= to maxCluster and not >
            this.dir_info = {};
            this.fcount = 1;
        }
        dosxe_date(b,c) { //funtion dosxe_date() for DOX XE; using bytes b and c; returning a string Y/M/D
                var d = b[c+1] | ((b[c]) << 8);
                return ((d >> 9) + 1900) + "/" + (d >> 5 & 0x0F)  + "/" + (d & 0x1F);
            }
        cluster_offset(n) { //funtion cluster_offset() for DOX XE, using the n cluster value; returns an interger value for data index in an ATR disk image
            if (n < 4 || n > this.maxCluster) return -1; //error, for files, no use of cluster below the number 4 and above maxCluster
            var ofst = n * 256 + (this.atr.blockSect == 2 ? -128 : -640) + 16;
            if ((ofst + 256) >= this.atr.d.length) return -1; //end of file ?
            return ofst;
        }
        get_dir(dir_cluster, dir_info) { //funtion get_dir() for DOX XE; using dir_cluster as the cluster number of the directory, dir_info the directory structure, stored as a file
            dir_cluster = dir_cluster || this.boot.root_dir_cluster;
            var files = [];
            var isFirst = true;
            var isRoot;
            var bs = this.atr.blockSect;
            function set_sect(c, bs) {
                if (bs == 1) return [c];
                else return [(c * 2), (c * 2 + 1)];
            }
            function get_file_map(buff, j) {
                var mp = [];
                for (var l = 0; l < 23; l += 2) {
                    mp.push(le16(buff, j + l));
                }
                return mp;
            }

            var dbuffer = this.read_cluster(dir_cluster); //WIPDOS// check for dbuffer that is null if cluster number not OK
            console.log(`DOS XE => ...entering directory at cluster #${dir_cluster}, that is sector ${dir_cluster * (bs == 2 ? 2 : 1)}`);
            var i = 0;
            while (true) { //search for all the entries from directory clusters. Nota: no need to use the VTOC, because cluster map are not in VTOC for DOS XE
                if (isFirst) { //set the directory
                    if (!dir_info) { //set a dummy file for the root directory
                        isRoot = true;
                        dir_info = {numidf: 0, flags: 0, valid: 2, name83: "ROOT", name: "ROOT", dfnbr: 0, is_dir: true, clusters: [], sectors: [] };
                        dir_info.start = dir_cluster * (bs == 2 ? 2 : 1);
                    }
                    else {
                        isRoot = false;
                    }
                    //get the directory map
                    dir_info.clusters = [dir_cluster];
                    dir_info.sectors = dir_info.sectors.concat(set_sect(dir_cluster, bs));
                    var tbuff = dbuffer;
                    while (true) {
                        var next_dir_cluster = le16(tbuff, 0xF8); //get next directory cluster
                        if (!next_dir_cluster) break;
                        dir_info.clusters.push(next_dir_cluster);
                        dir_info.sectors = dir_info.sectors.concat(set_sect(next_dir_cluster, bs));
                        tbuff = this.read_cluster(next_dir_cluster);
                    }
                    dir_info.total = dir_info.clusters.length;
                    dir_info.totalS = dir_info.sectors.length;
                    dir_info.fsize = dir_info.total * 256;
                    isFirst = false;
                    files.push(dir_info);
                    continue;
                }
                //FLAGS ARE: 0x01 > Subdirectory; 0x02 > Protected; 0x04 > Open for Writting; 0x40 > File exists; 0x80 > File deleted
                var flags = dbuffer[i]; //the first byte
                if (flags == 0) break; //no more file, so exit !
                var f = {
                    numidf: this.fcount++,
                    flags: flags,
                    valid: 2, //valid: true, 2 is file OK, 1 is for beeing displayed only in #show
                    name83: toAscii(dbuffer, i + 1, 11),
                    name: toAscii(dbuffer, i + 1, 8).trim(),
                    len: le16(dbuffer, i + 0x0C),    //len in full clusters, 0 for subdirectories
                    bflen: dbuffer[i + 0x0E],        //number of bytes in the last file cluster (add to full cluster to get file size)
                    dfnbr: le16(dbuffer, i + 0X0F),  //file or directory number
                    rdn: le16(dbuffer, i + 0X11),    //random disk number, must be equal to the one in the VTOC
                    cstart: le16(dbuffer, i + 0X13), //Directory: the number of the first cluster of directory; File: The first cluster number of the file map
                    file_map: get_file_map(dbuffer, i + 0x13), //File: The numbers of the other eleven consecutive file map clusters, two bytes per number (00 for directories)
                    cdate: this.dosxe_date(dbuffer, i + 0x2B), //file creation date in Y/M/D
                    mdate: this.dosxe_date(dbuffer, i + 0x2D), //file modification date in Y/M/D
                    dir_name: isRoot ? "ROOT" : dir_info.name,
                    is_dir: (dbuffer[i] & 0x01)   //is it a (sub)directory ? true or false
                }
                var ext = toAscii(dbuffer, i + 9, 3).trim();
                if (ext.length)  //make full name with dot like "TOTO.BAS"
                    f.name += '.' + ext;
                f.start = f.cstart * (bs == 2 ? 2 : 1); //conversion of block into sector

                f.sectors = []; //sectors of the file
                f.maps = []; //sectors of the file
                f.clusters = []; //clusters of the file

                if (flags & 0x80) {
                    f.flags &= 0x80; //protection in case of wrong flag, priority to "delete" bit 
                    f.erf = "==>DOS XE deleted file ($80 flag)"; //valid or not valid? will depend on sector chain below
                }
                
                if (f.is_dir) { // recurse get_dir if a file is a subdirectory
                    console.log(`DOS XE => Directory #${f.numidf} (id#${f.dfnbr}) ${f.name} exploration...`);
                    files = files.concat(this.get_dir(f.cstart, f));
                }
                //WIPDOS// use the random number for disk integrity "rdn"?
                else { //(!f.is_dir && !flags & 0x80) //not a directory & not erased => get every clusters (and sectors) of the file from the file cluster map
                    var ptr;
                    var efm = 0;
                    for (var j = 0; j < 12; j++) { //the 12 bytes of dir entry cluster map
                        var cnbr = f.file_map[j];  //read the cluster
                        if (cnbr == 0) break; //no more cluster in the dir entry cluster map, so exit
                        var tbuffer = this.read_cluster(cnbr); //read the cluster map cluster
                        if (!tbuffer) {efm = 1; break; } //error, cluster number was below 4, or above disk size, so exit
                        let tmp = set_sect(cnbr, bs);
                        f.maps = f.maps.concat(tmp); //save the cluster map sector(s)
                        for (var k = 0; k < 250; k+= 2) { //get all the cluster number of the file (only 250 bytes)
                            //WIPDOS// // use 00FE  >File Map cluster sequence number (starting at $00) to check if OK
                            //WIPDOS// // use 00FA  >File number - $0000 for the root directory to check if OK
                            ptr = le16(tbuffer, k);
                            if (ptr == 0) break; //no more cluster in the cluster map cluster, so exit
                            if (ptr < 4 || ptr > this.maxCluster ) {efm = 1; break; } //wrong cluster number, so exit
                            f.clusters.push(ptr); //store cluster in array
                            let tmp = set_sect(ptr, bs);
                            f.sectors = f.sectors.concat(tmp); //save the sector(s)
                        }
                    }
                    if (efm) {
                        console.log(`DOS XE => Directory #${f.numidf} (id#${f.dfnbr}) ${f.name} a wrong cluster value has been found!`);
                        f.erf = "==>DOS XE wrong cluster value found, file is corrupted!";
                        f.valid = 1;
                    }
                }
                f.total = f.clusters.length; //file number of clusters
                f.totalS = f.sectors.length; //file number of sectors
                f.fsize = f.len * 250 + f.bflen; //file size in bytes
                if (!f.is_dir) files.push(f);
                console.log(`DOS XE => File #${f.numidf} (id#${f.dfnbr}) ${f.name} with flag $${hex(flags,2)} recorded !`);
                i += 49; //next entry
                if (i >= 0xF5) { //load next directory cluster if any
                    dir_cluster = le16(dbuffer, 0xF8); //get next directory cluster
                    if (!dir_cluster) break; //if zero, no more entry, exit
                    var dbuffer = this.read_cluster(dir_cluster);
                    i = 0; //reset entry index
                }
            } //end of directory
            return files;
        }
        read_cluster(n) { //funtion read_cluster() for DOX XE, using the n cluster value, using cluster_offset(); returns an Uint8Array
            //WIPDOS//Check integrity// use $FA   01 00 >File number (from 0000 to FFFF); use $FC   99 CF >Random disk number (same as in VTOC); use $FE   00 00 >File cluster sequence number (starting at $0000)
            var d = this.atr.d;
            var dst = [];
            var src_ofst = this.cluster_offset(n);
            if (src_ofst < 0) return null;
            for (var i = 0; i < 256; i++) {
                dst.push(d[src_ofst + i]);
            }
            return new Uint8Array(dst);
        }
        read_file(file_clusters, file_size) { //funtion read_file() for DOX XE, using the file_cluster cluster array, and stoping at file_size bytes; returns an Uint8Array
        ///WIPDOS//Check integrity// use $FA   01 00 >File number (from 0000 to FFFF); use $FC   99 CF >Random disk number (same as in VTOC); use $FE   00 00 >File cluster sequence number (starting at $0000)
            var dst = [];
            file_clusters.forEach(fc => {
                var dc = this.read_cluster(fc); //WIPDOS//integrity of cluster must be done before, otherwise dc maybe null
                for (var rc = 0; rc < 250; rc++) {
                    dst.push(dc[rc]);
                }
            });
            if (file_size > 0) dst.length = file_size;   // clip it
            return new Uint8Array(dst);
        }
    }

    //===================================================================================================
    //(PVB MOD) ATR Class & ATARI DOS file flags 
    //see http://ftp.pigwa.net/stuff/collections/nir_dary_cds/Tech%20Info/DOS.HTM (not accurate enough)
    //and for DOS 3 : https://www.atarimax.com/jindroush.atari.org/afsdos3.html (not accurate neither !)
    // So for accurate information please use this link => http://atariki.krap.pl/index.php/Formaty_system%C3%B3w_plik%C3%B3w
    //0x80 value: File (or MyDOS DIRECTORY) deleted for any DOS (all other bits are cleared) (may be recovered if not overriden ?)
    //0x40 bit 6: File exits and in use for any DOS (normal), then bit 7 is clear. Bit cleared for a MyDOS DIRECTORY.
    //0x20 bit 5: File Locked (protected from overwriting and deleting) for any DOS (appears with '*' in directory).
    //0x10 bit 4: bit set only for MyDOS DIRECTORY (bits 6, 2 and 1 then have the value 0)
    //0x08 bit 3: not used
    //0x04 bit 2: is used by MyDOS only, if set means that file has a 16bits sector linking (MyDOS non-DOS2x compatible)
    //0x02 bit 1: is set, file created by DOS2x (if cleared, file created by DOS1). Set also fo a MyDOS file.
    //0x01 bit 0: File Opened for Output for any DOS. Used also by DOS2.5 to indicate that files is stored above sector 719 (and shown with <..>)
    //examples:
    // DOS1: $40=file exists, $60=write-protected file, and $80=file deleted. DOS2: $42=file exists, $62=write-protected file.
    // DOS2.5: $42=existing file available for DOS 2.0; $62= write-protected file available for DOS 2.0;
    //  $03=existing file not available for DOS 2.0; $43=file open for writing and never closed
    // MyDOS: $42 or $46 means an existing file, $62 or $66 - a read-only file, $10 - a directory, $80 - a file or directory deleted
    //  see http://atariki.krap.pl/index.php/Format_MyDOS for MyDOS details
    // DOS3: status of an existing file is $C0, a protected file is $C2, and a deleted file is $80.
    // For ATR structure see: http://www.atarimax.com/jindroush.atari.org/afmtatr.html
    class ATR {
        //(PVB ADD) is_atr(d) function to check if data d is an atr file
        static
        is_atr(d) {
            var sig = le16(d, 0); //(PVB COM) signature (2 first bytes)
            var ssz = le16(d, 4); //Sector Size: only 128 or 256 are handled by the tool
            if (sig == 0x0296) //(PVB COM) $0296 (sum of 'NICKATARI') [MSB 150; LSB 2]
                if (ssz == 128 || ssz == 256) { //check size of sector
                    console.log("ATR Class/is_atr() ==> This is an original ATR with 'NICKATARI' header signature and sector size of " + ssz + " bytes!");
                    return true;
                }
        }
        //(PVB END OF ADD)
        constructor(d, name, ext) { //'ext' is added for DCM & DSK files because no Class is used for the DCM disk image, unlike ATR, ATX, PRO, XFD...
            //(PVB COM) "d" is the raw disk image file data; "name" is the filename like "FoO.Ext"
            if (ATX.is_atx(d)) {
                d = ATX.to_atr(d); // Convert ATX into ATR
                this.orginalATR = "ATX";
            }
            else if (PRO.is_pro(d)) {
                d = PRO.to_atr(d); // Convert PRO into ATR
                this.orginalATR = "PRO";
            }
            else if (XFD.is_xfd(d)) {
                d = XFD.to_atr(d); // Convert XFD into ATR
                if (ext == 'dcm') this.orginalATR = "DCM";
                else if (ext == 'dsk') this.orginalATR = "DSK";
                else this.orginalATR = "XFD";
            }
            else { //(PVB ADD) convert disk image file that has an ATX,PRO,ATR and XFD extension into an XFD default disk image
                if (!ATR.is_atr(d)) {
                    console.log("ATR Constructor() => name '" + name + "' is not ATX, nor PRO, nor XFD, nor ATR => so Convert it into a raw disk image ATR.."); //(PVB CONSOLE HINT)
                    var m = d.length;
                    if (m <= _SD) //Single Density disk (128*720 bytes)
                        m = _SD; //clipped !
                    else if (m <= _ED) //Enhanced Density disk (128*1040 bytes)
                        m = _ED; //clipped !
                    else m = _DD; //Double Density disk (256*717+3*128 bytes) // maximum size
                    console.log("ATR Constructor() => '" + name + "' size has been restructured into a " + m + " bytes disk image"); //(PVB CONSOLE HINT)
                    var z = new Uint8Array(m); //create a new ATR disk image file with m bytes
                    z.set(d.subarray(0, m)); //copie the data from 'd' into new disk (maximum size m=183936) // remaining data are clipped
                    d = XFD.to_atr(z); //add the 16 bytes ATR header
                    this.restructured = true; //flag for identifying the conversion into raw image file
                }
                else {
                    this.orginalATR = "ATR"; //tagged as a genuine ATR
                }
            } //(PVB COM) "else" here this is an ATR file, obviously
            //(PVB END OF ADD)
            //(PVB MOD the size and sector count)
            this.d = d; //converted data go into the ATR
            this.name = name;
            this.sector_size = le16(d, 4); //ATR Header -> Sector size
            this.size = (le16(d, 2) + (d[6] << 16)) << 4; //ATR Header -> Disk size
            if (this.size == 720*256 || this.size == 1440*256) { //Check for buggy ATR
                this.sector_count = this.size / 256;
                this.size -= 384; //new corrected size
                console.log("ATR constructor() => This is a buggy ATR size with 3 first 256-bytes sectors! So let's correct it...");
                var atrmod = new Uint8Array(this.size); //actual size of disk (without ATR header and 3x128 buggy additional bytes)
                atrmod.set(d.slice(16, 384 + 16)); //copy 3 first boot sectors from datafile
                atrmod.set(d.slice(3 * 256 + 16, this.size - 16), 384); //copy rest of datafile, at 3x256 byte offset, cancel bytes from 384 ($180) to 767 ($2FF)
                this.d = XFD.to_atr(atrmod); //make a new ATR with ATR 16-bytes header
                console.log("ATR constructor() => OK, buggy ATR corrected into a " + this.size + " bytes disk!");
                this.buggy = true;
            }
            else
                this.sector_count = (this.size - 128 * 3) / this.sector_size + 3; //compute number of disk sector
            if (_bModif) {
                this.bModif = true; //memorized that the disk image was modified
                _bModif = false; //and reset it for next time
            }
            console.log("ATR constructor() => Number of sectors in the ATR is " + this.sector_count);
            this.dir_sector = 0; //(PVB COM) by default, no directory sector
            this.bootFlag = d[16] //bootflag = 1st byte on disk, set by some DOS
            if (!this.restructured) {
                //(PVB COM) check bytes for a SpartaDOS compatible disk (see http://atariki.krap.pl/index.php/Format_SpartaDOS )
                if (d[16 + 6] == 0x4C && (d[16 + 32] == 0x11 || d[16 + 32] == 0x20 || d[16 + 32] == 0x21)) { //SpartaDOS: the Jump and the versions
                    if (d[16 + 7] == 0x80) { //byte #7 of the 1st sector contains $80 in a SpartaDOS compatible disk with 128 or 256 bytes/sector
                        console.log("ATR constructor() => has found a SpartaDOS compatible disk!"); //(PVB HINT)
                        this.sparta = new SpartaDOS(this);
                        this.vtoc1_sect = this.sparta.boot.first_bitmap; //(PVB ADD)
                    }
                    else if (d[16 + 7] == 0x40 && d[16 + 31] == 1) //SpartaDOS byte #7 is $40, and 512 byte/sector: compatible and not handle by the tool
                        console.log("ATR constructor() => has found a 512 bytes/sector SpartaDOS disk => NOT SUPPORTED by the tool, normal DOS will be used!"); //(PVB HINT)
                }
            }
            //(PVB ADD) now identify DOS type...
            this.dosType = this.identify_dos();
            if (this.dosType == 3) this.isDos3 = true; //to simplify logic test in case of specific DOS3
            if (this.dosType == 4) this.isDos4 = true; //to simplify logic test in case of specific DOS4
            if (this.dosType == 5) this.isDosXE = true; //to simplify logic test in case of specific DOSXE
            console.log("ATR constructor() => identify_dos returns ATR.dosType = " + this.dosType); //(PVB HINT)
            this.ATRCheckSum = calChkSum(d, 0); //and compute checksum
            console.log("ATR constructor() => ATR construction done (into an ATR of $" + hdx(this.ATRCheckSum) + " checksum)!"); //(PVB HINT)
        }
        //(PVB COM) sector_offset() function: returns the memory index of sector 'n' in the ATR disk image data (including 16-bytes ATR header)
        sector_offset(n) {    // 1 based (first sector is number 1 (and not 0)
            //(PVB COM) sector_offset(n) computes the memory pointeur for sector 'n' into the ATR 'data'
            n--;
            if (n < 3) //(PVB COM) first 3 sectors for boot are always 0x80 bytes
                return 16 + n * 0x80; //(PVB COM) 16 = for ATR header bytes
            return 16 + 3 * 0x80 + (n - 3) * this.sector_size; //(PVB COM) 16 are for ATR header bytes, plus 3 * 0x80 bytes for 3 sectors of boot
        }

        //(PVB ADD) read_sector() function, to read any raw sector from the disk
        read_sector(n) {
            var offset = this.sector_offset(n);
            var d = this.d;
            var sectordata = [];
            if (n < 3)
                sectordata = d.slice(offset, offset + 128);
            else
                sectordata = d.slice(offset, offset + this.sector_size);
            return sectordata;
        }
        alloc_unit_sector(n) { //for DOS 4, return the starting sector of the AU #n
            if (n < 0) return -1; //error, for files, no use of cluster below 0
            var ofst = n * this.blockSect + 1;
            return (ofst + this.blockSect > this.sector_count) ? -1 : ofst;
        }
        alloc_unit_offset(n) { //For DOS 4, return the offset of the AU in the d disk image data
            if (n <= 0) return -1; //error, for files, no use of cluster 0
            var ofst = this.sector_size == 128 ? (16 + n * this.blockSize) : (16 + n * this.blockSize - 384);
            if ((ofst + this.blockSize) >= this.d.length) return -1; //end of file ?
            return ofst;
        }
        get_vtoc(d, v) { //for DOS4, get VTOC from d disk image data
            var s = this.sector_offset(v); // with the first 8 bytes that are not VTOC bytes
            var e = s + (v == 515 || this.sector_size == 256 ? 256 : 128); //for ED disk, VTOC in 515 continues on sector 516, so VTOC is 256 bytes
            return d.slice(s, e);
        }
        //(PVB END OF ADD)

        //(PVB MOD) one_dir() improvement, MyDOS subdirectories support, and DOS3 + DOS4 support (with AU block = Allocation Unit block)
        one_dir(n, sector, idf, subdirname) {// one_dir() is called by get_dir_range() and scan_files()
            // (PVB COM) 'n' is the dir entry from 1 to 8 (or 1 to 16 in DD & DSDD disk) into the directory sector; idf is the count of file (file number in the directory)
            // that is also use in DOS file sector control byte; "subdirname" parameter is the name of the parent's MyDOS subdirectory
            var m = 32; //(PVB CONSOLE HINT) limits the consolelog event display for the 32 first directory entry
            var d = this.d;
            var j = this.sector_offset(sector) + n * 16; //index in the memory for the beginning entry position number "n"
            var dirEntry = [];
            var dosVtocArray = []; //VTOC table of the DOS 3 (sector 24) or DOS 4 (this.vtoc1_sect) //WIPDOS// put dosVtocArray as a global atr variable instead to set it at each one_dir() call ??
            var tdos = this.dosType; // here tdos is 1 to 4 for DOS1 to DOS4; and 6 to 8 for MyDOS
            //check if entry is 16 zero bytes
            if (is_zero(d, j, 16)) { //function is_zero() returns true if there is len 00 bytes from d[j]
                if (idf < m) console.log(" one_dir() =>Error! File#" + idf + " entry is $00 bytes into DOS TOC!"); //(PVB CONSOLE HINT)
                else console.log(" one_dir() =>Error! Entry is $00 bytes into DOS TOC!");
                return dirEntry; //no dir entry, 16 times $00 bytes found on the dir entry
            } 
            if (tdos == 3) { // for DOS 3
                dosVtocArray = this.read_sector(24); //initialisation of the file layout table (sector 24)
                dirEntry = {
                numidf: idf, // (PVB ADD) the idf to count & identify files
                flags: d[j],  //(PVB) Byte 0 : Flag Byte of the DOS3 file: 0xC2 is OK, 0xC1 file exists and is open, 0x80 deleted, 00 no entry, bit 0x02 file is protected
                total: d[j +12], // Byte 12 : Total number of block (1 block = 8 sectors)
                startbloc: d[j +13], // Byte 13 : start block byte.
                fsize: le16(d, j +14), //size of the file in bytes (last 16 bits), it is used to define the last valid byte in the last AU
                name83: toAscii(d, j +1, 11), // Byte 5-15 : 11 char = 8 character filename padded with spaces at end + 3 character filename extension padded with spaces at end
                name: toAscii(d, j +1, 8).trim(), // Byte 1-8 : 8 character filename padded with spaces at end
                ext: toAscii(d, j +9, 3).trim(), // Byte 9-11 : 3 character filename extension padded with spaces at end
                };
                dirEntry.start = d[j +13] * 8 + 25 //Compute start sector = start block byte * 8 + 25; Starting sector number of the DOS file (as one AU is 8 sectors = this.blockSect)
                dirEntry.bflen = dirEntry.fsize - (((dirEntry.total - 1) * this.blockSize) & 0x0FFFF); //compute the number of bytes in the last block
                //NOTA: dirEntry.fsize : will be computed precisely below
            }
            else if (tdos == 4) {// for DOS 4
                dosVtocArray = this.get_vtoc(d, this.vtoc1_sect); //initialisation of the file layout table (sector vtoc1_sect)
                dirEntry = {
                numidf: idf, // idf to count & identify files
                flags: d[j],  //$00 Flag Byte of the DOS4 file: 0x80 deleted, 0x40 file exists, bit 0x20 file is protected, 0x01 file is open, 0x81 is special new created, 00 no entry.
                total: d[j +1], //$01 Total number of block for the file
                bflen: d[j +2], //$02 offset of the last byte of data contained in the last sector of the file // no use of fsize as for DOS3
                name83: toAscii(d, j +5, 11), // Byte 5-12 : 11 char = 8 character filename padded with spaces at end + 3 character filename extension padded with spaces at end
                name: toAscii(d, j +5, 8).trim(), // Byte 5-12 : 8 character filename without spaces
                ext: toAscii(d, j +13, 3).trim(), // Byte 13-15 : 3 character filename without spaces
                startbloc: d[j +3] //$03 byte number in the VTOC where the information about the file's location on the diskette begins, increased by eight (for direct VTOC access)
                };
                dirEntry.start = this.alloc_unit_sector(dirEntry.startbloc - 8); //Compute start sector = file start sector taken from first sector AU block the DOS4 file
                dirEntry.fsize = dirEntry.total * this.blockSize; //NOTA: fsize will be computed precisely below, as we don't know how many sectors in the last AU block are for the file
            }
            else // for ATARI DOS1 & DOS2X and MyDOS
                dirEntry = {
                numidf: idf, // (PVB ADD) the idf to count & identify files
                flags: d[j],  // Byte 0 : Flag Byte of the DOS2 file
                total: le16(d, j +1), // Byte 1-2 : Total number of sectors of DOS file. 
                start: le16(d, j +3), // Byte 3-4 : Starting sector number of the DOS file.
                fsize: 0, // filesize in bytes default value 0 : dirEntry.fsize will be compute with the read_file() result in load_data()
                name83: toAscii(d, j +5, 11), // Byte 5-15 : 11 char = 8 character filename with spaces at end + 3 character filename extension padded with spaces at end
                name: toAscii(d, j +5, 8).trim(), // Byte 5-12 : 8 character filename without spaces at end
                ext: toAscii(d, j +13, 3).trim(), // Byte 13-15 : 3 character filename extension without spaces at end
                dir_name: subdirname ? subdirname : "" //add parent's name if in a subdirectory (for MyDOS)
                };
            if (dirEntry.ext)
                dirEntry.name += '.' + dirEntry.ext; //"name" is like "dup.sys", without space but with ".ext"
            //(PVB MOD & ADD) Improvement of DOS file detection and validation
            dirEntry.valid = 2; //1 is valid (readable) and to be listed with error, 0 is not valid, 2 is OK fully valid (no error)
            //following 2 conditions to check are the minimum to get a file from the dir entry: a valid name & a consistant start sector
            var title = (tdos != 3) ? d.slice(j +5, j +16) : d.slice(j +1, j +12); //name in an Ascii byte array
            var isName = isAtariNameChar(title, this.dosType >= 7); //is that name is valid with atari char text ?
            if (is_zero(d, j, 16)) {
                dirEntry.valid = 0;
                if (idf < m) //(PVB CONSOLE HINT)
                    console.log(" one_dir() =>Error! File#" + idf + ": has only zero into DOS TOC entry!"); //(PVB CONSOLE HINT)
            }
            else if (!isName) {
                dirEntry.valid = 0;
                if (idf < m) //(PVB CONSOLE HINT)
                    console.log(" one_dir() =>Error! File#" + idf + ": has a name with invalid chars!"); //(PVB CONSOLE HINT)
            }
            else if ((dirEntry.start < this.file_start) || (dirEntry.start > this.sector_count)) {
                dirEntry.valid = 0;
                if (idf < m) //(PVB CONSOLE HINT)
                    console.log(" one_dir() =>Error! File#" + idf + ": inconsistent start sector! ($" + hex(dirEntry.start, 3) + ")"); //(PVB CONSOLE HINT)
            }
            if (!dirEntry.valid) return [];
            //dir.total is checked below while reading sectors of the file
            //here filename is valid start sector is OK
            dirEntry.gname83 = ''; //original filename, eventually with inverted char (not DOSx compatible)
            title.forEach(c => dirEntry.gname83 += String.fromCharCode(c)); //original filename is set from 'title'
            dirEntry.erf = ''; // text of error in case of
            if (isName < 0) {
                dirEntry.erf += " >not genuine DOSx filename with special char!";
                if (idf < m) //(PVB CONSOLE HINT)
                    console.log(" one_dir() =>Warning! File#" + idf + " '" + dirEntry.name + "'" + dirEntry.erf); //(PVB CONSOLE HINT)
            }
            if (d[j] == 0x80) { //$80 byte flag is deleted, as per DOS1, DOS2, DOS3 and DOS4
                dirEntry.erf += " >deleted file ($80 flag)"
                if (idf < m) //(PVB CONSOLE HINT)
                    console.log(" one_dir() =>Info: File#" + idf + ": " + dirEntry.name + " is a deleted file that could be wrong!"); //(PVB CONSOLE HINT)
            }
            else if (tdos > 5 && d[j] & 0x10 && dirEntry.total == 8) { //MyDOS subdirectory handling (flag = 0x10, 8 sectors length)
                dirEntry.is_dir = true;  //it's a MyDOS subdirectory
                dirEntry.sectors = []; //add subdir sectors
                var s = dirEntry.start;
                for (var k = 0; k < 8; k++) dirEntry.sectors[s+k] = { sector: s+k, slen: this.sector_size, snext: 0, fbloc: k }; //sectors init
                if (idf < m) //(PVB CONSOLE HINT)
                        console.log(" one_dir() =>We have found the #" + idf + "'" + dirEntry.name + "' subdirectory!"); //(PVB CONSOLE HINT)
                return dirEntry;
            }
            else { //standard file, not deleted
                if (tdos == 3 && !(d[j] & 0xC0)) { //$C0 is the valid flag for DOS3
                    dirEntry.valid = 1; //readable, but wrong ?
                    dirEntry.erf += " >DOS3 dir entry not valid (no $0C flag)!"
                    if (idf < m) //(PVB CONSOLE HINT)
                        console.log(" one_dir() =>Error! File#" + idf + ": " + dirEntry.name + " (DOS3) is not existing (no 0xC0 flag)!"); //(PVB CONSOLE HINT)
                }
                if ((d[j] & 0x41) == 0x41) { //$41 means not deleted and Open, applies to DOS2x, DOS3, DOS4 & MysDOS
                     dirEntry.erf += " >non-closed file (open-for-writing flag)!";
                    if (idf < m) //(PVB CONSOLE HINT)
                        console.log(" one_dir() =>Info: File#" + idf + ": " + dirEntry.name + " is a non-closed file that is open for writing, so may be wrong!"); //(PVB CONSOLE HINT)
                }
            }
            if (!dirEntry.valid) return dirEntry; //returns an empty dirEntry if non valid
            // get all sectors associated with this entry & check validity
            dirEntry.sectors = []; //initialisation of the DOS file sector table
            var num = -1; //init of the file number index
            var next = -1; //init of next sector
            var len = -1; //init of bytes per sector
            var sector = 0;
            var nextbloc = -1;
            if (tdos != 3 && tdos != 4) { //for standard DOS (not DOS3) (nota for MyDOS, tdos is 6, 7 or 8)
                sector = dirEntry.start; //current sector is the first one
                if (dirEntry.total) {
                    console.log(" one_dir() =>File#" + idf + ": DOS1/DOS2x/MyDOS '" + dirEntry.name + "' reading sectors...");
                    for (var k = 0; k < dirEntry.total; k++) { //up to the total number of block (sector)
                        var end = this.sector_offset(sector) + this.sector_size; //end of file pointer
                        len = d[end - 1]; //len of data in the sector is set in the last byte of the sector
                        if (tdos == 7 || tdos == 8) { //MyDOS 16 bits next sector
                            next = d[end-3] * 256 + d[end-2];
                            if ((!dirEntry.flag & 0x04) && k == 0) { //check only for first sector
                                //MyDOS 16bit sector chain flag not set in dir entry  ($04) but we continue as 16 bit chaining is used by default for MyDOS
                                console.log(" one_dir() =>Info! File#" + idf + ": MyDOS 16bits sector chain flag in " + dirEntry.name + " file directory entry not set!");
                            }    
                        }
                        else {
                            next = ((d[end - 3] & 0x3) << 8) | d[end - 2];
                            if (num == -1)  //first issue...
                                num = d[end - 3] >> 2; //.. set the file number from the MSB byte of the first sector
                            if (num != idf || num != (d[end - 3] >> 2)) { //file number in the MSB index of the next sector is not right or has changed
                                //(PVB TODO) add information according to conditions
                                if (dirEntry.flags == 0x80 && k == 0) {
                                    dirEntry.valid = 1;
                                    if (dirEntry.dir_name) //exit Loop if the deleted file is in a MyDOS subdirectory, because the overwritting check does not work
                                        console.log(" one_dir() =>Deleted MyDOS subdirectory file#" + idf + " is not valid!");
                                    else { //not in a subdirectory, so the overwritting check can be done
                                        dirEntry.erf += " >file overwritten by file #" + num +" >file unrecovarable!";
                                        console.log(" one_dir() =>Error! File#" + idf + ": DOS2x/MyDOS " + dirEntry.name + " has been overwritten by file #" + num + " in sector " + sector +"!");
                                    }
                                    break; //exit loop
                                }
                                else {
                                    dirEntry.valid = 1;
                                    dirEntry.erf += " >wrong file id in FMS byte at sect." + sector +" >" + k + " sect. read >file corrupted!";
                                    console.log(" one_dir() =>Error! File#" + idf + ": DOS2x/MyDOS " + dirEntry.name + " has wrong file number #" + num + " in sector " + sector +" after " + k + " sectors!");
                                    break; //exit loop
                                }
                            }
                        }
                        if (tdos != 1) { 
                            var is_good_len = (next == 0) ? (len <= (this.sector_size - 3) && len) : len == (this.sector_size - 3);
                            //is_good_len = true if (end sector && length of data to read is <= (sector size - 3) and not zero) or 
                            // (not end sector and length of data to read is = (sector size - 3))
                            if (!is_good_len) {
                                dirEntry.valid = 1;
                                dirEntry.erf += " >wrong length in FMS byte at sect." + sector + " >file corrupted!";
                                console.log(" one_dir() =>Error! File#" + idf + ": DOS2x/MyDOS " + dirEntry.name + " has wrong byte_length (" + len + ") in sector " + sector +"!");
                                break; //exit loop
                            }
                        }
                        else { //else if (tdos == 1) //(PVB TODO) count the file sector in len if z set
                            if (len & 0x80) { //check Z : if set, it is the last sector of DOS1 file
                                if (next) {
                                    dirEntry.valid = 1;
                                    dirEntry.erf += " >DOS1 Z bit set in the FMS byte!";
                                    console.log(" one_dir() =>Error! File#" + idf + ": DOS1 " + dirEntry.name + " has Z bit set in last sector " + sector +"!");
                                    break; //exit loop
                                }
                            }
                            else { //if Z clear, we are not in the last sector of DOS1 file (PVB TODO) : count the file sector in len...
                                len = this.sector_size - 3; //that is $7F
                                if (!next) {
                                    dirEntry.valid = 1;
                                    dirEntry.erf += " >DOS1 Z bit cleared in FMS byte!";
                                    console.log(" one_dir() =>Error! File#" + idf + ": DOS1 " + dirEntry.name + " has Z clear and no next sector in sector " + sector +"!");
                                    break; //exit loop
                                }
                            }
                            len &= 0x7F; //any way clear the bit 8
                        }
                        if (next > this.sector_count) {
                            //next is above last sector of disk
                            dirEntry.valid = 1;
                            dirEntry.erf += " >wrong next sector in FMS bytes at sect." + sector + " >file corrupted!";
                            console.log(" one_dir() =>Error ! File#" + idf + ": DOS2x/MyDOS " + dirEntry.name + " has wrong next_sector (" + next + ") in sector " + sector +"!");
                            break; //exit loop
                        }
                        /* //desactivated, accept this at this stage//
                        if (num != (d[end - 3] >> 2)) {
                            //file numbering the MSB index of the next sector has changed
                            dirEntry.valid = false;
                            console.log(" one_dir() =>File#" + idf + ": DOS2x/MyDOS " + dirEntry.name + " has wrong file_number in sector " + sector +"!");
                            break;
                        }*/
                        dirEntry.sectors[sector] = { sector: sector, slen: len, fbloc: k, snext: next, fid: num, slen: len}; //save the sector (offset = sector number)
                        
                        if (next == 0) { // check real end of file
                            if (k != dirEntry.total - 1) { // EndOfFile reached before the end of total sector get from the file VTOC directory
                                dirEntry.valid = 1;
                                dirEntry.erf += " >no FMS next sector at sect." + sector + " & total to read not reached >file corrupted!";
                                console.log(" one_dir() =>Error! File#" + idf + ": DOS2x " + dirEntry.name + " is truncated: next sector after " + sector + " is zero!");
                            }
                            break;  //exit loop // EOF?
                        }
                        sector = next;
                    }
                }
                else { // else if (!dirEntry.total) //if size is zero block or zero sector //(PVB CONSOLE HINT)
                    console.log(" one_dir() =>Info: File#" + idf + ": DOS2x/MyDOS " + dirEntry.name + " is zero byte length!");
                }
            }
            else if (tdos == 3) {
                //DOS3 computing of the exact file size// fsize in the directory table is the lowest 16 bit (2 bytes) value of the actual file size
                //file max size = dirEntry.total (=number of blocks) x 8 (=AU sectors) x this.sector_size = this is the highest byte of actual file size
                dirEntry.fsize = ((dirEntry.total * this.blockSize) & 0xF0000) + dirEntry.fsize; //so update extact fsize =  file max size "and" the "lowest 16 bits" fsize bytes of the dir entry 
                if (!dirEntry.fsize) {
                    console.log(" one_dir() =>File#" + idf + ": DOS3 " + dirEntry.name + " is not a valid file as zero byte length!");
                }
                else {
                    console.log(" one_dir() =>File#" + idf + ": DOS3 '" + dirEntry.name + "' reading sectors...");
                    var nls = 7; //from 0 to 7, 8 sectors in a block
                    var fNbrSect = 1; //number of sector for the file, starting at 1
                    var derr = "";
                    nextbloc = dosVtocArray[dirEntry.startbloc]; //init//number of current block, initialised to the start one
                    sector = dirEntry.start; //init//current sector is the first one
                    for (var k = 0; k < dirEntry.total; k++) { //up to the total number of AU blocks in the DOS3 file
                        if (sector == 0 || sector > this.sector_count) { //error sector is above total sector of disk
                            derr = " >invalid next block sector at file block #" + k + " >file corrupted!";
                        }
                        else if (nextbloc >= 0xFD && (k != dirEntry.total - 1)) { // error! EOF byte, but remaining block !
                            derr = " >EOF byte at file block #" + k + " with remaining block to read >file corrupted!";
                        }
                        else if ((k == dirEntry.total - 1) && nextbloc < 0xFD) { // error! no remaining block and no EOF byte !
                            derr = " >No remaining block to read and EOF byte not reached >file corrupted! at file block #" + k;
                        }
                        if(derr) {
                            dirEntry.erf += derr;
                            dirEntry.valid = 1;
                            console.log(" one_dir() =>File#" + idf + ": DOS3 " + dirEntry.name + " has" + derr);
                            break; //exit loop
                        }
                        next = sector + 1;
                        if (nextbloc == 0xFD) { //End-of-File, this is the last block
                            nextbloc = -1; //means EOF
                            nls = (dirEntry.bflen - 1) >> 7; //number of sector in the last block
                            len = dirEntry.bflen - nls * 128; //nbr of bytes in the last sector
                        } 
                        for (var s = 0; s <= nls; s++) { //do all the sectors of the DOS3 block
                            dirEntry.sectors[sector + s] = {sector: sector + s, slen: this.sector_size, snext: next++, fbloc: k, cbloc: nextbloc}; //save the sector (offset is sector number)
                            if (s == nls && nextbloc == -1) { //this is the last sector of the last block
                                dirEntry.sectors[sector + nls].snext = 0; //so no next sector
                                dirEntry.sectors[sector + nls].slen = len;
                            }
                            fNbrSect ++;
                        }
                        if (nextbloc > 0) { //we are not at EOF
                            next = nextbloc * 8 + 25; //compute sector of the next block, use 'next' temporarily
                            nextbloc = dosVtocArray[nextbloc]; //and read next block
                            dirEntry.sectors[sector + 7].snext = next; //adjust "snext" of previous block
                            sector = next;
                        }
                    }
                    dirEntry.totalSect = fNbrSect;
                }
            }
            else if (tdos == 4) {
                if (!dirEntry.fsize) {
                    console.log(" one_dir() =>File#" + idf + ": DOS4 " + dirEntry.name + " is not a valid file as zero byte length!");
                }
                else {
                    console.log(" one_dir() =>File#" + idf + ": DOS4 '" + dirEntry.name + "' reading sectors...");
                    var nls = this.blockSect - 1;
                    var fNbrSect = 1; //number of sector for the file, starting at 1
                    var fNbrSize = 0; //size of the file // to compute
                    var derr = "";
                    nextbloc = dosVtocArray[dirEntry.startbloc]; //get the file vtoc byte in the VTOC, either it is a next "AU + 8" , either and EOF (if < 8)
                    sector = dirEntry.start; //set initial first sector which corresponds to the first AU of the file
                    len = this.sector_size;
                    for (var k = 0; k < dirEntry.total; k++) { //up to the total number of AU blocks in the DOS4 file
                        if (sector <= 0 || sector > this.sector_count) { //error sector is above total sector of disk
                            derr = " >invalid next block sector at file block #" + k + " >file corrupted!";
                        }
                        else if (nextbloc <= 8 && (k != dirEntry.total - 1)) { // error! EOF byte, but remaining block !
                            derr = " >EOF byte at file block #" + k + " with remaining block to read >file corrupted!";
                        }
                        else if ((k == dirEntry.total - 1) && nextbloc > 8) { // error! no remaining block and no EOF byte !
                            derr = " >No remaining block to read and EOF byte not reached >file corrupted! at file block #" + k;
                        }
                        if(derr) {
                            dirEntry.erf += derr;
                            dirEntry.valid = 1;
                            console.log(" one_dir() =>File#" + idf + ": DOS4 " + dirEntry.name + " has" + derr);
                            break; //exit loop
                        }
                        next = sector + 1;
                        if (nextbloc < 8) { //End-of-File, this is the last AU block, nextbloc is the number of remaining sectors
                            nls = nextbloc; //nls = "nextbloc" sectors within the last AU block
                            nextbloc = -1; //means EOF
                        }
                        for (var s = 0; s <= nls; s++) { //do all the sectors of the DOS4 AU block
                            dirEntry.sectors[sector + s] = {sector: sector + s, slen: this.sector_size, snext: next++, fbloc: k, cbloc: nextbloc}; //save the sector (offset is sector number)
                            if (s == nls && nextbloc == -1) { //this is the last sector of the last block
                                dirEntry.sectors[sector + nls].snext = 0; //so no next sector
                                dirEntry.sectors[sector + nls].slen = dirEntry.bflen + 1;
                                len = dirEntry.bflen + 1;
                            }
                            fNbrSect ++;
                            fNbrSize += len;
                        }
                        if (nextbloc > 0) { //we are not at EOF
                            //compute sector of the next AU, use 'next' temporarily
                            next = this.alloc_unit_sector(nextbloc - 8); //then get the start sector of the next AU //if (next == -1) then error
                            nextbloc = dosVtocArray[nextbloc]; //and read next block
                            dirEntry.sectors[sector + this.blockSect - 1].snext = next; //adjust "snext" sector of last sector of previous block
                            sector = next;
                        }
                    }
                    dirEntry.fsize = fNbrSize;
                    dirEntry.totalSect = fNbrSect;
                }
            }
            if (dirEntry.valid != 2)
                dirEntry.sectors = []; //if file entry not valid, no sector is save in the dirEntry
            else
                console.log(" one_dir() =>OK: File#" + idf + ": " + (tdos == 3 ? "DOS3 '" : (tdos == 4 ? "DOS4 '" : "DOS2x/myDOS '")) + dirEntry.name + "' file is valid !!");
            return dirEntry;
        }

        // Search the entire disk for sneaky directory entries
        get_dir_range(from, to, subdirname) { // get_dir_range() is called by get_dir(); DOS XE and SpartaDOS not handled because they have dedicated routine
            //(PVB COM) Search in the directory table that is (from, to) sectors ('to' is not included !);
            //(PVB ADD) the "subdirname" parameter in case of a MyDOS subdirectory
            var dirs = [];
            var idf = 0;
            //Set number of entry in a directory sector for Double Density DOS: only DOS4 in DD has 16 entries in one 256 bytes sector; DOS2.0d and MyDOS keep 8 entries in 256 bytes sector
            var nbrofentry = (this.isDos4 && this.sector_size == 256) ? 16 : 8; //otherwise there is always 8 entries per sector of 128 bytes
            for (var i = from; i < to; i++) {   // (PVB COM) "i" stands for the sector range of the dir table (like the 8 sectors 361-368)
                for (var n = 0; n < nbrofentry; n++) {   // (PVB COM) "n" stands for the 8 lines of file entry in each sector of the dir table
                    var dir = this.one_dir(n, i, idf++, subdirname); // (PVB COM) "dir" gets the content of one file entry
                    if (dir.valid) {
                        if (!this.dir_sector)
                            this.dir_sector = i; //first sector stored in dir_sector if it was not set
                        dirs.push(dir);
                    }
                    if (dir.is_dir) { //(PVB ADD) if this is a MyDOS directory, then recurse
                        dirs = dirs.concat(this.get_dir_range(dir.start, dir.start + 7, dir.name)); //7 sectors
                    }
                }
            }
            return dirs;
        }

        //(PVB MOD) DOS3, DOS4 and DOS XE added for get_dir()
        get_dir() {
            if (this.sparta) { //SpartaDOS don't use get_dir_range() nor one_dir() 
                console.log("get_dir() => Retreiving the SpartaDOS disk directory...");
                return this.sparta.get_dir();
            }
            if (this.isDosXE) { //SpartaDOS don't use get_dir_range() nor one_dir() 
                console.log("get_dir() => Retreiving the DOS XE disk directory...");
                this.dosxe = new DosXE(this);
                return this.dosxe.get_dir();
            }
            var dirs = [];
            if (this.dosType == 10) { //KBOOT disk: the file on the disk is the only one, so we set it direcly in 'dirs'
                var fl = {numidf: 1, flags: 0x42, valid: 2, fsize: this.totalBlock, start: this.file_start};
                Object.assign(fl, {name83: "KBOOFILEXEX", name: "KBOOFILE.XEX", ext: "XEX"});
                fl.sectors = [];
                for (var i = 0; i < (this.totalBlock / 128); i++) {
                    fl.sectors.push(this.file_start + i);
                }
                fl.total = fl.sectors.length;
                dirs.push(fl);
            }
            else if (this.isDos3 || this.isDos4) { //for DOS3 & DOS4; the directory sectors are just before the VTOC se"ctor
                console.log("get_dir() => Retreiving the DOS3/DOS4 disk directory at sectors [" + this.dir_sector + "-" + this.vtoc1_sect + "]...");
                dirs = this.get_dir_range(this.dir_sector, this.vtoc1_sect); //from first sector argument, to the second sector argument that is not included
                if (dirs.length < 1 ) {
                    console.log("get_dir() => No DOS3/DOS4 directory entry found!");
                }
            }
            else if (this.dosType > 0 || this.dosType == -1) { //(PVB COM) for not DOS3 nor DOS4
                console.log("get_dir() => Retreiving DOS1, DOS2x or MyDOS disk directory at 361-368...");
                dirs = this.get_dir_range(361, 369); //369 not included
                if (dirs.length < 1 && this.dosType < 8) { //(PVB MOD) Not for MyDOS4.5x HD disk
                    console.log("get_dir() => No DOS2x directory found at 361-368.... let's try into the whole disk...");
                    dirs = this.get_dir_range(4, this.sector_count);  // try the whole disk
                }
                if (this.dir_sector == 0) { // if nothing found...
                    console.log("get_dir() => No DOS2x directory entry found on whole disk");
                    this.dir_sector = 361;  // didn't find one, so use default (that is sector 361)
                }
            }
            if (this.dosType == -1 || (this.dosType > 1 && this.dosType < 3) || this.dosType == 6) { //if no DOS found, or for DOS2x, or for MyDOS compatible with DOS2x 
                console.log("get_dir() => Try and find files that don't have a real directory entry like the erased ones...");
                //(PVB TODO) Scan files() only if not a DOS2x disk ?
                this.scan_files(dirs);      // try and find files that don't have a real directory entry
            }
            return dirs; //(PVB COM) complete directory table is returned, 'dirs' is empty if no file found
        }

        //(PVB MOD & ADD) Rewrite the scan_files(dirs) function to retrieve and recover lost or hidden files (min 2 sectors !) 
        scan_files(dirs) { //scan_files() is called by get_dir(), only for DOS2x and MyDOS system
            var d = this.d;
            var sSectors = [];
            //(PVB TODO) check the previous utility of "used" ? in the original TOOL //WIP may be make a map of the disk used ?
            /*var used = []; dirs.forEach(dir => dir.sectors.forEach(s => used[s] = dir)); //last directory entry
            dirs.forEach(dir => used[dir.start] = dir); //record each dir entry in an array with its start sector as index */
            var files = [];
            for (var i = 4; i <= this.sector_count ; i++) { //map the sector of the disk
                var end = this.sector_offset(i) + this.sector_size;
                var len = d[end - 1];
                var next = ((d[end - 3] & 0x03) << 8) | (d[end - 2]);   // TODO: 10 bits
                if (len == (this.sector_size - 3) || ((len <= (this.sector_size - 3)) && next == 0))
                    sSectors[i] = { sect: i, len: len, next: next, num: d[end - 3] >> 2 };
                else //means file broken by wrong sector, like an empty BAD sector, filed with zero or inconsistant data
                    sSectors[i] = { sect: i, len: 0, next: 0, num: -1 };
            }
            sSectors.forEach(s => { //add previous sector
                var n = sSectors[s.next];
                if (n) {
                    if (n.num == s.num)
                        n.prev = s.sect;
                    else s.next = 0;
                }                    
            });
            sSectors.forEach(s => {
                if (!s.prev && s.len) { //this is the pilot sector, as the first sector of a file and no prev sector
                    s.total = 0;
                    s.bytes = 0;
                    s.used = 0;
                    s.error = 0;
                    s.fsectors = [];
                    var n = s; //first sector is copied into n, s is kept into the loop
                    do {
                        s.fsectors[n.sect] = {sector: n.sect, slen: n.len, snext: n.next, fbloc: s.total };
                        s.bytes += n.len; //s.bytes = number of bytes in the file
                        s.total++; //s.total = number of sector
                        if (n.next == 0) //end of file, exit loop
                            break;
                        var ns = sSectors[n.next]; //get next sector
                        if (n != s) { //exclude first sector
                            //if next sector is empty, or sector link damaged, or wrong id : need to close current file and set a new one
                            if (!ns || (ns.prev != n.sect) || (s.num != n.num)) { 
                                s.error++; //the retrieved file has an error
                                s.fsectors[n.sect].snext = 0; //so cancel the next sector
                                sSectors[n.sect].next = 0;
                                if (ns && (s.num != n.num)) //reajust "previous" to zero in the next sector only for 'num' mismatching
                                    sSectors[ns.sect].prev = 0;
                                break;
                            }
                        }
                        n = ns; //iterative n is set to next sector
                    } while (n);
                    if (s.total > 1) //at least 2 chained sectors to identify a file !
                        files.push(s); //push the 'fsectors' file sector list in the "pilot" first sector in the file (the one without prev)
                }
            });
            var _correlated;
            function match(sect, num, error, bytes) {
                _correlated = 0;
                for (var i = 0; i < dirs.length; i++) { //(PVB COM) list of recognized filenames in the TOC Dir entry
                    if (dirs[i].start == sect && dirs[i].numidf == num) {
                        _correlated++; //the file is in the TOC Dir entry
                        if (!error && dirs[i].valid == 2) { //the file is valid
                            dirs[i].correlated = true; // valid file correlated !
                            dirs[i].fsize = bytes;
                            console.log("scan_files() =>Info: file #" + num + " '" + dirs[i].name + "' correlated, start at " + sect + ", length is " + bytes + " bytes, " + dirs[i].total + " sectors" );
                            return true; //no need to recover, we match a valid file !
                        }
                        break; //exit loop
                    }
                }
                return false; //to be recovered
            }
            // now we have chains of files, recover those missing dir entries
            var i = 0;
            files.forEach(f => {
                if (!match(f.sect, f.num, f.error, f.bytes)) { //not valid file ?
                    var name = "FILE_" + hex(i) + ".DAT";
                    var name83 = "FILE_" + hex(i++) + " DAT";
                    var ext3 = "DAT";
                    // Reconstruct stomped dirs
                    if (dirs && dirs.length && _correlated) { //file is in TOC Dir entry
                        var nom = dirs[f.num];
                        if (nom && nom.flags & 0x02) { //it's a valid flag (42 or 03 for DOS 2x) file but corrupted
                            name83 = nom.name83; //use the TOC Dir enry name instead of the DAT name
                            name = nom.name;
                            ext3 = nom.ext;
                            i--; //cancel the .DAT name number
                        }
                    }
                    var tdir = { numidf: "=>", sectors: f.fsectors, valid: 2, start: f.sect, total: f.total, fsize: f.bytes, name: name, name83: name83, ext: ext3, flags: 0x00, recovered: true, fnum: f.num };
                    dirs.push(tdir);
                    console.log("scan_files() =>Info: file '" + name + "'' recovered, file id #" + f.num + ", start at " + f.sect + ", length is " + f.bytes + " bytes, " + f.total + " sectors" );
                }
            });
        }

        read_file(f) { //read_file() is called in load_data() and returns an array of byte data of the read file
            //(PVB MOD) simplification of read_file(), we assume reading only a valid file, checking of sector chaining is done in one_dir()
            if (this.sparta)
                return this.sparta.read_file(f.start);
            if (this.dosxe)
                return this.dosxe.read_file(f.clusters, f.fsize);
            var data = [];
            var d = this.d;
            //(PVB ADD) read the DOS 3 files & KBoot; fsize is already compute in one_dir()
            if (this.dosType == 3 || this.dosType == 10) { //for DOS3, and also raw KBoot read
                f.sectors.forEach(s => {
                    var src = this.read_sector((this.dosType == 3 ? s.sector : s));
                    for (var i = 0; i < src.length; i++)
                        data.push(src[i]);
                });
                data.splice(f.fsize); //clipped the size of the file to the f.fsize
            }
            //(PVB END OF ADD)
            else { //for DOS1, DOS2X and Mydos
                f.sectors.forEach(s => {
                    var src = this.read_sector(s.sector)
                    for (var i = 0; i < s.slen; i++)
                        data.push(src[i]);
                });
                //f.size already set with DOS2x thanks to scan_files() function, but not for DOS 1...
                f.fsize = data.length; //(PVB ADD) so anyway, force fsize to the read data length from the dir entry
            }
            return new Uint8Array(data);
        }
        //(PVB ADD) the identify_dos() function //(TODO) try to optimize code to avoid repeating the same code & add other DOS support
        identify_dos() {//identify_dos() is called by the ATR constructor in order to identify the disk image DOS system and set atr.dosType
            //let's assume that return value is (-1) if no DOS found; (0) for Sparta;
            // (1) for DOS1; (2) for DOS2.0; (2.5) for DOS2.5; (3) for DOS3; (4) for DOS4; (5) for DOS XE
            // (6) for MyDOS (DOS2x compatible); (7) for MyDOS with flag 03 (not DOS2x compatible); (8) for MyDOS4.5x for more than 1440 sector;
            // (9) [futur myDOS ?] ; (10) for KBOOT; (11) for Multiboot disk //WIP//
            if (this.sparta)
                return 0;
            //function checkZeroIn() called to check if TOC contains $00, from byte index s to e (e not included)
            function checkZeroIn(vtoc, s, e){
                var x = 0;
                for (var i = s; i < e; i++) {
                    x += vtoc[i];
                }
                return (x == 0); //return true if there are zero from s to (e-1)
            }
            var idos = -1; //default is "unknown dos"
            this.totalBlock = 0; //Number of sector after DOS disk formatting
            this.freeBlock = 0;  //Number of free sector in DOS disk
            this.vtoc2_sect = 0;
            this.vtoc1_sect = 360;
            this.dir_sector = 361;
            this.file_start = 4; //first data sector on DOS disk (after boot)
            var str = "";
            //====== Check for DOS XE... ======//
            //BOOT SECTOR information is used to detect DOS XE: use string code for the density (or disk type) used at $710
            for (var i = 0x10 ; i < 0x16; i++) {
                if (this.d[16 + i]) str += String.fromCharCode(this.d[16 + i]);
            }
            var bc = (this.d[16] === 0x58); //"X" boot flag ?
            if (bc || str == "XF551" || str == "AT810" || str == "AT1050" || str == "SSDD") { //check DOS XE string code
                this.dosXEType = str;
                //The allocation unit is a "cluster" of 256 bytes, i.e. two physical sectors in SD and ED, and one sector in DD.
                this.blockSize = 256;
                this.blockSect = (this.size == _DD || this.size == _DS ) ? 1 : 2;
                this.vtoc1_sect = 4 * this.blockSect;  //VTOC starts at cluster 4 (physical sector 4 in DD , or sectors 8-9 in SD and ED 
                this.dir_sector = this.d[16 + 0x1D] * this.blockSect; //directory starts at the cluster number read in $71D of the boot 
                this.totalBlock = le16(this.d, 16 + 0x18);
                this.freeBlock = le16(this.d, 16 + 0x1A);
                if (!bc) this.dirErrorStr = " >'X' byte signature is missing in the DOS XE boot sector";
                this.vtoc_off = this.sector_offset(this.vtoc1_sect); //data for the DosXE constructor,
                idos = 5;
                console.log(" identify_dos() => has found a DOS XE disk image system");
                return idos; //DOS XE is 5
            }
            //====== Check for MyDOS...======// 
            var vtocSect = this.read_sector(360); //read VTOC and it's data at default sector 360 ($168) for most every DOS
            var t = le16(vtocSect, 1); //read total formated sector
            var s = le16(vtocSect, 3); //read remainning free sector
            var sc = this.sector_count;
            str = "";   
            bc = (this.d[16] + this.d[17] + this.d[18] + this.d[19]) === 10; //standard 1st 4 bytes of DOS boot contains '$00 $03 $00 $07'
            var vtocb = vtocSect[0]; //first byte of VTOC is the DOS signature = VTOC's Byte = vtocb
            var vts = (vtocSect[0x37] === 0) && checkZeroIn(vtocSect, 6, 10); //DOS or MyDOS: Byte $37 of VTOC is zero and bytes 6 to 9 of the VTOC are zero
            //VTOC must start with $02, $03 or higher byte, contain $00 at offset $37, and has a comprehensive total-of-sector value
            if (t == 0x2C4 && vtocb == 2 && vts) { //VTOC flag must be 02 for MyDOS compatible with DOS2x, in SD or DD only
                if (sc == 1040) str += " >720-sector MyDOS disk on a 1040-sector disk";
                idos = 6; //MyDOS SD or DD disks ($2C4 formated sectors) compatible with DOS2x
            }
            else if ((t == 0x403 || t == 0x2C4) && vtocb == 3 && vts) {
                // vtocb is 03, for ED disk ($403 formated sectors) OR for SD/DD disks that are not compatible with DOS2x (with sub-directories for instance)
                if (t == 0x403 && sc == 720) str += " >1040-sector MyDOS disk has been clipped into a 720-sector disk";
                idos = 7; //MyDOS SD, DD or ED disks not compatible with DOS2x
            }
            else if (t == 0x594 && vtocb == 3 && vts) {
                if (sc < 1440) str += " >1440-sector MyDOS disk has been clipped into a smaller sector disk";
                idos = 7; //MyDOS DSDD disks not compatible with DOS2x
            }
            else if (t > 0x594 && s <= t && vtocb > 3 && vts) { //Other MyDOS disks
                if (sc <= t) str += " >MyDOS4.5x disk has been clipped into a smaller sector disk";
                idos = 8; //MyDOS4.5x for disks greater than 1440 sectors, with 128B/sector or 256B/sector
            }
            if (idos >= 6) { //MyDOS exit
                if (this.bootFlag != 0x4D) str += (str ? "\n;" : "") + " >'M' byte signature is missing in the MyDOS boot sector"; //info
                this.totalBlock = t;
                this.freeBlock = s;
                if (str) this.dirErrorStr = str;
                //compute lowest sector number of the VTOC, under 360 ($168) that is the main VTOC sector
                if (this.sector_size == 256 && vtocb > 3) this.vtoc2_sect = 360 - vtocb + 3; //formula to be validated
                if (this.sector_size == 128 && vtocb > 2) this.vtoc2_sect = 360 - (vtocb * 2) + 5; //formula to be validated
                console.log(" identify_dos() => has found a MyDOS disk image system");
                return idos; //MyDOS is 6, 7 or 8
            }
            //====== Check for DOS 1& DOS 2x... ======//
             //(PVB TODO) better DOS2x detection, support DOS loaders (with special boot), and valid DOS by loading the first one_dir ??
             var bintadd = le16(this.d, 16+4); //boot $704: DOS initialization address; $1540 for DOS2x
             var sasa = le16(this.d, 16+12);   //boot $70C: Buffer allocation address for drives and files, $1A7C for DOS2, $19CC for DOS2.5
             //VTOC's Byte = vtocb must be 01 for DOS1 ans 02 for DOS2x, contain $00 at offset $37, and has a comprehensive total-of-sector value
             if (vtocb == 0x01 && t == 0x2C5 && vts) { //let's be strict for DOS1
                if (sc == 1040) str += " >720-sector DOS 1.0 disk on a 1040-sector ED disk";
                this.file_start = 2;
                idos = 1; //DOS 1 (SD only)
            }
            else if (vtocb == 0x02 && (t == 0x2BF || t == 0x2C3) && vts) { //seems to be a DOS2.O disk, so check vtocb, bc & sasa
                if (sc == 1040) str += " >720-sector DOS 2.0 disk on a 1040-sector ED disk";
                if (sc == 720 && bc && bintadd == 0x1540 && sasa == 0x19CC) idos = 2.5; //DOS2.5 on a 720-sector (SD) disk
                else if (bc && bintadd == 0x1540 && sasa == 0x1A7C) idos = 2; //DOS2.0S (SD) or DOS2.0D (DD & SD)
                else { //note: t == $2BF formated sectors have been found on some modified DOS2 loader disks ==> TODO: check this
                    str += (str ? "\n;" : "") + " INFO: This is not a genuine SD DOS 2.0S disk or DD DOS 2.0D disk";
                    idos = 2; //DOS2.0 based disk
                }
            }
            else if (vtocb == 0x02 && (t == 0x3F2 || t == 0x3F3 || t == 0x3E9) && vts) { //seems to be a DOS2.5 disk
                //note: $3F3 and $3E9 formated sectors have been found on some modified DOS2.5 loader disks ==> TODO: check this
                if (sc == 1040) {
                    s = s + le16(this.d, (this.sector_offset(1024) + 0x7A)); //compute free sector number
                    this.vtoc2_sect = 1024;
                    if (is_zero(this.d, this.sector_offset(1024), this.sector_size))
                        str +=  (str ? "\n" : "") + " >1040-sector ED disk VTOC2 is erased, disk may be corrupted";
                }
                else if (sc == 720) {
                    str = " >1040-sector DOS 2.5 disk has been clipped into a 720-sector disk";
                    str += "\n; >VTOC2 is missing, free blocks value is wrong";
                }
                //else this is a DOS2.5 disk on unknown disk image? should not appears, so it's a boot program disk
                if (!(bc && bintadd == 0x1540 && sasa == 0x19CC && t == 0x3F2 && sc == 1040))
                    str += (str ? "\n;" : "") + " INFO: This is not a genuine 1040-sector ED DOS 2.5 disk";
                idos = 2.5; //DOS2.5 for ED enhanced disk and SD (but not for DD disk)
            }
            if (idos > 0) {
                this.totalBlock = t;
                this.freeBlock = s;
                if (!checkZeroIn(vtocSect, 101, 128))
                    str += (str ? "\n" : "") + " >Error in DOS 2x TOC that must end with $00 value bytes"; //info
                if (str) this.dirErrorStr = str;
                console.log(" identify_dos() => has found a DOS1/2/2x disk image system");
                return idos; //DOS 1 is 1, DOS 2 is 2, DOS2.5 is 2.5
            }
            //====== Check for DOS 3... ======//
            //Directory must start with 14x $00 value bytes, contain $A5 signature, and has the total-of-block byte
            this.vtoc1_sect = 24;
            this.vtoc2_sect = 0;
            this.dir_sector = 16;
            vtocSect = this.read_sector(16);
            t = vtocSect[0x0E];
            if (checkZeroIn(vtocSect, 0, 14) && (vtocSect[0x0F] == 0xA5) && (t == 0x57 || t == 0x7F)) {
                if (t == 0x57 && sc == 1040)
                    str += " >720-sector DOS3 disk on a 1040-sector disk";
                if (t == 0x7F && sc == 720)
                    str += " >1040-sector DOS3 disk has been clipped into a 720-sector disk";
                this.totalBlock = t;
                vtocSect = this.read_sector(24);
                this.freeBlock = vtocSect.filter(arrayElement => arrayElement == 0xFE).length;
                if (str) this.dirErrorStr = str;
                this.file_start = 25;
                this.blockSize = 1024; //8x128=1024 bytes ($400) (DOS 3 is SD and ED only)
                this.blockSect = 8;
                idos = 3;
                console.log(" identify_dos() => has found a DOS 3 disk image system");
                return idos; //DOS 3 is 3
            }
            //====== Check for DOS 4... ======//
            //Directory must start with 14x $00 value bytes, contain $A5 signature, and has the total-of-block byte
            this.vtoc2_sect = 0;
            vts = (this.size == _DS) ? 0x43 : 0x52; //signature is 0x43 for double sided disk
            vtocSect = this.read_sector(360);
            vtocb = ((vtocSect[0] + vtocSect[2]) == vts) && checkZeroIn(vtocSect, 4, 8);
            var vtocSectED = this.read_sector(515);
            bc = ((vtocSectED[0] + vtocSectED[2]) == vts) && checkZeroIn(vtocSectED, 4, 8);
            if (vtocb || bc) {
                idos = 4;
                if (vtocb) { //case of SD, DD and DS(DD) disks
                    if (this.size == _ED) str += " >720-sector DOS4 disk on a 1040-sector disk!";
                    this.totalBlock = (this.size == _DS) ? 248 : (this.size == _DD) ? 237 : 118; //248 for DS, 237 for DD, 118 for SD
                    this.dir_sector = (this.size == _DD) ? 355 : 349; //in DD disk, AU#118-119 = sect. 355-360; in SD & DS disk, AU#58-59 = sect. 349 to 360
                    this.vtoc1_sect = 360;
                    this.freeBlock = vtocSect[3];
                }
                if (bc) { //case of ED disk
                    if (this.size == _SD) str += " >1040-sector DOS4 disk has been clipped into a 720-sector disk!";
                    this.totalBlock = 171;
                    this.dir_sector = 505; //505-514, AU#84-85
                    this.vtoc1_sect = 515; //sector 515 and 516 ! 
                    this.freeBlock = vtocSectED[3];
                }
                //6x256=1536 bytes in DSDD ($600); 6x128=768 bytes in SD and ED ($300); 3x256=768 bytes in DD ($300)
                this.blockSize = (this.size == _DS) ? 1536 : 768;
                this.blockSect = (this.size == _DD) ? 3 : 6;
                this.file_start = 1; //WIPDOS// to be confirmed that a DOS4 file can start in the boot sectors !!
                if (str) this.dirErrorStr = str;
                console.log(" identify_dos() => has found a DOS 4 disk image system");
                return idos; //DOS 4 is 4
            }
            //====== Check for KBoot ... ======//
            const kboot = [0, 3, 0, 7, 0x14, 7, 0xA0, 0, 0xA9, 0x6B, 0x91, 0x58, 0x20, 0xD9, 7]; //some KBoot signature
            var isKBoot = true;
            var j = 0;
            for (var i = 0 ; i < 0x1D; i++) {
                if (i == 6) i = 0x14;
                isKBoot = (this.d[i+16] == kboot[j++]) && isKBoot;
            }
            if (isKBoot) {
                this.totalBlock = le24(this.d, 16 + 9);
                this.file_start = 4;
                idos = 10;
                console.log(" identify_dos() => has found a KBOOT disk image system");
                return idos; //KBOOT is 10
            }
            //======= NO KNOWN DOS FOUND ======//
            this.dirErrorStr = " >VTOC error: unknown DOS system or disk image file has a boot loader!";
            this.vtoc1_sect = 0;
            this.dir_sector = 0;
            console.log(" identify_dos() => has not found any known DOS disk image system!");
            return idos; //no DOS found, idos is -1
        }
        //(PVB END OF ADD)
    }
    
    //===================================================================================================
    //(PVB ADD) the make_OBJ() function
    function make_OBJ(d, badd) { //make an OBJ file with Extracted data, so add headers and segments
        //'d' are data; 'badd' is the load address of data
        var szd = d.length;
        var tlen = szd + 2 + 4 + 6; //futur size is data size + header + segement + segement for RUNADD vector
        var dz = new Uint8Array(tlen);
        dz.set([0xFF, 0xFF, badd & 0xFF, badd >> 8 & 0xFF, (badd+szd-1) & 0xFF, (badd+szd-1) >> 8 & 0xFF]); //make header & segment for data
        dz.set(d.subarray(0, d.length), 6); //put data after
        dz.set([0xE0, 0x02, 0xE1, 0x02, badd+6 & 0xFF, badd+6 >> 8 & 0xFF], d.length + 6); //make segment for RUNADD vector
        return dz;
    }
    //(PVB ADD) the make_ATR() function
    function make_ATR(source_data, badd, ntc) { //make an ATR file with Extracted data, ntc = need to convert into boot 
        //'d' are data; 'badd' is the load address of data
        sect_size = 128; //obviously, destination disk of extract will be max $10000 bytes, so fits into a 720-sector disk of single density
        var szd = source_data.length;
        if (ntc) szd += 6; //add the 6 bytes for boot bytes to the data length
        var tlen = 720*128; // size of targetted disk
        var dz = new Uint8Array(tlen); //create a new tlength bytes disk
        //compute number of sectors according to source_data length
        var m = szd - 1; //index of data starts from "0" index
        var nbs = 1; //number of sectors to load for the boot
        nbs += (m >> 7) & 0xFF; //compute number of sector (size + 1) / $80
        console.log("make_ATR() ==> has computed $" + hdx(nbs) + " boot sectors");
        if (ntc) { //add the boot bytes for conversion
            dz.set([0, nbs, badd & 0xFF, badd >> 8 & 0xFF, 0x00, 0x00]); //put a "standard" boot header 3 sectors at $1000
            dz.set(source_data.subarray(0, m + 1), 6); //copie the rest of data
        }
        else {
            dz.set(source_data);
            dz[1] = nbs & 0xFF; //adjust number of boot sector
        }
        dz = XFD.to_atr(dz); //add the ATR header
        return dz;
    }
   
    //===================================================================================================
    //(PVB ADD) DCM File management by the extract_dcm() function
    // based upon https://www.atarimax.com/freenet/freenet_material/5.8-BitComputersSupportArea/7.TechnicalResourceCenter/showarticle.php?62
    // diskcomm https://atari.fox-1.nl/atari-400-800-xl-xe/400-800-xl-xe-tools/diskcomm-3-2-and-source-code/ and Altirra DCM source code
    function extract_dcm(srcDCM) {
        var sectorBuffer = new Uint8Array(256); //temp sector buffer
        var DCMSectorSize = 128; //number of bytes per sector on the disk image // by default
        var dSize = 0; // disk size
        var bfirst = true;
        var idx = 0; //index in the DCM file data
        var DCMtoATRdisk = [];
        var BArcType;
        var BPassInfo;
        var sectorNbr;
        function readSource(n, ofst) {
            while (n > 0) {
                sectorBuffer[ofst++] = srcDCM[idx++];
                n--;
            }
        }
        function swapBuffer(n) {
            let j = n;
            for (var i=0; i < j; i++) {
                let t = sectorBuffer[i];
                sectorBuffer[i] = sectorBuffer[j];
                sectorBuffer[j--] = t;
            }
        }
        while (true) {
            BArcType = srcDCM[idx++];
            if (BArcType != 0xF9 && BArcType != 0xFA) return false;
		    BPassInfo = srcDCM[idx++];
            //BPassInfo= Pass number: A sequence number assigned to each pass.  Normally ranging from 1 to 31 decimal.
            //This might roll over to zero after 31. End of pass: The value hex 45.
            console.log(">>> extract_dcm() >>Entering pass number #" + (BPassInfo & 0x1F) + "...");
		    let BSctrLow = srcDCM[idx++];
		    let BSctrHigh = srcDCM[idx++];
		    let sSize = (BPassInfo & 0x60) == 0x20 ? 256 : 128;
		    sectorNbr = BSctrHigh *256 + BSctrLow;
            switch(BPassInfo & 0x60) {
			    case 0x00:
                    dSize = _SD; break; //Disk number of sector = 720; diskType = kATDCMDiskType_SD, 128B/sect;
			    case 0x40:
                    dSize = _ED; break; //Disk number of sector = 1040; diskType = kATDCMDiskType_ED, 128B/sect;
			    case 0x20:
                    dSize = _DD; break; //Disk number of sector = 720; diskType = kATDCMDiskType_DD, 256B/sect;
            }
            DCMSectorSize = sSize;
            if (bfirst) {
                DCMtoATRdisk = new Uint8Array(dSize);
                DCMtoATRdisk.fill(0);
                console.log(">>> extract_dcm() DCM to ATR disk of " + dSize + " bytes created with density " + DCMSectorSize);
                bfirst = false;
            }
            while (true) {
                let contentType = srcDCM[idx++];
                if ((contentType & 0x7F) == 0x45)
                    break;
                // This check has to be after the 0x45 token check, as it's legal to have a sector number of 0 before it.
                if (!sectorNbr) {
                    console.log(">>> extract_dcm() !ERROR: Null sector number encountered!!");
                    return false;
                }
                else
                    console.log(">>> extract_dcm() decodes sector $" + hdx(sectorNbr) + " with command $" + hdx(contentType) + "...");
                let c;
                //Compression type: One of the following hex values: 41, 42, 43, 44, 46 or 47.
                switch(contentType & 0x7F) {
                    case 0x41: //65 //modify begin
                        c = srcDCM[idx++];
                        readSource(c + 1, 0);
                        swapBuffer(c);
                        break;
                    case 0x42: //66 //128 byte DOS sector
                        readSource(5, 123);
                        sectorBuffer.fill(sectorBuffer[123], 0, 123);
                        break;
                    case 0x43: //67 //compressed sector
                        let pos = 0;
                        let offset;
                        let bcompressed = false;
                        let bfirst = true;
                        while(pos < DCMSectorSize) {
                            offset = srcDCM[idx++];
                            // offset cannot exceed sectorSize, ever.
                            if (offset > DCMSectorSize) {
                                console.log(">>> extract_dcm() !ERROR: Offset " + offset + " greater than sectorsize!!");
                                return false;
                            }
                            // offset cannot go backwards, except in two specific cases:
                            //  - offset is 0, pos is 0 (null span)
                            //  - offset is 0, sectorSize is 256 (fill to end of DD sector)
                            if (offset < pos && (offset || (pos && DCMSectorSize != 256))) {
                                console.log(">>> extract_dcm() !ERROR: Backwards offset " + offset + " encountered!!");
                                return false
                            }
                            let spanLen = (offset || bfirst ? offset : DCMSectorSize) - pos;
                            if (bcompressed) {
                                c = srcDCM[idx++];
                                sectorBuffer.fill(c, pos, pos + spanLen);
                            }
                            else if (spanLen) {
                                readSource(spanLen, pos);
                            }
                            pos += spanLen;
                            bcompressed = !bcompressed;
                            bfirst = false;
                        }
                        break;
                    case 0x44:		// 68 // modify end
                        c = srcDCM[idx++];
                        if (c >= DCMsectorSize) {
                            console.log(">>> extract_dcm() !ERROR: at code 0x44, read byte " + c + " is greater than sectorsize!!");
                            return false;
                        }
                        readSource(DCMsectorSize - c, c);
                        break;
                    case 0x46:		// 70 // repeat last sector
                        break;
                    case 0x47:		// 71 //uncompressed sector
                        readSource(DCMSectorSize, 0);
                        break;
                    default:
                        console.log(">>> extract_dcm() !ERROR: byte $" + hdx(contentType) + " is not a supported DCM command!!");
                        return false;
                    }
                //create entry for sector
                //storeBuffer(sctr_nbr) in the disk image
                let sof = sectorIndex(sectorNbr, DCMSectorSize);
                let ssz = sectorNbr < 4 ? 128 : DCMSectorSize;
                for (var i = 0; i < ssz; i++ ) {
                    DCMtoATRdisk[sof + i] = sectorBuffer[i];
                }
                // increment sector number if sequential flag is set, else read new sector number
                if (contentType & 0x80) {
                    ++sectorNbr
                }
                else {
                    BSctrLow= srcDCM[idx++];
                    BSctrHigh= srcDCM[idx++];
                    sectorNbr = BSctrHigh * 256 + BSctrLow;
                }
            }
            //exit main loop
            if (BPassInfo & 0x80) break; //exit main loop
        }
        console.log(">>> extract_dcm() >>Process over, exiting!");
        return DCMtoATRdisk;
    }
    //(PVB end of ADD)

    //===================================================================================================
    // arc files management
    function dearc_3(srcd, srclen, dstlen)    // RLE - after altirra
    {
        var dst = 0;
        var src = 0;
        var dstd = new Uint8Array(dstlen);

        let last = 0;
        while (dstlen) {
            let c = srcd[src++];
            if (c == 0x90) {
                if (!srclen--)
                    return null;
                let d = srcd[src++];
                if (d == 0) {
                    prevoutput = last;
                    if (!dstlen--)
                        return null;
                    dstd[dst++] = 0x90;
                } else {
                    let count = d - 1;
                    if (dstlen < count)
                        return null;
                    dstlen -= count;
                    while (count--)
                        dstd[dst++] = last;
                }
            } else {
                last = c;
                if (!dstlen--)
                    return null;
                dstd[dst++] = c;
            }
        }
        return dstd;
    }

    function dearc_8(srcd, srclen, dstlen)    // after altirra
    {
        var dst = 0;
        var src = 0;
        var n = 256;
        var last = 0;
        var byte2 = false;
        var bits = 9;
        var accum = 0;
        var accumbits = 0;
        var lastCode = 0;
        var codesRead = 0;
        var dstd = new Uint8Array(dstlen);

        var prev_link = new Int16Array(4096);
        var first_char = new Uint8Array(4096);
        var last_char = new Uint8Array(4096);
        var tmp = new Uint8Array(4096);
        for (var i = 0; i < 256; i++) {
            prev_link[i] = -1;
            first_char[i] = last_char[i] = i;
        }

        if (srcd[src++] != 0xC) // longest code length?
            return null;

        while (dstlen) {
            let code = 0;
            for (let i = 0; i < bits; ++i) {
                if (!accumbits) {
                    if (!srclen--)
                        return null;
                    accum = srcd[src++];
                    accumbits = 8;
                }

                if (accum & 1)
                    code += (1 << bits);

                accum >>= 1;
                --accumbits;
                code >>= 1;
            }

            ++codesRead;
            if (code > n)
                return null;

            if (code == 256) {
                let align = ((-codesRead & 7) * bits) >> 3;
                if (srclen < align)
                    return null;
                srclen -= align;
                src += align;

                // reset code table
                n = 256;
                bits = 9;
                lastCode = 0;
                accumbits = 0;
                accum = 0;
                codesRead = 0;
                continue;
            }

            if (n < 4096) {
                first_char[n] = first_char[lastCode];
                if (code == n)
                    last_char[n] = first_char[n];
                else
                    last_char[n] = first_char[code];
                prev_link[n] = lastCode;

                ++n;
                if (n >= (1 << bits) && bits < 12)
                    ++bits;
            }

            var tmpstart = 4096;
            for (var link = code; link >= 0; link = prev_link[link])
                tmp[--tmpstart] = last_char[link];

            while (tmpstart != 4096) {
                let c = tmp[tmpstart++]
                if (byte2) {
                    if (c == 0) {
                        last = 0x90;
                        if (!dstlen--)
                            return null;
                        dstd[dst++] = 0x90;
                    } else {
                        let count = c - 1;
                        if (dstlen < count)
                            return null;
                        dstlen -= count;
                        while (count--)
                            dstd[dst++] = last;
                    }
                    byte2 = false;
                } else {
                    if (c == 0x90)
                        byte2 = true;
                    else {
                        last = c;
                        if (!dstlen--)
                            return false;
                        dstd[dst++] = c;
                    }
                }
            }
            lastCode = code;
        }
        return dstd;
    }

    function arc_extract(id, pos) {
        var file = get_file(id);
        function extract(pos) {
            var f = file.arc[pos];
            var d = file.data.slice(pos, pos + f.compressed_size);
            switch (f.method) {
                case 3: d = dearc_3(d, f.compressed_size, f.original_size); break;
                case 8: d = dearc_8(d, f.compressed_size, f.original_size); break;
            }
            load_one(f.name, get_ext(f.name, d, false, false), d, "", "isFile"); //(PVB MOD) add arguments to load_one()
        }
        if (pos == -1)
            file.arc.forEach(a => extract(a.pos));
        else
            extract(pos);
        refresh_containers();
    }

    function show_arc(f) {
        var d = f.data;
        var files = [];
        var txt = [];
        var sel = [];
        var i;

        var _methods = [
            "End of archive marker",
            "unpacked (obsolete) - ARC 1.0 ?",
            "unpacked - ARC 3.1",
            "packed (RLE encoding)",
            "squeezed (after packing)",
            "crunched (obsolete) - ARC 4.0",
            "crunched (after packing) (obsolete) - ARC 4.1",
            "crunched (after packing, using faster hash algorithm) - ARC 4.6",
            "crunched (after packing, using dynamic LZW variations) - ARC 5.0",
            "Squashed c/o Phil Katz (no packing) (var. on crunching)"];

        var i = 0;
        f.arc = [];
        var count = 0;
        while (i < d.length) {
            if (d[i + 0] != 0x1A)
                break;
            var method = d[i + 1];
            if (!method)
                break;  // end of archive is 0x1A 0x00

            var name = '';
            for (var j = 0; d[i + 2 + j] && j < 12; j++)
                name += String.fromCharCode(d[i + 2 + j]);

            var file = {
                method: method,
                name: name,
                compressed_size: le32(d, i + 15),
                date: le32(d, i + 19),
                crc: le16(d, i + 23),
                original_size: le32(d, i + 25),
                pos: i + 29
            }
            f.arc[file.pos] = file;
            //(PVB MOD) add the display of html hyperlinks
            sel.push(`; <a href=#${file.name}>${file.name}</a><button style="float:right" type="button" onclick='arc_extract(${f.id},${file.pos})'>Extract</button>`);
            sel.push(`; ${file.original_size} bytes (${file.compressed_size} compressed)`);
            sel.push("");

            txt.push('; --------------------------------------------------------------------------------'); //(PVB MOD) add a separation line)
            txt.push('; <span id="'+ file.name + '">' + file.name + " raw data: </span>");
            txt.push('; ' + _methods[method] + ', ' + file.compressed_size + ' -> ' + file.original_size);
            txt.push('; <a href="#backtoarc">(back)</a>');
            txt.push(''); 
            txt.push(hex_dump(d, i + 29, file.compressed_size, 4));
            txt.push('');

            i += 29 + file.compressed_size;
            count++;
        }
        sel.unshift(`; <span id="backtoarc">${f.name} archive contains ${count} files: </span><button type="button" style="float:right" onclick='arc_extract(${f.id},-1)'>Extract All</button>\n\n`);
        sel.push("");

        render_file(f);
        _h("#show", sel.join("\n") + txt.join("\n"));
    }
    
    //===================================================================================================
    //(PVB ADD) ROM Image management and ROM dump display
    function show_rom(f) {
        var r = f.rom;
        var d = r.romData; //ROM with the CART header
        var bankMap = r.romMap;
        var sc = d.length - 16;
        var nb = []; //temp Array
        var txt = []; //string of text to display
        var romBank = []; //restructured banks of the rom
        var aname = []; //bytes in the A5200 ROM for the name and date, that will be transformed into string
        var str = ""; //tmp
        var i = 16;  //memory pointer
        var n = 0  //number of banks with same characteristic that are switched
        var k = 0; //number of bank * 2
        var l = 0; //bank counter
        //initialization of a5200eq and _bShowA5200 Equates is now in load() and apply_rommap(), that are called just before show_rom())
        r.rom_flag = 0xFF; //set default
        r.rom_init = 0; //set default
        while (n < bankMap.length) { //for every map
            var m = bankMap[n+2]; // number of bank
            for (var j = 0; j < m; j++) { //for each identical bank
                nb[k] = bankMap[n] * 0x100; //len of memory
                nb[k+1] = bankMap[n+1] * 0x100; //start address
                nb[k+2] = nb[k+1] + nb[k] - 1; //end address
                romBank.push({start: nb[k+1], end: nb[k+2], len: nb[k], offset: i}); 
                if (((r.romType == "21" || r.romType == "59" || r.romType == "53") && (nb[k+2] == 0x9FFF)) //Right Slot Cartridge or Low bank 8 KB Cartridge
                        || (nb[k+2] == 0xBFFF)) { //Normal Slot Cartridge
                    r.rom_flag = d[r.romData.length - 3]; //CARTFG => Cartridge ROM, normaly $04; For A5200: char date or $FF (see below)
                    r.rom_init = le16(d, r.romData.length - 2);  //CARTAD => initialization of start vector, same for A5200
                    if (r.romMachine == "5200") { //check if it is an A5200 Cartridge
                        //for the A5200 CART: $BFE8-$BFFB are the 20 char of title name; $BFFC-$BFFD for the (c) date
                        //see https://www.atarimax.com/freenet/freenet_material/5.8-BitComputersSupportArea/7.TechnicalResourceCenter/showarticle.php?51
                        aname = d.slice(r.romData.length - 24, r.romData.length - 2);
                        r.rom_coldstart = 0; // no CARTCS for A5200 cartridges
                    }
                    else {
                        r.rom_coldstart = le16(d, r.romData.length - 6); //CARTCS => cold start for 800/XL/XE Cartridges
                    }
                }
                if (nb[k+2] == 0xFFFF) r.rom_init = 0xFC00; // for the 2K A5200 ROM
                l++; //increment bank coiunter
                i += nb[k]; //adjust the memory pointer
                k += 3; //number of bank * 2 
            }
            n+=3;
        }
        r.romBankMap  = romBank;
        //r.romBankList = nb; //(PVB TODO) check if this is relevant to save the romBankList nb into the ROM array r
        if (r.restructured)
            txt.push(`<span style='color:red;'>; Displayed ROM image file was restructured into full 2KB multiple size data for display</span>`);
        if (!bankMap || bankMap.length == 0)
            txt.push(`; <b>ROM Image is ${r.romKBSize}KB ($${hdx(sc)} bytes) in total - No memory Mapping available - Please test above</b>`);
        else {
            txt.push(`; <b>ROM Image is ${r.romKBSize}KB ($${hdx(sc)} bytes) in total in ${l} banks of memory</b>`);
            if (r.romMachine == "5200") {
                str = "Atari 5200 ROM ";
                txt.push(`; ${str}<b>Initialisation Start Vector is $${hex(r.rom_init,4)}</b>`);
                //(PVB COM) Extracting A5200 rom name and date...
                let j = aname.length;
                while (j--) { //convert the char display
                    if (aname[j] > 0x7F) //(PVB TODO / experiment => check how the char above $7F are displayed)
                        aname[j] = 0;
                    if (aname[j] < 0x3F)
                        aname[j] += 0x20;
                    else 
                        aname[j] -= 0x20;
                }
                if (r.rom_flag != 0xFF) {
                    aname = toAscii(aname, 0, aname.length); //(PVB) for A5200 rom displayed name and date
                    txt.push(`; ${str}displayed name at OS boot is "` + aname.substring(0, 20) + ` (c) ATARI 19` + aname.substring(20, 22) + `"`);
                }
                else
                    txt.push(`; ${str}has no displayed name at OS boot, CARTFG = 0xFF`);
            }
            else {
                str = "Atari 800/XL/XE ROM ";
                txt.push(`; ${str}<b>Initialisation Vector CARTAD is $${hex(r.rom_init,4)}</b>`);
                txt.push(`; ${str}<b>Cold Start Vector CARTCS is $${hex(r.rom_coldstart,4)}</b>`);
                txt.push(`; ${str}<b>Cartridge Flag CARTFG is $${hex(r.rom_flag,2)}</b>`);
            }
        }
        l = 0;
        txt.push('\n; <b>ROM Bank Map:</b>');
        for (var j = 0; j < nb.length; j+=3) {
            txt.push(`; <a id="BKTOBANK${l}" href="#FWTOBANK${l}">Bank nbr ${l}</a>; size ${(nb[j]/1024)}KB; at memory $${hex(nb[j+1],4)}:${hex(nb[j+2],4)}`);
            l++;
        };
        l = 0;
        r.romBankMap.forEach(b => {
            txt.push(`\n` + _hr);
            str = `<span id="FWTOBANK`+ l + `"><strong>; HEX DUMP of Bank nbr ` + l + `; size: ` + b.len + ` ($` + hdx(b.len) + `) bytes = ` + (b.len/1024) + `KB`;
            str += `</strong> <a href="#BKTOBANK` + l + `">(back)</a></span><em class="bankcode" onclick="show_bank(` + l + `)">Toggle Disassembly/HexDump View</em>`;
            txt.push(str);
            txt.push(`; Bank set to memory $` + hex(b.start,4) + ` : $` + hex(b.end,4));
            str = `;`;
            if (l > 0)
                str += ` <a href="#FWTOBANK` + (l-1) + `">(previous)</a> `;
            if (l < r.romBankMap.length - 1 )
                str += ` <a href="#FWTOBANK` + (l+1) + `">(next)</a> `;
            txt.push(str + "\n" + _hr);
            txt.push(`<div id="BANK_${l}" style="display:block">` + `\n` + hex_dump(d, b.offset, b.len, (b.start + l)) + `</div>`);
            l++;
            });

        render_file(f);
        _h("#show", txt.join("\n"));
    }
    //(PVB END OF ADD)

    //===================================================================================================
    // dump atr raw data
    //(PVB MOD) improvement of the show_atr() function
    //handles DOS3, DOS4, DOS XE and KBOOT, add ATR disk characteristics, mod display of boot sector, add DOS directory, mod display of sectors & blocks...
    function show_atr(f, rawmode) {
        //(PVB COM) show the ATR is_disk : 'ATR', ATX, PRO & XFD
        //rawmode is true with DSK file where the sectors are just listed
        var atr = f.atr;
        var d = atr.d; //d includes the 16 bytes of the ATR header !!
        var txt = [];
        var sparta = atr.sparta; //(PVB MOD) declaration here

        // just the raw sectors
        //(PVB COM) if rawmode => atr.sector_size is used for the size if sector, d is the data memory buffer to display,
        // the dump text is put in the txt variable, and display on the right after render_file (top) et #show (bottom with txt)
        if (rawmode) {
            var n = 0;
            for (; ;) {
                var ssize = n < 3 ? 128 : atr.sector_size;
                var offset = atr.sector_offset(n + 1);
                if (offset >= (atr.size + 16))
                    break;
                var zero = is_zero(d, offset, ssize);
                // (PVB MOD) add the hexa number sector, and count sectors from 1 and not zero (there is no sector zero for the atari SIO)
                var sect = n + 1;
                txt.push("; Sector " + hex(sect, 3) + " (" + sect + ")" + (zero ? " (" + ssize + " zeros)" : ""));
                //(previously) txt.push("; Sector " + n + (zero ? " (" + size + " zeros)":""));
                if (!zero) // (PVB COM) if the sector is not empty then we display the dump
                    txt.push(hex_dump(d, offset, ssize, 4));
                txt.push("");
                n++;
            }
            render_file(f);
            _h("#show", txt.join("\n"));
            return; //exit show_atr() !
        }
        function pad_hex(h) { // pad_hex(n) is used to pad the value of the boot_record entries
            //(PVB COM) remplace the hex(n) with hex(n,4) if n is greater than 0xFF
            return h > 0xFF ? hex(h, 4) : '  ' + hex(h);
        }
        //(PVB ADD) pad_dec() function
        function pad_dec(x, n) { // pad_dec(n) is used to pad the value general
            x = "" + x; //convert x number into a string 
            return x.padStart(n, ' ');
        }
        //(PVB ADD) pad_dir(s, n) function
        function pad_dir(s, n){ //function pad_dir(s, n) is used to pad the display of the Directory (add space char after string)
            while (s.length < n)
                s = s + ' ';
            return s;
        }
        //(PVB ADD) pad_dtime(x) function
        function pad_dtime(x, t) {
            var c = t ? ":" : "/";
            var s = String(x & 0xFF).padStart(2,"0") + c + String((x >> 8) & 0xFF).padStart(2,"0") + c + String((x >> 16) & 0xFF).padStart(2,"0");
            return s;
        }
        //(PVB COM) no rawmode => display the atari disk : boot flags & disassembly, directory, VTOC, sectors dump, etc...
        // source https://www.atariarchives.org/mapping/appendix17.php : DOS 2.5 loads its boot sector at address $700
        var _br = {  //_br = Boot Record //$700 = standard DOS BOOT address
            BFLG: d[16],         //700: Boot flag; always equals 0.
            BRCNT: d[17],        //701: Number of sectors in the disk boot, -usually $03
            BLDADDR: le16(d, 18),//702: Boot load address; where DOS is loaded into memory; -usually $700 for DOS disk
            BINTAD: le16(d, 20), //704: DOS initialization address; -usually $1540
            BCONT: le16(d, 23),  //707: $4C jmp address for DOS2x, that is "$706  4C 14 07 ; JMP $0714"
            // (PVB COM) end of normal boot sector. Next is the DOS2x continuing structure:
            SABYTE: d[25],       //709: Maximum number of concurrently open files -usually $03
            DRVBYT: d[26],       //70A: Drive allocation byte; one bit per drive -usually $03
            SAFBFW: d[27],       //70B: -usually $00
            SASA: le16(d, 28),   //70C: Buffer allocation address for drives and files -usually $1A7C
            DFSFLG: d[30],       //70E: Reads zero if there is no DOS.SYS on disk, nonzero if present -usually $01
            DFLINK: le16(d, 31), //70F: Points to first sector of the DOS.SYS file (LSB first) -usually sector $04
            BLDISP: d[33],       //711: Number of displacement bytes to sector link bytes (last sector three bytes) = $7D (125)
            DFLADDR: le16(d, 34),//712: Address of the FMS (D:) handler table; -usually $7CB for DOS2x
            // $714 XBCONT  boot program continues at usually $714 as indicated in BCONT
        };
        if (d[22] != 0x4C) //(PVB ADD) if no jump $4C then br.CONT does not exist
            _br.BCONT = 0;

        /*(PVB MOD) cancel the available() function ///WIP// What was the purpose of the available() function?
        function available(n) {
            return d[vtoc + 10 + (n >> 3)] & (0x80 >> (n & 3));
        }*/
        //(PVB COM) Checking the validity of TOC => code is now /has been move in identity_dos() function in ATR class
        //(PVB ADD) check and identify the sector size of disk
        var density = "";
        //var formatStrError = ""; //(PVB ADD) ///WIP// use of formatStrError to report error
        var ts = atr.sector_count; //(PVB ADD)
        if (ts == 720) {
            // 720 sectors => Density 128 B/sect, ATARI 810 drive => for DOS1 & DOS2.0S, compatible all DOS;
            //             => Density 256 B/sect, ATARI 815 drive => for DOS2.0D, compatible with OSS DOS XL, DOS XE, MyDOS, Sparta
            density = atr.sector_size == 128 ? "Single Density SD" : "Double Density DD";
        }
        else if (ts == 1040) {
            // 1040 sectors => Density 128 B/sect, ATARI 1050 drive => for DOS3 and DOS2.5, compatible all DOS except DOS1 & DOS2.0S
            density = "1050 Enhanced Density ED (Medium Density)";
        }
        else if (ts == 1440) {
            // 2*720 = 1440 sectors => Density 256 B/sect, ATARI XF551 drive => for DOSXE, compatible with MyDOS (?), Sparta
            density = "Double Sided Double Density DSDD";
        }
        else if (ts > 1440 && atr.dosType == 8) { //(PVB MOD) MyDOS4.5x
            density = "MyDOS4.5x HD disk format";
        }
        else if (sparta) { //or atr.dosType == 0 for sparta
            density = "SpartaDOS disk format";
        }
        else if (atr.dosType == 10) { //for KBOOT ATR disk
            density = "KBOOT disk on a small disk image";
        }
        else { //(PVB MOD) unknow format
            density = "Unknown disk format with " + ts + " Sectors of " + atr.sector_size + " bytes";
            console.log("show_atr() file " + atr.name + " has a wrong unknown sector_count: " + ts);
        }
        let daf = "\n; <i>You can [download ATR file] if you want to save a fixed image file</i>\n";
        if (atr.buggy)
            txt.push("<span style='color:red;'>; Displayed ATR was corrected because ATR disk image file was <b>buggy</b> by having three 256-bytes boot sectors</span>" + daf);
        if (atr.restructured)
            txt.push("<span style='color:red;'>; Displayed XFD image file was restructured into a full disk image file</span>" + daf);
        if (atr.forcedExt && atr.newDisk)
            txt.push("<span style='color:red;'>; Original '" + atr.prevext + "' selected disk image format extension was not right and has been converted to ATR</span>" + daf);
        //Display Disk Image characteristics
        txt.push(`; <b>Image has ${ts} ($${hdx(ts)}) sectors of ${atr.sector_size} bytes - ` + density + "</b>"); //(PVB MOD)
        //(PVB ADD) SpartaDOS dosType management
        //if (formatStrError) txt.push(formatStrError); //WIP//
        var t1 = "disk has been identified";
        var t2 = "1 block is 1 sector";
        if (sparta) { //Sparta
            if (atr.vtoc1_sect) txt.push("; Jump to SpartaDOS <a id='BOOT' href='#VTOC'>Disk Bitmap</a> (VTOC)");
        }
        else if (atr.restructured) {
            txt.push("; <b><u>The disk image file did not have a disk size and then has been restructured into a new full disk image file!</u></b>");
        }
        else if (atr.dosType == 10) { //KBOOT
            txt.push(`; <b>KBoot ${t1}</b>, with one Atari executable file arbitrarily named 'KBOOFILE.XEX'`);
            txt.push(`;  which size is $${hdx(atr.totalBlock)} (${atr.totalBlock}) bytes, and starting at sector ${atr.file_start}`);
        }
        else if (atr.dosType > 0) { //not for Sparta for which dosType == 0
            var mep = "";
            switch (atr.dosType) {
                case 1: 
                case 2:
                    mep = ".0";
                case 2.5:
                    txt.push(`; DOS ${(atr.dosType + mep)} ${t1}, ${t2}`); break;
                case 3: txt.push(`; DOS 3 ${t1}, 1 block is 8 sectors`); break;
                case 4: txt.push(`; DOS 4 ${t1}, 1 allocation unit block is ${atr.blockSect} sectors`); break;
                case 5: txt.push(`; DOS XE ${t1}, 1 allocation unit block is a cluster of ${atr.blockSect} sectors (type is '${atr.dosXEType}')`); break;
                case 6: txt.push(`; MyDOS ${t1} (DOS2 compatible), ${t2}`); break;
                case 7: txt.push(`; MyDOS ${t1} (not compatible with DOS2), ${t2}`); break;
                case 8: txt.push(`; MyDOS4.5x HD ${t1} (more than 1440 sectors), ${t2}`); break;
            }
            if (atr.dirErrorStr) txt.push(`; WARNING${atr.dirErrorStr}`);
            if (atr.freeBlock || atr.totalBlock) {
                t1 = "; DOS disk has " + atr.freeBlock + " ($" + hdx(atr.freeBlock) + ") free blocks,";
                t1 += " among a total of " + atr.totalBlock + " ($" + hdx(atr.totalBlock) + ") blocks";
                txt.push(t1);
            }
            if (atr.vtoc1_sect) txt.push("; Jump to <a id='BOOT' href='#VTOC'>VTOC</a>");
            if (atr.vtoc2_sect) txt.push("; Jump to <a id='BOOT' href='#VTOC2'>VTOC2</a>");
            if (atr.dir_sector) txt.push("; Jump to <a href='#DIR'>Directory</a>");
        }
        else if (atr.dosType < 0) //No DOS found
            txt.push(`; WARNING${atr.dirErrorStr}`);
 
        txt.push("");
        //(PVB EN OF ADD)

        // Display boot sectors, disassemble them
        txt.push(";<b> Boot sector record" + (atr.restructured ? " (maybe not valid)" : "") + ":</b>"); //(PVB) update text
        var k = Object.keys(_br);
        //(PVB MOD & ADD)
        var bi = '', bic = '';
        for (var i = 0; i < (sparta || atr.isDosXE ? 5 : k.length); i++) { //for Sparta & DOS XE, don't list DOS2x additional boot info
            txt.push("; " + bi + pad_hex(_br[k[i]]) + " " + k[i] + bic);
            //(PVB ADD) display more information about boot
            if (i == 3) {//(PVB COM) 3rd value => check the jump
                if (d[22] == 0x4C) {
                    //(PVB COM) test of the JUMP $4C to BCONT
                    txt.push("; Boot execution start with a JUMP to BCONT=$" + hex(_br[k[4]],4));
                    i++; //so do not display BCONT again
                }
                else {
                    txt.push("; Boot execution start at BLDADDR+6=$" + hex(_br[k[2]]+6,4));
                    bi = "<i>"; //(PVB COM) set text in italic because should not be valid for a non DOS disk
                    bic = "</i>";
                }
                if (atr.dosType < 1 || atr.isDosXE || atr.dosType > 8) break; //no display of additionnal boot info for "no DOS", Sparta, and DOS XE
                txt.push("; " + bi + "<b>Additional DOS boot info:</b>" + bic);
            } //(PVB END OF ADD)
        }
        if (sparta || atr.isDosXE) { //Display Sparta Boot record // (PVB ADD) the display of the DOS XE Boot & VTOC record
            txt.push("");
            txt.push(`; <b>${sparta ? "SpartaDOS Boot" : "DOS XE Boot & VTOC"}</b> : `);
            var br = sparta ? sparta.boot : atr.dosxe.boot ;
            var k = Object.keys(br);
            for (var i = 0; i < k.length; i++) {
                if (k[i] == 'volume_name'|| typeof (br[k[i]]) === "string") //or use //if (Object.prototype.toString.call(br[k[i]]) === '[object String]')
                    txt.push(`;'${br[k[i]]}' ${k[i]}`);
                else
                    txt.push("; " + pad_hex(br[k[i]]) + " " + k[i]);
            }
        }
        if (sparta) { //(PVB ADD) display SpartaDOS version
            var v ="";
            if (br.version == 0x11) v = "SpartaDOS 1.1";
            else if (br.version == 0x20) v = "SpartaDOS 2.x, 3.x, or SpartaDOS X 4.1x/4.2x";
            else if (br.version == 0x21) v = "SpartaDOS X >= 4.39 (version 2.1 filesystem)";
            else v = "an unknown version";
            txt.push(`;\n; SpartaDOS version is $${hex(br.version,2)} that is ${v}`);
        }
        txt.push(";");
        
        // Scan files/sectors //(PVB ADD) Prepare data for the Disk Sector Dump and display the file directory list
        //(PVB MOD) cancel the use of get_dir() in this fucntion & add the restructured feature //previously //var dirs = atr.get_dir();
        var dirs = [];
        var blocsectors = []; //array for display a file and its block / sector in the sector listing
        //(PVB ADD) display the directory of DOS files
        txt.push("");
        if (f.dosdir && f.dosdir.length) { //OK, there is a Directory and Atari files, list them
            if (sparta) //no "save all files" for sparta, there is no use of such possibility
                txt.push(`; The following SpartaDOS files has been found in the <i>"${atr.name}"</i> disk image`);
            else { //not a sparta, and there is a Directory, and Atari files
                if (atr.dosType < 4) //add [save all valid files] only for DOS1 to DOS3 (small disk with few files)
                    var btmp = `<button style="float:right" type="button" title="=extract all the files from disk image (use with care)" onclick="save_as_dsk('ALL')">Download all valid files</button>`;
                txt.push(`; <i>"${atr.name}"</i> has a directory with the following DOS files: ${btmp}`);
            }
        }
        else if (!atr.restructured)//no DIR found
            txt.push(`; <i>"${atr.name}"</i> has no identified DOS files\n`);
        else
            txt.push(`; No directory was searched into the restructured disk image file\n`);
        
        var strList = "";
        var isDos34 = atr.isDos3 || atr.isDos4;
        if (!atr.restructured && f.dosdir.length) {
            var blkstr = (isDos34 || atr.isDosXE) ? (atr.blockSect + " sectors = " + atr.blockSize) : ("1 sector of " + atr.sector_size);
            txt.push("; <b>Directory on disk (1 block = " + blkstr + " bytes):</b>");
            txt.push("; FileId Flag Name          StartSector NbrBlocks   FileSize bytes  Info");
            //        ; #1     $80  12345678.123  $000(0000)  $000(0000)  $12345(123456)  xxxx
            dirs = f.dosdir;
            //(PVB END OF ADD)
            //(PVB MOD) add the directory listing //previously// dirs.forEach(dir => dir.sectors.forEach(s => { sectors[s.sector] = { dir: dir, sector: s } }));
            dirs.forEach(fe => { //for each file entry from the dos directory
                var dt = "";
                var isdir = fe.is_dir ? true : false;
                //Tag every sector with the file's name and block numbers
                if (atr.isDosXE) { //for DOS XE only
                    if (fe.maps)
                        fe.maps.forEach((sec, s) => {
                            blocsectors[sec] = {dirName: fe.name, dirTotal: fe.maps.length, dirOffset: s,  map:true}
                            blocsectors[sec].dirNext = (s == (fe.maps.length - 1)) ? 0 : fe.maps[s+1];
                        });
                    for (var s = 0; s <  fe.sectors.length; s++) {
                        var sec = fe.sectors[s];
                        blocsectors[sec] = {dirName: fe.name, dirTotal: fe.totalS, dirOffset: s + 1};
                        if (s == fe.sectors.length - 1) {
                            blocsectors[sec].dirNext = 0;
                            if (fe.bflen) // case for file
                                blocsectors[sec].dirLen = fe.bflen & (atr.blockSect == 2 ? 0x7F : 0xFF); //adjust number of bytes in the last sector
                            else // case for directory where bflen is not used
                                blocsectors[sec].dirLen = atr.sector_size;
                        }
                        else blocsectors[sec].dirNext = fe.sectors[s+1];
                    }
                }
                else {//if not DOS XE
                    fe.sectors.forEach(sect => {
                        blocsectors[sect.sector] = {dirName: fe.name, dirTotal: fe.total, dirOffset: sect.fbloc};
                        if (sect.snext && sect.snext > 0) blocsectors[sect.sector].dirNext = sect.snext;
                        if (sect.slen) blocsectors[sect.sector].dirLen = sect.slen; //number of bytes in one sector
                        if (sect.fid >= 0) blocsectors[sect.sector].dirId = sect.fid; //id of file (not for DOS3 & 4)
                    });
                }
                if (sparta && fe.valid > 1) { //(PVB ADD) SpartaDOS file info
                    //Special for SpartaDOS, the file first sector is the file sector map 
                    fe.maps.forEach(sect => {
                        blocsectors[sect.map] = {dirName: fe.name, dirTotal: fe.total_map, dirOffset: sect.fbloc, dirNext: sect.snext, map:true}
                    });
                    dt = " [Created on " + pad_dtime(fe.date, false) + "-" + pad_dtime(fe.time, true) + "]";
                }
                if (atr.isDosXE && fe.valid > 1) { //(PVB ADD) DOS XE file info
                    dt = " [Id $" + hdx(fe.dfnbr) + "]";
                    if (fe.numidf) dt += "[Creation date:" + fe.cdate + "; Mod date:" + fe.mdate + "]";
                }
                //Display directories listing 
                if (isdir) strList += "<b>"; //Directory diplayed in bold
                strList += ";" + (fe.numidf == '=>' ? pad_dir(("(#"+ fe.fnum + ")"),6) : pad_dir((" #"+ fe.numidf),8)); //FileId
                strList += (fe.numidf == '=>' ? "=> --  " : ("$" + pad_dir(hex(fe.flags,2),4))) + pad_dir(fe.name, 13); //the recovered ones
                strList += (" $"+ hex(fe.start,3) + pad_dir((" (" + fe.start + ")"), 7)); //start sector
                strList += (" $"+ hex(fe.total,3) + pad_dir((" (" + fe.total + ")"), 7)); //total blocks
                strList += (" $"+ hex(fe.fsize,5) + pad_dir((" (" + fe.fsize + ")"), 9)); //file size
                if (fe.erf) strList += fe.erf; else strList += dt;
                if ((atr.isDosXE || sparta) && fe.numidf == 0) strList += "[ROOT MAIN DIRECTORY]"; //first entry for SpartaDOS or DOS XE is MAIN
                else { //if not Sparta nor DOS XE first entry"
                    if (isdir) strList += "[DIR]";  // show "DIR" text if isdir
                    if (fe.dir_name) strList += "[Parent is " + fe.dir_name + "]"; //show parent "dir_name" if not empty
                }
                //Check the cases which identify an empty file, whatever DOS type (0 bytes directory is OK)
                if (fe.valid != 1 && (!fe.fsize || !fe.sectors.length) && !isdir) strList += " =>empty entry"; 
                //if file number is "=>" then it is an hidden/ canceled file that may be recovered
                strList += (fe.numidf == '=>') ? (" =>may be recovered ?\n" ) : "\n";
                if (isdir) strList += "</b>";
            });
            txt.push(strList + ";");
        }
        else {
            console.log("show_atr() ATR has no DIR");
        }

        //(PVB COM) Display the disassembly of boot sectors
        if (!atr.restructured) { //only if it is not a restructured disk image ATR
            var bootsize = atr.sector_offset(_br.BRCNT + 1);    // 0 based for data to load
            var bootdata = d.slice(16, bootsize); //(PVB COM) copy boot sector data, minus 16 first bytes (ATR header)
            //(PVB MOD & ADD)
            var entries = [_br.BINTAD];
            //(PVB COM) check boot sector vector validity
            //'cont' = is the address after the JMP, minus the boot load address (usualy $700)
            //if 'cont' is negative, we keep 'cont' for boot loading address; otherwise 'cont' is the address after the JUMP
            //org = _br.BLDADDR = boot load address ; entry = 'cont'
            if(_br.BCONT && (_br.BCONT -_br.BLDADDR) > 9)
                entries.push(_br.BCONT);
            txt.push(xex_dump(_br.BRCNT, bootdata, 0, bootdata.length, "BOOT", _br.BLDADDR, entries));
        }
        txt.push('\n' + _hr);
        txt.push('; <b>Disk Boot sector hexdump</b>');
        txt.push(_hr + '\n');

        //(PVB COM) Display the sector of the ATR disk image file
        var n = 0; //(PVB COM) n is the sector counter
        var nsb = [];
        function get_bfs(n) { //with the sector number, get the block and the sector within the block
            var t, s;
            if (atr.isDos3) {
                t = Math.floor((n-25)/8);
                s = n - t*8 - 24;
            }
            if (atr.isDos4) {
                t = Math.floor((n-1)/atr.blockSect);
                s = n - t*atr.blockSect;
            }
            return [t, s];
        }
        //(PVB COMM) Loop to manage display of all the information about sectors on disk image
        for (; ;) { //(PVB COM) endless loop, stop when offset index is greater than the ATR size
            var ssize = n < 3 ? 128 : atr.sector_size;
            var offset = atr.sector_offset(n + 1);
            if (offset >= (atr.size + 16))
                break; //EXIT! end of loop, last sector has been reached !
            var zero = is_zero(d, offset, ssize);
            // Display the VTOC and Directory sectors
            switch (++n) {
                case atr.vtoc1_sect:
                    if (!sparta) txt.push("; <span id='VTOC'>VTOC Volume Table of Contents <a href='#BOOT'>(back)</a></span>");
                    else txt.push("; <span id='VTOC'>SpartaDOS Bitmap fist sector (VTOC)<a href='#BOOT'>(back)</a></span>");
                    break;
                case atr.dir_sector: txt.push("; <span id='DIR'>Directory <a href='#BOOT'>(back)</a></span>"); break;
                case atr.vtoc2_sect:
                    txt.push("; <span id='VTOC2'>VTOC2 Volume Table of Contents 2<a href='#BOOT'>(back)</a></span>"); break;
            }
            var bsn = blocsectors[n]; // .sectors correspond au chainage des secteurs d'un fichier DOS valide
            var sstr = "";
            var cstr = "";
            if (bsn) { //the sector belongs to a file (or file sector map for Sparta) So display the fiename and the file sector count
                var sbf = bsn.dirOffset + 1; //dirOffset = number of the sector or block into the file
                var nsf = bsn.dirNext;
                var lsf = bsn.dirLen;
                //(PVB MOD) if sb == 0; this is the file sector_map of a spartaDOS file
                sstr += " [" + bsn.dirName + ";"; //file name
                if (bsn.dirId) sstr += " ID#" + bsn.dirId + ";";
                if (bsn.map) sstr += " File Map"; //for SpartaDOS and DOS XE only, as they use file map sectors
                sstr += (isDos34 ? " Block#" : " Sector#"); //only DOS 3 uses the block to display files, oddly DOS 4 uses sector display and not block display
                //sstr += " Sector#";
                if (sbf) sstr += " " + sbf + "/" + bsn.dirTotal + (isDos34 ? "" : " ($" + hdx(sbf) + "/$" + hdx(bsn.dirTotal) +")");
                if (lsf && !isDos34 && !atr.isDosXE) sstr += "; Bytes: $" + hex(lsf,2) + "(" + lsf + ")";
                if (nsf) sstr += "; NextSector: $" + hdx(nsf) + "(" + nsf + ")";
                else if (!bsn.map) sstr += "; **EOF**" + (isDos34 || atr.isDosXE ? (" (EndByte@$" + hex(lsf-1,2) + ")") : "");
                else if (bsn.map) sstr += "; **EndOfMap**"
                sstr += "]";
            }
            //(PVB MOD) display disk sectors with counting from 1 and not 0, and corresponding Block (Allocation Unit) for DOS 3 and 4
            if (atr.isDos4 || (atr.isDos3 && n >= 25)) { //Block $15(30)-Sect#5
                nsb =  get_bfs(n);
                cstr = ", Block $" + hdx(nsb[0]) + " (" + nsb[0] + ")"  + " >Sect#" + nsb[1]; //display block and sector within the block
            } //and display Cluster number for DOS XE
            if (atr.isDosXE) {
                var cf = atr.blockSect == 2 ? Math.floor(n/2) : n;
                cstr = ", Cluster $" + hdx(cf) + " (" + cf + ")"; //add cluster for DOS XE
            }
            txt.push('; Sector $' + hex(n, 3) + ' (' + n + ')' + cstr + ';' + (zero ? ' (' + ssize + ' zeros)' : '') + sstr);
            if (!zero)
                txt.push(hex_dump(d, offset, ssize, 4));
            txt.push('');
            if (n == _br.BRCNT) { // for the last sector of the boot
                txt.push(';<i>End of Disk Boot sector hexdump \><a href="#top">Back to top</a></i>\n');
                txt.push(_hr);
                txt.push('; <b>Disk sector hexdump</b>');
                txt.push(_hr);
                txt.push('');
            }
        }
        txt.push(';<i>End of Disk sector hexdump \><a href="#top">Back to top</a></i>');

        render_file(f);
        _h("#show", txt.join('\n'));
    }

    //(PVB ADD) functions retrieve_file_data(f), show_hexdump(f), and show_extract(f)
    //called by show(id) in case of _shown.extract_launched is true, or called by toggle_hex() to display file Hex Dump
    function retrieve_file_data(f) {
        var d;
        if (f.type == "isDisk") d = f.atr.d.slice(16, f.atr.d.length); //data of an "isDisk" without the ATR 16-bytes header
        else if (f.type == "isRomdump" && f.rom.isCart) d = f.data.slice(16, f.data.length); //retrieve data of an "isRomdump", without the CART header
        else d = f.data; //else retrieve data of an "isFile" or "isRaw" or "isRomdump"
        return d;
    }
    function show_hexdump(f) {
        render_file(f);
        var d = retrieve_file_data(f);
        var str = '; Hexdump view of "' + f.name + '"" file data';
        if (f.start && f.total) str += '\n; [Start sector: $' + hdx(f.start) + '; ' + f.total + ' blocks or sectors]'; //only if is an Atari DOS file
        str += '\n\n' + hex_dump(d, 0, d.length, f.type == "isDisk" ? f.atr.sector_size : 0) + '\n;<i>End of Hexdump \><a href="#top">Back to top</a></i>';
        _h("#show", str);
    }
    function show_extract(f) { //display the extract menu and the hex dump
        //(PVB TODO) to limits the extract possibility according to f.ext or f.type
        if (f.type == "isTxtImg" || f.type == "isFnt" || f.type == "isArc") { //shall not be possible as "E" is disable for these file type
            console.log("Show_extract() cancelled because isTxt, isFnt, isArc");
            return; //no extract on a text, picture, font or Arc file
        }
        if (!f.extract_launched) {//no launch-extract has been launched yet, so just display hex_dump and not disassembly
            show_hexdump(f);
        }
        else { //an extract has been launched, so display disassembly
            var d = retrieve_file_data(f);
            console.log("show_extract() => Display the disassembly of the Extract"); //(PVB CONSOLE HINT)
            if (f.type == "isDisk") {
                var ss = f.extracted_disk.start_sect; 
                var es = f.extracted_disk.end_sect;
                var so = f.extracted_disk.start_sect_off;
                var ad = f.extracted_disk.start_add;
                var sta = (ss < 4) ? (so + (ss - 1) * 128) : (384 + so + (ss - 4) * f.atr.sector_size);
                var sto = (es < 4) ? (es * 128 - 1) : (384 + (es - 3) * f.atr.sector_size - 1);
                if (sta < sto && sto <= d.length) { //(PVB COM) protection in case of extract_disass() has done wrong
                    var de = d.slice(sta, sto + 1);
                    render_file(f);
                    _h("#show", xex_dump("Disk extracted data", de, 0, de.length, "EXTRACT", ad));
                    f.extractedData = de;
                }
                else
                    alert("show_extract() ==> Something went wrong, extracted data error! ");  //(PVB COM) display an error in case of selection of range has done wrong
            }
            else {
                var so = f.extracted_file.start_offset; 
                var eo = f.extracted_file.end_offset;
                var ad = f.extracted_file.start_add;
                if (so <= eo && eo < d.length) { //(PVB COM) protection in case of extract_disass() has done wrong
                    var de = d.slice(so, eo + 1);
                    render_file(f);
                    _h("#show", xex_dump("File extracted data", de, 0, de.length, "EXTRACT", ad));
                    f.extractedData = de;
                }
                else
                    alert("show_extract() ==> Something went wrong, extracted data error!");  //(PVB COM) display an error in case of selection of range has done wrong
            }
        }
        return;
    }
    //(PVB ADD) function update_a5200eq_option() to handle the A5200 Equates
    function update_a5200eq_option(f) {
        if (f) { // then this is a new file displayed, so update _bShowA5200Equates according to f.a5200eq
            _bShowA5200Equates = f.a5200eq ? 1 : 0;
        }
        //update a5200 equates display option
        var chkdof = document.getElementById("cShowA5200Eq"); //get the display option diplay Id
        if (chkdof) chkdof.className = _bShowA5200Equates == 1 ? "hilite" : ""; //if Id, then update it
        _checks['cShowA5200Eq'] = _bShowA5200Equates; //update _checks table
    }
    //(PVB END OF ADD)

    //(PVB MOD) improvement of the show(id) function - show(id) is called by refresh() function (refresh() = show(_shown.id))
    function show(id) { //(PVB COM) show(id) is call on click event on file canva container to display the file on page right
        //id is the number of file in the container files, last available value is in the global variable _id
        //show(id) is also use the re-display the same file when clicking on tools (E extract, H Hexdump...) and buttons
        try {
            var f = get_file(id);
            if (_bHexEd) display_HexEditor(false); //cancel/close the Hex Editor window frame if active
            if (_shown) { //a file is already displayed
                if (id != _shown.id) { //we have changed to another file !
                    ///here: action if clicked on a different file from the left file list
                    reset_ext(); //if changed type in the previous file, cancel it (same as click on Reset Type button)
                    reset_hexdump(); //if hexdump display in previous file, cancel it
                    if (_shown.extract) reset_extract(); //same as click on Cancel Extract button
                    cancel_search(); //cancel search in progress if changing of file
                    update_a5200eq_option(f); //(PVB ADD) update the A5200 equates disassembly option in menu
                    console.log("show(id) => we have changed to another file !");
                }
                //else // we have the same file selected: action not useful, because show(id) can be called several times for displaying same file !!
            }
            var isTypeChanged = false; ///WIP// futur use
            console.log("show(id) => Trying to show id: " + id + ", Name: '" + f.name + "'");
            if (f.type == "spacer") { //in case of "spacer" set the click to the next id that must be the ATR disk
                f = get_file(++id);
                console.log("show(id) => Get next id: " + id + ", Name: '" + f.name + "', file type: " + f.type); //(PVB CONSOLE HINT)
            }
            if (f.data.length == 0){ //(PVB MOD) we should only consider "Modify it" //data.length is still 0 after conversion into XFD/ATR disk
                f.ext = '???';
                f.empty = true; //display the empty file with a warning
            }
            //(PVB MOD) use of get_type() that is already in f.type instead of e = _exts[f.ext];
            if (f.original_ext && f.original_ext != f.ext) { //we have changed the ext type !
                var ntype = get_type(f.ext, false); //get type of new ext, false for not to consider "isFile" for DOS file
                console.log("show(id) => New extension request! id: " + id + ", Name: '" + f.name + "', new ext: " + f.ext + ", file type: " + ntype); //(PVB CONSOLE HINT)
                if (f.type != ntype) { //we have changed the file type !
                    console.log("  > notice this has changed the file type that was: '" + f.type + "'");
                    isTypeChanged = true; ///WIP// futur use
                    f.type = ntype;
                }
            }

            _shown = f; //(PVB COM) save the current selected file into the _shown global variable
            
            update_a5200eq_option(false); //set the A5200 equates disassembly option in menu

            if (f.extract_menu_request && (f.type != "isRomdump")) { // rom extract is managed below
                show_extract(f);
                return;
            }
            if (f.forceHexDump && ntype !="isRaw") { //no forced hexdump for "isRaw" (dat), it is a normal dump above
                //(PVB TODO) do special hexdumps for Rom Banks 
                show_hexdump(f);
                return;
            }
            if (f.ext == "bas") {
                show_bas(f);
                return;
            }
            if (f.ext == "m65") {
                show_m65(f);
                return;
            }
            if (f.ext == "fnt" || f.ext == "chr") {
                show_fnt(f);
                return;
            }
            if (f.ext == "arc") {
                show_arc(f);
                return;
            }
            //(PVB ADD) ROM Dump
            //Warning f.type is not set after changing an extension type, so a RomDump will still be a romdump, even if extension is changed
            if (f.type == "isRomdump") {
                if (f.extract_menu_request) {
                    show_extract(f); //(PVB TODO) do special extract within the selected bank for ROM
                    return;
                }
                if (f.ext != "dat") { 
                    show_rom(f); 
                    return;
                } //else ROM is displayed as DAT as below
            }
            //Warning f.type is not set after changing an extension type, so an isDisk will still be an is Disk, even if extension is changed
            if (f.type == "isDisk") { //for the atari disk like XFD, ATR...
                if (ntype != "isRaw") {
                    show_atr(f, f.ext == "dsk"); //(PVB COM) Rawmode in show_atr() if ext == "dsk"
                    return;
                } //else the isRaw will be displayed as below 
            }
            //other files
            var e = f.ext == '???' ? _exts["dat"] : _exts[f.ext]; //(PVB ADD) mandatory : if extension is unknown (???), then force .dat
            if (e && e.is_img) {
                show_img(f);
                return;
            }
            if (e && e.is_txt) {
                show_txt(f);
                return;
            }
            console.log("show(id) => ...render_file (f) which name is: " + f.name + ", ext: " + f.ext + ", type: " + f.type); //(PVB CONSOLE HINT)

            render_file(f); //(PVB COM) display title and type selection list on page top right in #main

            if (e && e.is_code) { //(PVB COM) when it si "is_code" (and not a ROM or an Atari disk) => disassemble it !
                console.log("show(id) => xex_dump() of '" + f.name + "'");//(PVB CONSOLE HINT)
                //display of disassembly code in the <pre id="show"
                _h("#show", xex_dump(f.name, f.data, 0, f.data.length, (e.has_header ? "HEAD" : "BIN"))); //(PVB COM) BIN has no header
                return;
            }
            //(PVB COM) here we have a special file like "???" or "DAT", so display an Hex Dump of the file
            if(f.empty) {
                var str = "; ERROR, nothing to show! the selected '" + f.name + "' file is empty !";
                str += "\n; =>You should consider to modify it by the [M] tool, or convert it into an XFD/ATR disk image...";
                _h('#show', '<span style="color:red;">' + str + '</span');
                return;
            }
            console.log("show(id) => '???'' or 'DAT' file HEX_dump() of '" + f.name + "' (with extension: '" + f.ext + "') as " + e.name);//(PVB CONSOLE HINT)
            var str = '; Hexdump of '; //(PVB ADD) hint on hexdump display
            if (f.is_dir) str += 'directory file "' + f.name + '"';
            else str += 'data in file "' + f.name + '" which extension ' + (f.ext == '???' ? 'type is unknown and shown as DAT' : (f.original_ext ? "is forced to DAT" : "is DAT"));
            if (f.start && f.total) str += '\n; [Start sector: $' + hdx(f.start) + '; ' + f.total + ' blocks or sectors]'; //only if is an Atari DOS file
            _h("#show", str + '\n\n' + hex_dump(f.data, 0, f.data.length) + '\n\n;<i>End of Hexdump \><a href="#top">Back to top</a></i>'); //(PVB COM) default hex_dump() as for a DAT file
        }
        catch (err) {
            /*previously//show_as("dat"); //(PVB COM) No need to keep this action, since no error should now occur thanks to the tool upgrade*/
            //so warn to kindly report to development team (i.e. myself, pvbestinfoo!)
            var str = '[! ERROR while trying to display file Id #' + id + ' "' + f.name + '"!]\n[See HTML Console log for details & Please report the bug to development team]';
            console.log(str);
            console.log(err);
            _h('#show', '<span style="color:red;">' + str + '</span>');
        }
    }

    //(PVB ADD) the reset_hexdump() function
    function reset_hexdump () {
        if (_shown.forceHexDump) _shown.forceHexDump = 0;
    }
    
    function show_as(e) { //funtion show_as() is called by the ext list ext_option(f)
        if (_shown) {   //(PVB COM) _shown is the 'file' shown on right page // if "_shown" then a file was already displayed
            if (((e == 'atr' || e == 'xfd' || e == 'pro' || e == 'atx' || e == 'dsk' || e == 'dcm') && !_shown.atr) 
                || ((e == 'bin' || e == 'a52' || e == 'car' || e == 'rom') && !_shown.rom)) { //conversion from isFile to isDisk or isRomdump
                console.log("show_as() => An isDisk or isRomdump type extension is requested... so make a file and open it!");
                //curext is set to the previous current extension in order to tell load_data() that we need to open a new file
                load_data(_shown.name + "." + e.toUpperCase(), _shown.data, "", _shown.ext) //load_data(name, a, imgTag, curext)
                refresh_containers();
                return; //Exit as we have opened a new file, no need to save 'ext' modification
            }
            if (!_shown.original_ext){
                _shown.original_ext = _shown.ext; //save original extension
                _shown.original_type = _shown.type; //save original type
            }
            _shown.ext = e; //change file type extension
            reset_hexdump(); //cancel Hex Dump display
            extract_reset(); //cancel Extract display
            //note: cancel_search() is not called, allowing to explore type like GR7, GR8, PIC, FNT... keeping the offset and search menu display 
            refresh(); // select one // Go for redisplaying the new file type and update buttons
        }
    }
    //(PVB ADD) the create_atr() function
    function create_atr() { //called by the [Create XFD/ATR disk] button when a DAT file is displayed
        load_data(_shown.name, _shown.data, "", "forceATR") //load_data(name, a, imgTag, curext)
        refresh_containers();
    }
    //(PVB ADD) the reset_ext() function
    function reset_ext() { //called by reset_type_button() and in show(id)
        if (_shown.original_ext) { //yes there was a previous type
            _shown.ext = _shown.original_ext; //restore extension
            _shown.type = _shown.original_type; //restore type
            delete _shown.original_ext; //delete saved extension
            delete _shown.original_type; //delete saved type
        }
    }
    //(PVB ADD) the reset_type_button() function
    function reset_type_button() { //called by HTML event: onclick "Reset file type" button
        reset_ext();
        reset_hexdump();
        cancel_search();
        extract_reset();
        refresh(); //re-display the file with previous extension in the "main" HTML page
    }
    //(PVB ADD) toggle_hex() is used to force display of the file hex dump
    function toggle_hex() { //called by HTML event: onclick "H" tool
        if (!_shown.forceHexDump === undefined)
            _shown.forceHexDump = 1; //invert flag
        else
            _shown.forceHexDump ^= 1;
        refresh(); //then re-display the file with forced Hexdump in the "main" HTML page
    }
    //(PVB ADD) toggle_disoption() is used to manage the "disoption" menu flag
    var _bShowDisOption = 0; //variable to memorize the choice
    function toggle_disoption(swtchon) { ///WIP// to simplify the toggle_disoption
        if (!_q("#disoption")) { //in case of #disoption is not in the HTML doc
            console.log("INFO: toggle_disoption has been canceled");
            return; 
        }
        if (swtchon) {
            _bShowDisOption = 1;
            toggle_on("#disoption");
        }
        else {
            _bShowDisOption ^= 1;
            toggle("#disoption");
        }
    }
    //(PVB ADD) toggle_extract() is used to display/hide the Extract menu (click on "E") and set/reset the f.extract_menu_request flag
    function toggle_extract() {
        if (!_shown.isExtractable) return; //if file not extractable, then do nothing
        if (!_shown.extract_menu_request === undefined) _shown.extract_menu_request = 1; //invert flag
        else _shown.extract_menu_request ^= 1;
        console.log("INFO: toggle_extact flag is: " + (_shown.extract_menu_request ? "ON" : "OFF"));
        reset_hexdump();
        refresh(); //then re-display the file in the "main" HTML page
    }
    //(PVB ADD) cancel_search() is used to cancel all search
    function cancel_search(){ //called by reset_type_button() and toggle_search() functions
        if (_shown.isSearchable && _shown.searchrequest) { //a search is in progress, so cancel it
            delete _shown.searchrequest;
            _shown.data = _shown.dataOld;
            delete _shown.dataOld;
            delete _shown.offst;
        }
    }
    //(PVB ADD) toggle_search() is used to display/hide the Search menu and set/reset the f.searchrequest flag
    function toggle_search() {  // either "searchrequest == 1" => search is in progress; either "searchrequest" does not exist
        if (_shown.isSearchable) {
            if (_shown.searchrequest === undefined) { //first time
                _shown.searchrequest = 1; //activate search
                _shown.dataOld = _shown.data; //save data before modification
                _shown.offst = 0;
            }
            else cancel_search(); //search request exists, so cancel it
            refresh();
        }
    }
    //(PVB END OF ADD)

    function refresh() {
        show(_shown.id);
    }

    function close_container(id) { //close_container(id) is called when user click on the cross to close file on page left
        for (var i = 0; i < _containers.length; i++) {
            if (_containers[i].id == id) {
                _containers.splice(i, 1);
                break;
            }
        }
        if (_bHexEd) display_HexEditor(false); //cancel/close the Hex Editor window frame if active
        //previously// render_state(_containers); //instead of// refresh_containers();//PVB COM) it's better to come back to first file when other file is cancelled
        refresh_containers(true); //(PVB ADD) set to true in case of _containers closing to refresh properly displayed files
    }

    //===================================================================================================
    //(PVB MOD) improvement of load_one(): handle ROM file, display of size in KB or B
    function load_one(name, ext, a, imgTag, gt, curext) { //(PVB COM) load_one() is called by load_data() when the disk image file is not a disk with several DOS files
        //(PVB ADD) handling the ROM case with the ROM constructor; "curext" if the file was already displayed with another extension; "gt" is the file type
        var nr;
        console.log("load_one() loads " + name + " that is a '" + gt + "' file type into the container (previous 'ext' was '" + curext + "')"); //(PVB HINT)
        if (gt == "isRomdump") {
            nr = new ROM(a, name);
        }
        //(PVB ADD) handling the computation of the image file size in KB or B
        var strSize = '';
        if (a.length < 1024) {
            strSize = a.length + "B ";
        }
        else {
            var n = (a.length & 0x3FF) ? (a.length >> 10) + 1  : a.length >> 10 ;
            strSize = n + "KB";
        }
        //(PVB MOD) //Previously // var f = { name: name, ext: ext, data: a, id: _id++, total: ((a.length + 127) >> 7, img: img };
        var cf = {name: name, type: gt, data: a, id: _id++, total: strSize, imgTag: imgTag}; //put new image file in the container
        if (ext == 'ere') {
            ext = '???';
            cf.forcedDat = true; //file has been forced to be displayed as DAT
            cf.prevext = curext; //and was previously displayed as another ext
        }
        else if (curext && curext != ext) cf.forced_ext = true; 
        else cf.forcedDat = false;
        cf.ext = ext;
        if (nr && gt == "isRomdump") {
            cf.rom = nr;
            if (nr.romMachine == '5200') { //initialize the a5200eq here because it's not done show(id) nor in show_rom()
                cf.a5200eq = true;
                _bShowA5200Equates = 1;
            }
        }
        var i = name.lastIndexOf(".");
        var ext83 = ext;
        if (i != -1) {
            ext83 = name.substr(i + 1);
            name = name.substr(0, i);
        }
        if (i > 8 || ext83.length > 3){ //(PVB MOD)
            cf.name83 = name.substr(0, 5); //(PVB MOD)
            cf.name83 += "..."; //(PVB MOD)
        }
        else{ //(PVB MOD)
            cf.name83 = name.substr(0, 8);
            while (cf.name83.length < 8)
                cf.name83 += ' ';
        }
        cf.name83 += ext83.toUpperCase().substr(ext83.length - 3, 3);
        _containers.unshift({ name: cf.name, ext: ext, type: "container", data: a, files: [cf], id: _container_id++ }); //(PVB MOD) single file into container
        return cf;  //(PVB COM) the return of "cf" is required with flush_images() function via the load_data() that calls the load_one()
    }
    //(PVB MOD) improvement of load_data()
    function load_data(name, a, imgTag, curext) { //(PVB COM) load_data() is called by load() and flush_images() to load the OS/Windows Image file into memory
        //(PVB COM) name = full filaname of the disk image file like "Foo.XFD"; a =  data of the OS/Windows file;
        // imgTag = the image type/mime when the Client loads an image without or with unknown file extension; "curext" current ext of existing file in tool (conversion)
        console.log(_hr + "\n>load_data() Loading '" + name + "' with imgTag '" + imgTag + "'..."); //(PVB HINT)
        var originalExt = "";
        var ext = "";
        if (curext && curext == "forceATR") {
            originalExt = "xfd";
            ext = "xfd";
        }
        else {
            originalExt = name.lastIndexOf(".") == -1 ? "" : name.substring(name.lastIndexOf(".") + 1).toLowerCase(); //the requested ext before anlylising it by get_ext()
            ext = get_ext(name, a, imgTag, false); //(PVB COM) get the filename extension according to its contents and/or its extension!; "false" for not atari DOSfile
        }
        //(PVB MOD) the new function get_type() to remplace "var e = _exts[ext];"
        //Note: for disk image, get_ext() checks and corrects extension adequacy by analyzing disk content, in order to avoid ATR constructor crash
        //get_ext() returns "ere" if dcm error or atr error
        if (curext && curext != "forceATR") { //it is an Ext Type conversion by the user, so put right extension
            name = name.substring(0, name.lastIndexOf(originalExt.toUpperCase()) - 1); //cancel the file ext that had been added
            if (ext == "ere" && (curext == '???' || curext == 'dat')) { //no need to reopen a dat file, because "ere" will be displayed as DAT
                console.log("load_data() => error in get_ext(), '" + originalExt + "' file extension not recognized, so redisplay it as a DAT file!");
                _shown.prevext = originalExt;
                _shown.forcedDat = true;
                return null;
            }
        }
        var gt = get_type(ext, false); //'false' for not to consider "isFile" for DOS file
        //(PVB COM) if not an "isDisk", there is no DOS files in a directory to retrieve, so it is a single file to open with load_one()
        if (gt != "isDisk") { //(PVB COM) //previously // if (!e || !e.is_disk)
            if (!curext) curext = originalExt;
            return load_one(name, ext, a, imgTag, gt, curext);
        }
        //Here: we have an isDisk disk image.
        console.log("load_data() converts and loads the '" + ext + "' disk image file into a displayable ATR file..."); //(PVB HINT)
        //make an ATR with the isDisk (isDisk are always converted into ATR in the tool)
        var str = '';
        if (ext == 'dcm') { //if it is a dcm file, convert it!
            var b = extract_dcm(a);
            if (!b) str = '! ERROR while trying to convert the "' + name + '" DCM file into ATR! Please read Console log!';
            else var atr = new ATR(b, name, ext);
        }
        else {
            var atr = new ATR(a, name, ext);
            if (!atr) str = '! ERROR while trying to open the "' + name + '", it cannot be converted into ATR disk image!';
            if (a.length == 0) a = atr.d.slice(16); //atr has been created, but length of "a" was null, so it was an empty file, copy the restructured "atr.d" in "a"
        }
        //(PVB MOD) improvement of the files array
        if (!atr) {
            alert(str);
            console.log("load_data() => ATR Constructor error: " + str);
            return null;
        }
        var files = []; //"files" array is the list of files to be displayed in the blue directory on page left by render_state(m)
        if (!atr.restructured) { //(PVB ADD) if "restructured" no need to seek for a directory, no file on restructured ATR disk
            var dirs = atr.get_dir();
            dirs.forEach(f => { //purpose here is to get type of each Atari DOS file, and if OK, to set it in the "blue" directory on left 
                if (f.valid == 2 && f.sectors.length) { //if not valid, or no sectors (empty file) the file is not displayable, so exit to next "f"
                    var file = { name: f.name, name83: f.name83, id: _id++, start: f.start, total: f.total, flags: f.flags, recovered: f.recovered, is_dir: f.is_dir};
                    if (f.gname83) file.gname83 = f.gname83; //genuine filename with inverted char (non-DOSx compatible)
                    file.data = atr.read_file(f); //atr.read_file() calls sparta.read_file() or dosxe.read_file() accordingly
                    file.dosType = atr.dosType; //copy atr.dosType in the file, DOS type found into the ATR disk is an important information to know
                    file.ext = f.is_dir ? "???" : get_ext(file.name, file.data, false, true); //actual ext is from get_ext() (and not from filename ext)
                    if (!f.ext || (f.ext.toLowerCase() != file.ext)) file.forced_ext = true; //if the ext is forced to have a correct display of the file
                    console.log(" ...get_ext() returns '" + file.ext + "' extension for " + file.name + " Atari DOS file!");
                    //if ext has been forced to bin, set the isFile not to confuse it with RomDump, otherwise get the type of file from get_type()
                    file.type = (file.ext == 'bin') ? "isFile" : get_type(file.ext, true); //true for "isFile" for DOS file
                    files.push(file);
                }
            });
            console.log("load_data() ATR file " + name + " has a DOS directory with " + files.length + " valid DOS files"); //(PVB HINT)
        }
        else { //ATR was restructured, so force extension to ATR
            ext ='xfd';
            console.log("load_data() " + name + " was truncated and has been restructured, no DOS directory was searched!"); //(PVB HINT)
        }
        if (ext != originalExt) { //isDisk extension adequacy has been corrected by get_ext()
            atr.forcedExt = true; //so put save button ON to save new file
            atr.prevext = originalExt; //memorise original extension
        }
        if (curext) {//there was a file previous display (from a DAT isRaw file)
            atr.newDisk = true; //so put save button ON for the new displayed file
        }
        var forced_ext = atr.restructured || atr.forcedExt; //extension was forced
        //(PVB COM) files = table of valid ATARI DOS files found into the ATR disk; so files.length is the number of files
        if (files.length) {
            //(PVB COM) if files where found, add a spacer (empty line) under the directory list as a file, that will be displayed in blue on left
            //(PVB MOD) the "spacer" type: name83 is empty, ext is empty. 
            files.push({ name83: "", name: "", ext: "", type: "spacer", data: [], id: _id++});
        }
        //(PVB MOD) add the name of the ATR disk file as the last file in the list
        //.name 83 : is used to display the number of sector on ATR disk, .name is the name of the ATR File (foO.XFD)
        //.type is set to the type of file, which is a "isDisk", .data : is set to the data of the ATR disk
        //.atr and .dosdir are added to save the atr construction data, and the valid DOS directory found
        files.push({name83: (atr.sector_count + "-sector disk"), name: name, ext: ext, type: "isDisk", data: a, id: _id++, atr: atr, dosdir: dirs, forced_ext: forced_ext});
        _containers.unshift({ name: name, length: a.length, data: a, ext: ext, type: "container", files: files, id: _container_id++ }); //(PVB MOD) put files at the beginning of the _containers
        console.log("load_data() has loaded " + name + " (and its DOS files) into the container"); //(PVB HINT)
    }

    //===================================================================================================
    // https://www.atarimagazines.com/software/software.html

    var _images = [];

    function flush_images() {
        _images.forEach(f => {
            var b = '';
            for (var i = 0; i < f.data.length; i++)
                b += String.fromCharCode(f.data[i]);
            var url = `data:${f.file.type};base64,${btoa(b)}`;

            var img = document.createElement('img');
            img.src = url;
            img.hidden = true;
            img.onload = (evt) => {
                load_data(f.file.name, f.data, img).edit_img = 1;
                refresh_containers();
                document.body.removeChild(img);
            }
            document.body.appendChild(img);
        });
        _images = [];
    }

    function refresh_containers(close) { //(PVB COM) refresh_containers() is used to select the first file on the list on page left to be shown on the right!
        render_state(_containers);
        if (_containers.length) { //there is a _containers, so file to display
            //(PVB MOD) add the *opened file remaining displayed* in case of a "close" file container occurs (X icon click) 
            var exit = false;
            if (_shown && close) // if an opened file is displayed, and close _containers requested 
                _containers.forEach(c => c.files.forEach(i => { if (i.id == _shown.id) exit = true })); //if the file is still in the _containers, exit
            //else display the root (=last file) of the first file of the _containers list (=the new loaded) - case by default
            if (!exit) show(_containers[0].files[(_containers[0].files.length - 1)].id);    // select on
        }
    }

    // #153382 - BG 0x94

    function open() {
        _q("#fe").click();
    }
    
    function load() { // (PVB COM) load() is the HTML Javascript main function
        drop_init(_q("#toc"),
            (file, ab) => { //(PVB COM) file = client loaded file; name = name of the client loaded file, and properties
                //ab = ArrayBuffer for the file data (byteLenght = size of the file)
                if (file.type.indexOf("image") != -1) //check file MIME type, if is is an image picture file
                    _images.push({ file: file, data: new Uint8Array(ab) }); //if so, file is push in _images
                else //it is not an image picture file
                    load_data(file.name, new Uint8Array(ab)) //file data is loaded by the load_data() function
            },
            () => {
                flush_images();
                refresh_containers();
            }
        );
        _fcanvas = get_font(_font);

        document.body.onkeyup = function (e) {
        }

        document.onselectionchange = selection_change; //(PVB COM) watch where is the mouse pointer, and if text is selected by the carret

        document.body.onkeydown = function (e) {
            if (e.ctrlKey && e.shiftKey) {
                switch (e.key) {
                    case 'o':
                    case 'O':
                        open();
                        break;  // open a file....
                    case 'h':
                    case 'H':
                        toggle_hex();
                        break;  // toggle hex display
                    case 'k':
                    case 'K':
                        toggle_kb();
                        break;  // toggle keyboard
                    case 'j': // for special test features
                    case 'J':
                        launch_test();
                        break;
                }
            }
        };
        render_state(_containers);
        window.addEventListener("message", function(event) {
            if (event.data) receive_HexEditor(event.data);
        }); //(PVB ADD)
    }

    //(PVB ADD) the toggle_on() function to force display (instead of switching it in toggle() function)
    ///WIP// to simplify & merge the toggle & toggle_on function ?
    function toggle_on(eid) { //toggle_on() is used by toggle_disoption() to force dsiplay of the option menu
        var e = _q(eid);
        if (e) e.style.display = "block"; //force to set display block on
    }
    function toggle(eid) { //toggle(eid) is used by disassemble2()/as_data() for data block and toggle_disoption() for option menu
        var e = _q(eid);
        if (e) e.style.display = e.style.display == 'none' ? "block" : "none";
    }

    //(PVB ADD) show_bank(id) function is called by show_rom(f)
    //Note : the button [Toggle Disassembly/HexDump] set in show_rom(f) calls the show_bank(id) function to toggle disassembly / hex dump
    function show_bank(id) {
        var r = _shown.rom;
        var eid ="#FWTOBANK" + id;
        var s = _q(eid);
        var str = s.innerHTML;
        var eid ="#BANK_" + id;
        if (str.lastIndexOf("HEX DUMP") > 0)
        {
            s.innerHTML = str.replace("HEX DUMP", "DISASSEMBLY");
            var entries = [r.rom_init, r.rom_coldstart];
            _h(eid, xex_dump("ROM Cartridge", r.romData, r.romBankMap[id].offset, r.romBankMap[id].len, "ROM_" + hex(id,2), r.romBankMap[id].start, entries));
        }
        else
        {
            s.innerHTML = str.replace("DISASSEMBLY", "HEX DUMP");
            _h(eid, "\n" + hex_dump(r.romData, r.romBankMap[id].offset, r.romBankMap[id].len, (r.romBankMap[id].start + id)));
        }
    }
    //(PVB END OF ADD)

    //(PVB MOD) improvement of function ext_option() add the enabling/disabling list fields when required
    function ext_option(f) { //(PVB COM) ext_option(f) function is called by render_file(f) for the selection list of ext types 
        //(PVB ADD) The enable table of extension for the selection list of ext types
        var _entable = { //list of f.type, normaly set by get_type()
            "isArc" :     [0,0,0,0,0,0, 1,1, 0, 0,0,0,0,0,0,0,0,0,0, 0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0, 0,0,0,0,0, 0,0,0,0],
            "isDisk" :    [1,1,1,1,1,1, 1,0, 0, 0,0,0,0,0,0,0,0,0,0, 0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0, 0,0,0,0,0, 0,0,0,0],
            "isRaw" :     [1,1,1,1,1,1, 1,1, 0, 1,1,1,1,1,1,1,1,1,1, 0, 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, 0, 1,1,1,1,1, 1,1,1,1],
            "isFile" :    [0,0,0,0,0,0, 1,0, 0, 1,1,1,1,1,1,1,1,1,1, 0, 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, 0, 1,1,1,1,1, 0,0,0,0],
            "isTxtImg" :  [0,0,0,0,0,0, 1,0, 0, 1,1,1,1,1,1,1,1,1,1, 0, 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, 0, 1,1,1,1,1, 0,0,0,0],
            "isRomdump" : [0,0,0,0,0,0, 1,0, 0, 0,0,0,0,0,0,0,0,0,0, 0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0, 0,0,0,0,0, 1,1,1,1]
        };
        if (f.type == "isDisk" || f.type == "isRomdump" ) { //only enable the original extension type of the isDisk, disable the others (because changing ext type doesn't work)
            var chkext = f.original_ext ? f.original_ext : f.ext;
            switch (chkext) {
                case 'atr': _entable["isDisk"].splice(0, 5, 1, 0, 0, 0, 0); break;
                case 'atx': _entable["isDisk"].splice(0, 5, 0, 1, 0, 0, 0); break;
                case 'pro': _entable["isDisk"].splice(0, 5, 0, 0, 1, 0, 0); break;
                case 'xfd': _entable["isDisk"].splice(0, 5, 0, 0, 0, 1, 0); break;
                case 'dcm': _entable["isDisk"].splice(0, 5, 0, 0, 0, 0, 1); break;
                case 'dsk': _entable["isDisk"].splice(0, 5, 0, 0, 0, 1, 0); break;
                case 'bin': _entable["isRomdump"].splice(47, 4, 1, 0, 0, 0); break;
                case 'rom': _entable["isRomdump"].splice(47, 4, 0, 1, 0, 0); break;
                case 'a52': _entable["isRomdump"].splice(47, 4, 0, 0, 1, 0); break;
                case 'car': _entable["isRomdump"].splice(47, 4, 0, 0, 0, 1); break;
            }
        }
        var e = f.ext == '???' ? "dat" : f.ext; //(PVB MOD) force extension "???"" to be a "DAT" in the list
        var s = `<div style='display:inline-block'><label>Ext Type :<select onchange="show_as(this.value)" title="...you can try to change type" name="ext_type" ${f.empty ? "disabled" : ""}>`;
        //(PVB MOD) Add display of extension in the list
        var i = 0;
        Object.keys(_exts).forEach(ext => s += `<option ${_entable[f.type][i++] ? "" : "disabled"} value='${ext}' id='id_${ext}' ${ext == e ? 'selected' : ''}>${_exts[ext].name} ${ext[0] == '-' ? "" : " (" + ext + ")"}</option>`);
        s += `</select></label></div>`;
        return s;
    }

    //(PVB ADD) rom_option(f) function is called by render_file(f) for the selection list of ROM types
    function rom_option(f) {
        var s = `<label>Rom Type Selection: <select id="rommapid" onchange="apply_rommap(${f.id})">`;
        var k = f.rom.romKBSize;
        var t = f.rom.romTypeTxt;
        Object.keys(_romtypes).forEach(r =>
            s += `<option ${((r[5] == '#') || (_romtypes[r].size != k)) ? "disabled" : ""} value='${r}' ${(r == t) ? "selected" : ""}>
                ${r + ": " + _romtypes[r].name + " [" + _romtypes[r].machine + "]"}</option>`);
        s += `</select></label>`;
        return s;
    }
    //(PVB END OF ADD)

    function finfo(f) { //(PVB COM) finfo(f) function is called by render_state(m)
        var t = _exts[f.ext] ? _exts[f.ext].name : "'" + f.ext + "' file";
        return `<b>${f.name}</b><div style="font-size:small">${t} (${f.data.length} bytes)</div>`;
    }

    function redraw_palette() {
        _h(".palette", palette(_palette));
    }

    function pick_click(c, i) {
        _palette[c] = i;
        _reload_palette = 0;    // make sure our changes take
        refresh();
        redraw_palette();
        _reload_palette = 1;
    }

    var atari2css = (i) => '#' + hex(atari_palette_rgb[i], 6);
    function palette(colors) {
        function atari256(c) {
            var s = [];
            for (var i = 0; i < 256; i++)
                s.push(`<div class='acolor' title='${hex(i)}' onclick='pick_click(${c},${i})' style='background:${atari2css(i)}'></div>`);
            return s.join("");
        }
        var s = [];
        for (var c = 0; c < colors.length; c++) {
            s.push(
                `<div class='dropdown'>
                <div class='acolor' title='${hex(colors[c])}' style='background:${atari2css(colors[c])}'>
                    <div class='dropdown-content'>${atari256(c)}</div>
                </div>
            </div>`
            );
        }
        return s.join("");
    }

    function pick_mono(cr) {
        _mono_cr = cr;
        _radios["scheme"].value = 0;    // mono
        refresh();
    }

    function refresh_image_controls(f) {
        function monochrome() {
            var s = '';
            for (var i = 0; i < 16; i++) {
                var c = (i << 4) | 8;
                s += `<div class='acolor' title='${hex(c)}' onclick='pick_mono(${c >> 4})' style='background:${atari2css(c)}'></div>`;
            }
            return s;
        }
        _h("#image_controls", `
    <div class='exts' style="padding:8px">
        <div><b>dither</b><span class='radio'>${radio_init('dither', ['atkinson', 'floyd-steinberg', 'noise', 'ordered', 'none'])}</span><div><br />
        <div><b>scheme</b><span class='radio'>${radio_init('scheme', ['monochrome', 'r:g', 'random', 'kmeans', 'octree', 'median'])}</span><div><br />
        <div><b>monochrome</b><span style='padding-left:12px'>${monochrome()}<span><div><br />
        <div><b>distance</b><span class='radio'>${radio_init('distance', ['rgb', 'yiq', 'y'])}</span><div><br />
    </div>`);
    }

    function render_state(m) { //render_state(m) is mainly called by the main load() function, for containers 'm' displayed on page left, after loaded a file on the Client
        //(PVB COM) rendering = display the content at the left side of the HTML page (#menu_container) + init the right side if no file loaded
        var h;
        if (m.length == 0) {
            h = `<div style="text-align:center;color:#AAA"><h2>Drag Files Here</h2><h2>or</h2></div>`;
            _h("#tabs", "");
            _shown = null; //reset the content of the _shown global variable
        } else //(PVB COM) display the file name, the type, and the size on the left, above the file list (this is the container)
            h = m.map(container =>
                `<div>
            <span class='close-icon' onclick="close_container(${container.id})"></span>
            <div class='infof'>${finfo(container)}</div>
            <ul id="menu">
            ${container.files.map(file =>
                    `<li onclick="show(${file.id})">
                    <div><canvas id="canvas${file.id}"></canvas></div>
                </li>`
                ).join("")}
            </ul>
        </div>`
            ).join("");
        _h("#menu_container", h);

        //(PVB MOD) info(f) function improvement, DOS 3 support
        function info(f) {//info(f) is called by render_state(m), to display file characteristics on top left above file display
            //(PVB COM) f = DOS file from the Atari DOS file table
            //in case of single file, function load_one() initializes f.total with the KB or B size, like "17KB" for exemple
            //in case of mutiple files, load_data()->get_dir() initializes each file with DOS-number-of-blocks in f.total 
            var sLine = '';           //"0000000001111111111222"
            //(PVB COM) sLine format is "1234567890123456789012"
            //(PVB COM)             for ".*<FILENAMEext>.tXXX.."
            var nFile = f.gname83 ? f.gname83 : f.name83; // DOS original filename (or number of sector for disk size if the container file is the "isDisk")
            //(PVB ADD) the different type of DOS
            var isDos34XE = f.dosType == 3 || f.dosType == 4 || f.dosType == 5; //DOS3 or DOS4 or DOSXE
            var isSparta = f.dosType == 0;
            var isStdDos = !isDos34XE && !isSparta;
            //(PVB MOD)
            if (f.total) { //if the variable total exists and not equal to zero, display f.total in KB, B or in Secteurs size
                sLine += f.total; //(PVB COM) we start the string line from the end where the size in KB or B is displayed
                if (!isNaN(f.total)) { //padding of the DOS file size on 3 digit numbers with 0 at beginning...
                    if  (f.total <= 999) {
                        while (sLine.length < 3) sLine = '0' + sLine; //add 0 at the beginning
                        sLine = " " + sLine; //add 1 space at the beginning
                    } //else, for more than 999 blocks (case for Sparta, myDos...) nothing to do, use the thousand t at 17th digit => tXXX
                    sLine += "  "; //add 2 spaces at the end
                }
                else {  //(PVB MOD) padding the file size in B or KB to 6 total char, with space at the beginning
                    while (sLine.length < 6)
                        sLine= " " + sLine; //add space at the beginning
                }
            }
            else { //(PVB COM) there is no f.total: it's the spacer line or the total number of sector of disk to display
                //note : if f.total is 0, it means an empty file and this file is not listed in the "files" array to be displayed (see load_data())
                sLine = "   " + nFile; //nFile is empty, or nFile is the total sector on the disk
                while (sLine.length < 22) // we pad it at 22 chars
                    sLine = sLine + ' '; // padding with space
                return sLine;   // and directly display it
            }
            //(PVB MOD) nFile = f.names83, contains the DOS filename, we pad it on 11 chars
            while (nFile.length < 11)
                nFile += ' ';
            //(PVB MOD) Add the DOS flag management according to DOS type
            var locked = " ";
            if ((isDos34XE && (f.flags & 0x02)) || isStdDos && (f.flags & 0x20) || isSparta && (f.flags & 0x01))
                locked = "*"; // '* filename.ext' for locked DOS file (non erasable)
            //(PVB MOD) Add the DOS "Opened File" from 1st bit and display it as in DOS2.5 with <> chars, like "<filename>"
            if (!isSparta && (f.flags == 0x80) || isSparta && (f.flags & 0x10)) {  //deleted file
                return " " + " " + "[" + nFile + "] " + sLine; // '[filen.ame]' for erased DOS file
            }
            else if (isStdDos && (f.flags & 0x01) || (f.dosType == 5 && (f.flags & 0x04))) {
                return " " + locked + "<" + nFile + "> " + sLine; // '<filen.ame>' indicates an open DOS file for DOS2, or a file stored above sector 720 for DOS2.5
            }
            else if (f.dosType > 5 && (f.flags & 0x10)) {
                return " " + locked + ":" + nFile + "  " + sLine; // MyDOS directory
            }
            else if (f.dosType == 5 && (f.flags & 0x01)) {
                return " " + locked + " " + nFile + "> " + sLine; // MyDOS directory
            }
            else {
                return " " + locked + " " + nFile + "  " + sLine; // normal DOS file
            }
        }
        //(PVB END OF MOD)

        m.forEach(container => {
            container.files.forEach(file => draw_line(`#canvas${file.id}`, info(file), file.recovered, file.is_dir));
        });

        // if no containers (no opened file), then display all supported file types and extensions from _exts list object
        if (m.length == 0) {
            var s = `<div class='exts'>`; //see .exts in the style sheet
            Object.keys(_exts).forEach((ext) => {
                s += (ext[0] == '-') ? `<div><b> </b><strong>${_exts[ext].name}</strong></div>` : `<div><b>${ext}</b>${_exts[ext].name}</div>`;
            });
            s += `</div>`;
            _h('#tabs', s);
            reset_tools(); //(PVB ADD) disable tool bouttons as no file is displayed
        }
        else {
            set_tool("H", true); //(PVB ADD) enable "H" boutton as a file is displayed
            set_tool("M", true); //(PVB ADD) enable "M" boutton as a file is displayed
        }
    }
  
    //(PVB ADD) render_extract(f, isDisk) function is for rendering extract menu only, called by render_file(f) function
    function render_extract(f, isDisk) {
        var ipb = `input class='btnstyle' type='button' `;
        var str = `pattern='[0-9a-fA-F]{1,6}' placeholder='0...FFFF' title='Address in valid hex code 0...FFFF'`;
        var strdh = `pattern='[$0-9a-fA-F]{1,4}' title='Enter dec number, or hex number starting with $'`;
        var addmenu = `
    <div class='extract'><form id='hexmenu' onsubmit='return extract_disass(${isDisk ? f.atr.sector_size : ("0," + f.data.length)});'><fieldset>
      <legend><b>Extract data from ${isDisk ? "disk sectors" : "file data"} and disassemble Menu: </b></legend>
      <div style='display:flex; justify-content:space-between'>
        <div>`;
        if (isDisk) { //Sectors selection
            if (!f.extracted_disk) f.extracted_disk = _extracted_disk;
            addmenu += `<div>
            <label for='start_sect'>Start sector: </label>
            <input size='5' type='text' id='start_sect' name='start_sect' ${strdh} value='${f.extracted_disk.start_sect}'>
            <label for='end_sect'> =&gt to end sector: </label>
            <input size='5' type='text' id='end_sect' name='start_sect' ${strdh} value='${f.extracted_disk.end_sect}'>
                <span> <em>(use $ for hexa number)</em> [Valid values from 1 to $${hdx(f.atr.sector_count)} (${f.atr.sector_count})]</span><br />
            <label for='start_sect_off'>Offset Byte in start sector: </label>
            <input size='3' type='text' id='start_sect_off' name='start_sect_off' ${strdh} value='${f.extracted_disk.start_sect_off}'>
                <span> <em>(use $ for hexa number)</em> [Valid value from 0 to $${hdx(f.atr.sector_size - 1)} (${f.atr.sector_size - 1})]</span>
          </div>`;
        }
        else { //this is not a file with Sectors, so Select from data index and not sector
            if (!f.extracted_file) {
                f.extracted_file = _extracted_file;
                f.extracted_file.end_offset = f.data.length-1; //to initialize value
            }
            addmenu += `<div>
            <label for='start_offset'>Start Offset at (hexa): $</label>
            <input size='6' type='text' id='start_offset' name='start_offset' ${str}
                value='${hdx(f.extracted_file.start_offset)}'><span> <em>(Min $0) </em></span><br />
            <label for='end_offset'>End Offset at (hexa): $</label>
            <input size='6' type='text' id='end_offset' name='end_offset' ${str} 
                value='${hdx(f.extracted_file.end_offset)}'><span> <em>(Max $${hex(f.data.length-1, 6)}) </em></Span><br />
          </div>`;
        }
        //now add input of Start Address
        addmenu += `
            <label for='start_add'>Disassembly start at (hexa): $</label>
            <input size='4' type='text' id='start_add' name='start_add' ${str}
                value='${isDisk ? hdx(f.extracted_disk.start_add) : hdx(f.extracted_file.start_add)}'>
                <span> [Valid value from $0 to max $FFF9]</Span><br />
            <div id='extractinfo' class='extractinfo' style='color:#F00'></div>
          </div>`;
        //now add text area, and normal buttons
        addmenu += `  
          <div style='display: flex; flex-direction: column; align-items: flex-end; justify-content: space-between;'>
            <div><input class='btnstyle' style='font-weight: bold; width:118px; text-wrap:auto;' type='submit' value='=> EXTRACT & DISASSEMBLE'></div>
            <div><${ipb}id='cancel_extract' value='CANCEL EXTRACT' onclick='extract_reset()' ${f.extract_launched ? '' : 'disabled'}></div>
          </div>
        </div>`;
        //now the extract saving buttons - and close form
        addmenu += `  
        <div><fieldset>
          <legend><b>Extract saving buttons: </b></legend>
          <div style='display:flex; justify-content:space-between;'>
            <${ipb}id='save_extract' title='as raw data in a DAT file' value='Download extracted data' onclick='save_as_extract(4)' ${f.extract_launched ? '' : 'disabled'}>
            <${ipb}id='extractconv2file' title='adding $FFFF headers & RUNADD at disass. start address' value='Save extract to OBJ file' onclick='save_as_extract(1)' ${f.extract_launched ? '' : 'disabled'}>
            <${ipb}id='extract2boot' title='extract is a 720-SD boot disk, nbr of sectors is computed' value='Save extract into ATR disk' onclick='save_as_extract(3)' ${f.extract_launched ? '' : 'disabled'}>
            <${ipb}id='extractconv2boot' title='computing & adding 6 boot bytes on a720-SD boot disk' value='Convert & Save extract into ATR disk' onclick='save_as_extract(2)' ${f.extract_launched ? '' : 'disabled'}>
          </div>
        </div></fieldset>
      </div>
    </fieldset></form></div>`;
        return addmenu;
    }
    //(PVB END OF ADD)

    //(PVB ADD) showDisOption() function is for rendering disassembly option menu only, called by render_file(f) function
    function showDisOption() {//showDisOption() is called by render_file() for disassembly and dump display options
        // _dof: display option iniialization, used to redraw check buttons
        var _dof = [
            ["cShowAtasciiChar", _bShowAtasciiChar, "Show Atari ATASCII charset"],
            ["cShowDispChar", _bShowDispChar, "Show ANTIC Internal charset"],
            ["cShowROMBank", _bShowROMBank, "ROM: Show addresses with Rom bank number [n00..FF] index"],
            ["cShowDisLinks", _bShowDisLinks, "DIS: Show disassembly destination address in hyperlinks"],
            ["cShowDisBRK", _bShowDisBRK, "DIS: Accept code disassembly with up to 2 BRK instructions"],
            ["cShowA5200Eq", _bShowA5200Equates,"DIS: Use Atari 5200 OS equates instead of 800/XL/XE equates"],
            ["cShowDisFlags", _bShowDisFlags, "DIS: Show disassembly code flags (webpage js info for dev.)"]
        ];
        var tmpstr = `<div><form id='disoptionform' class='doblock'>`; //Start of block Form
        //(PVB TODO) check to add "${_bShowAtasciiChar ? "disabled" : ""}" for disabling Option Buttons according to displayed cases
        //(like disable ROM bank display button if no rom is displayed...)
        tmpstr += `<div><fieldset><legend><b>Dump & Disassembly options: </b></legend>`; //First fieldset
        tmpstr += '<div>';
        for (var i = 2; i < _dof.length; i++) { //start at 2, for disassembly option
            _checks[_dof[i][0]] = _dof[i][1];
            tmpstr += `<div class='radio'>` + check_init(_dof[i][0], _dof[i][2]) + '</div>';
            //previously for one line/one button//tmpstr += '<div class="radio">' + check_init(_dof[i][0], _dof[i][2]) + '</div>';
        }
        tmpstr += '</div>';
        tmpstr += `</div></fieldset>`; //End of first fieldset
        //tmpstr += `<div class='doradgrp'><fieldset><legend><b>Listing display font options: </b></legend><div class='radio'>`;
        tmpstr += `<div>`; //Start of 2nd block of fieldsets
        tmpstr += `<div><fieldset><legend><b>Listing display font options: </b></legend><div>`; //Second fieldset
        tmpstr += `${radio_init('atarichlist', ['Normal Dump with Atari Font', 'Dump with monospace Webfont', 'Display all with Atari Font'], null, true)}</div>`;
        tmpstr += '</div></fieldset>'; //End of second fieldset
        tmpstr += `<div><fieldset><legend><b>Hex Dump Charset display: </b></legend><div>`; //Third fieldset
        for (var i = 0; i < 2; i++) {
            _checks[_dof[i][0]] = _dof[i][1];
            tmpstr += `<div class='radio'>` + check_init(_dof[i][0], _dof[i][2]) + '</div>';
        }
        tmpstr += '</div></fieldset>'; //End of third fieldset
        tmpstr += '</div>'; //End of 2nd block of fieldsets
        tmpstr += '</form></div>'; //End of block Form

        _h("#disoption", tmpstr); //set the display option menu in the screen buffer
        toggle_disoption(true); //and force display of the display option menu

        //adjust the display of the different font listing 
        var preShow = _g("show"); //only for "pre #show"
        var stylesheet = document.styleSheets[0];
        var preData = [...stylesheet.cssRules].find(
            (r) => r.selectorText === "pre data",
        );
        if (_bShowAtariFont) { //all in Atari font
            preShow.style.cssText += "color: #005; background-color: #EEE; font-size: 12px; line-height: 14px; font-family: 'Atari'";
            preData.style.fontFamily = "'Atari'";
            preData.style.fontSize = "12px";
            preData.style.fontWeight = "normal";
        } //else thanks to refresh() "pre #show" has no specific type, CSS style of "pre" applied
        else if (_bShowWebChar ) { //"pre data" with standard Monospace web font for data and hex dump
            preShow.style.fontSize = "13px"; //adjust pre font
            preShow.style.lineHeight = "14px";
            preData.style.fontFamily = "'Noto Sans Mono', monospace";
            preData.style.fontSize = "12px";
            preData.style.fontWeight = "bolder";
        }
        else { //default "pre data" with Atari font for data and normal font for hex dump
            preShow.style.fontSize = "13px"; //adjust pre font
            preShow.style.lineHeight = "13px";
            preData.style.fontFamily = "'Atari'";
            preData.style.fontSize = "10px";
            preData.style.fontWeight = "normal";
        }
    }
    //(PVB END OF ADD)

    //(PVB MOD & ADD) add improvement for the addition of Extract, disassembly and ROM menus
    function render_file(f) { //render_file(f) is called by functions like show_rom(), show_atr ()...
        //(PVB COM) rendering = display the content at the right side of the HTML page (id #tabs DIV container)
        // on top : Class .info
        // on bottom : DIV #file
        var isCode = (_exts[f.ext] ? _exts[f.ext].is_code : false) || false;
        var isTxt = (_exts[f.ext] ? _exts[f.ext].is_txt : false) || false; //(PVB ADD) to force true or false, and not undefined
        var isImg = _exts[f.ext] ? _exts[f.ext].is_img : false;
        var isFnt = _exts[f.ext] ? _exts[f.ext].is_fontset : false; //(PVB ADD AND MOD) //previously // f.ext == 'fnt' //
        f.isSearchable = isImg || isFnt || false; //allow the "search picture and font" flag into file flag  
        
        var isNwExt = (f.original_ext && f.original_ext != f.ext) ? true : false;
        var pre = !isTxt && !isImg && !isFnt;
        var isRomdump = f.type == "isRomdump";
        var isDisk = f.type == "isDisk";
        f.isExtractable = pre && (f.type != "isArc") && !f.empty; //allow the "extract file data" flag into file flag
        
        //Special cases to force and display the file Hex dump
        if (f.forceHexDump) {
            pre = true;
            isTxt = false;
            isImg= false;
            isFnt= false;
        }
        var controls = `<div class='radio' title='contextual display options (number of columns, colors...)'>`;
        var buttons = ''; //displayed text saving buttons
        var button1 = ''; //Atari Files, ATR, XFD, ROM or CART saving buttons
        var button2 = ''; //file extension management saving buttons
        var imageinfo = ''; //text about the Ext Type and file Type
        var addmenu = ''; //additionnal menu for ROM image or for Extract menu
        var romtxt = ''; //Rom image type text
        var ctrldat =''; //DAT file convertion to XFD/ATR button
        var hexsizetxt = "($" + hdx(f.data.length) + ") bytes";
        //(PVB ADD) compute and display checksum
        var c;
        if (isDisk) c = calChkSum(f.atr.d, 16);
        else if (isRomdump) c = calChkSum(f.rom.romData, 16);
        else c = calChkSum(f.data, 0);
        var chksum = " [chksum $" + hdx (c) + "] "; //Checksum string
        //[controls] buttons
        if (isTxt || isFnt) { //[controls] are to modify the display of Text or Font
            controls += `
                ${f.ext == 'bas' ? check_init('indent', 'Indent') : ""}
                ${isFnt ? check_init('multicolor', 'Multicolor') : ""}
                ${radio_init('layout', ['38', '40', '80', 'Wide'])}`;
        }
        if (isFnt || (isImg && is_palettable(f.ext))) { //previously //if (f.ext == 'fnt') || ...
            controls += `<div class='palette'>${palette(_palette)}</div>`; //[controls] are to modify the display of Img
        } 
        controls += `</div>`;
        //(PVB ADD) [buttons] buttons for saving purpose
        var ot = "<button class='btnstyle' type='button' ";
        if (pre) { //[buttons] are for displayed text saving, when it is not Text, nor Img, nor Font
            buttons += `${ot}title='=Client text file, as displayed' onclick='save_disassembly(0)'>Save listing as .txt</button>`;
            buttons += `${ot}title='=simple HTML, no CSS, no Atari char; better with Webfont Dump setting' onclick='save_disassembly(1)'>Save listing as .html (without html style)</button>`;
            buttons += `${ot}title='=with CSS style, keeping Atari char if displayed; use Normal Dump setting' onclick='save_disassembly(2)'>Save listing as .html (Atari font included)</button>`;
        }
        if (isTxt) { //[buttons]  are valid for Text only, not fot Immg, nor Font
            buttons += `${ot}title='=convert & save code listing into Client UTF text' onclick='save(2)'>Save as UTF text</button>`;
            buttons += `${ot}title='=take a PNG screenshot of the code listing' onclick='save_as_png()'>Save as PNG Image</button>`;
            buttons += `${ot}title='=save (modified) code listing into Atari LST text file' onclick='save(1)'>Save as Atari LST</button>`;
        }
        //(PVB ADD) Info and inputs display for Rom Management Menu
        if (isRomdump) {
            if (f.rom.oldRomType === undefined) //First iteration - no orignal CART type saved
            {
                if (f.rom.romType === 0) {
                    romtxt = `<strong>Info:</strong> ROM image file has no CARTridge identification header: <strong>` + f.rom.romName; 
                    romtxt += `</strong><br />You can choose a relevant mapping type from the list (which displays the best possible matches) and download the new CART file.`;
                }
                else {
                    romtxt = `<strong>Info: "` + f.rom.romName + `"</strong> type has been identified in the ROM image file CARTridge header.`;
                    romtxt += `<br />No need to change its mapping type from the list, but you can try.`;
                }
            }
            else { //Second iteration - there is an original CART type saved
                if (f.rom.oldRomType > 0)
                    romtxt = `<strong>Reminder:</strong> Original ROM image file CARTridge type was: <strong>"` + f.rom.oldRomName + `"</strong>`;
                else
                    romtxt = `<strong>Reminder:</strong> ROM image file has no CARTridge header.<br />You can choose a relevant mapping type from the list, and download the new CART file.`;
            }
            addmenu = `
            <div class='rommap'>
                <div id='rominfoid' class='rominfoid'>${romtxt}</div>
                <fieldset>
                <legend><b>ROM Memory Bank mapping type selection (75 first types):</b> <a href='https://github.com/atari800/atari800/blob/master/DOC/cart.txt' target='_blank'>(see information link here)</a>
                </legend>
                <div style='display:inline-block; overflow:auto;'>${rom_option(f)}</div>
                <div style='padding-top:4px;'><i>Please note that Emulationstation/ emulators may not support last rom types above 60 - so try it !</i></div>
                </fielset>
            </div>`;
            tmpromsize = f.data.length >> 10;
            hexsizetxt += " = " + tmpromsize + "KB ROM ";
        }
        //(PVB ADD) Render the Extract Menu if requested by clicking the tool E
        if (f.isExtractable) {
            set_tool("E", true);
            if (f.extract_menu_request) addmenu += render_extract(f, isDisk);
        } 
        else { 
            set_tool("E", false);
        }
        //(PVB ADD) [button1] management for Atari Files, ATR, XFD, ROM or CART saving buttons
        if (isRomdump) { //special buttons to save new CART header in a ".car" file...
            if (f.rom.isCart || f.rom.restructured) //...if it is a CART 
                button1 += ` <button type='button' title='=without CART header' onclick='save_wo_header()'>Download raw ROM</button>`;
            button1 += ` <button type='button' title='=adding the CART header' onclick='save_as_cart()' ${((!f.rom.isCart && f.rom.romType) || (f.rom.isCart && f.rom.oldRomType)) ? '' : 'disabled'}>`;
            button1 += `Download new CART</button>`;
        }
        else { //Atari file, ATR or XFD saving buttons
            var db = isDisk && f.atr && (f.atr.restructured || f.atr.buggy || f.atr.bModif || f.atr.forcedExt || f.atr.newDisk); //force both XFD and ATR buttons when ATR disk image has been modified
            if (!isDisk) //no use to save original file as this is the disk image file that has been loaded
                button1 += `<button type='button' title='=extract it if from disk image, or re-save original file' onclick='save(0)'>Download original Atari file</button>`; 
            //(PVB ADD) Add a Save Buttons for saving XFD/ATX/PRO/DSK into ATR, and ATR/ATX/PRO/DSK into XFD
            //(PVB COM) We know that we have in memory a disk file always converted in ATR
            if (db || isDisk && f.ext !="atr") { 
                //so we can save it into ATR if it was an XFD for instance
                button1 += `<button type='button' title='=convert to ATR disk image (with ATR header)' onclick='save_as_dsk("ATR")'>Download ATR file</button>`; 
            }
            if (db || isDisk && f.ext !="xfd") {
                //so we can save it into XFD if we remove ATR 16-bytes header
                button1 += `<button type='button' title='=convert to XFD disk image (no ATR header)' onclick='save_as_dsk("XFD")'>Download XFD file</button>`; 
            }
        }
        //(PVB ADD) set the "imageinfo" text about the Ext Type and file Type
        var oext = f.prevext ? f.prevext : f.original_ext;
        if (isRomdump)
            imageinfo += `<div><em>INFO: Dump image file <b>Ext type</b> was automatically set and can only change to 'DAT' type</em></div>`;
        else if (isDisk && !f.original_ext) {
            if (f.atr.orginalATR != "ATR" && f.atr.orginalATR != "XFD" && f.atr.orginalATR != "DSK" && !f.atr.restructured) {
                imageinfo += `<div><em>INFO: The '${f.atr.orginalATR}' original disk image file has been converted into an ATR by the tool</em></div>`;
            }
        }
        else if (f.type == "isRaw" && f.forcedDat)
            imageinfo += `<div><em>INFO: the '${oext}' disk image type signature for the file given extension was not found, so file is displayed as 'DAT'</em></div>`;
        //(PVB ADD) [button2] is when a new XFD is created, and for 'changing extension and reset type button' management
        if (f.ext == 'xfd' && f.forced_ext) button2 += `INFO: The new XFD/ATR disk image file has been created!`;
        else if (isNwExt || f.forced_ext) { //extenion has changed, if by the user then isNwExt is true and then add "reset extension" button
            button2 += `<div  style='overflow: auto;'>`;
            if (isNwExt) //if isNwExt, then the new ext is  requested by the user
                button2 += `INFO: File extension type has been changed from '${oext}' to '${f.ext}' in Ext Type list...`;
            else if (f.forced_ext) //if ext was forced by get_ext()
                button2 += `<em>INFO: File extension is modified to '${f.ext == '???' ? 'DAT' : f.ext}' to display the closest file type</em>`;
            button2 += `<div style='float: right;'>
                        <button type='button' title='download file with new extension' onclick='save_as_new()'>Download new ext file</button>
                        ${isNwExt ? "<button type='button' title='cancel type change' onclick='reset_type_button()'>Reset ext type</button>" : ""}</div>`;
            button2 += '</div>';
        }
        //(PVB ADD) [ctrldata] button to create a XFD the DAT file raw data
        if (f.type == 'isRaw' && ((f.original_type && f.original_type != "isDisk") || (!f.original_type)))
            ctrldat = `<div style='float: right; margin-left: 8px;'><button type='button' title='create a new XFD/ATR disk image from the raw data' onclick='create_atr()'>Create XFD/ATR from DAT</button></div>`;
        //(PVB end of ADD)

        _h("#tabs",
        `<div class='info'>
            <div style='overflow: auto; padding-bottom: 4px;'><b>${f.name}</b>
                <div style='float: right'>${button1}</div>
            </div>
            <div style='padding-bottom: 6px;'> ${ext_option(f)} ${f.data.length} ${hexsizetxt} ${chksum} ${ctrldat}</div>
            <div style='padding-bottom: 3px;'> ${imageinfo} ${button2}</div>         
            <div style='border-top: solid 1px #AAC; padding-top: 8px'> ${buttons}
                <div style='float: right; padding-top: 2px'>${controls}</div>
            </div>
        </div>
        ${addmenu}
        <div id='search_controls' style='font-size: 12px;'></div>
        <div id='file'>
            <div>
                ${pre ? `<pre id='disoption'></pre><pre id='show'></pre>` : ''}
                ${isImg || isFnt ? `<canvas id='show' title='Right click to save pic'></canvas>` : ''}
                ${isTxt ? `<div contenteditable='true' spellcheck='false' class='atari' id='atari_text'></div>` : ''}
            </div>
            <div id='image_controls'></div>
        </div>`
        );

        if (f.edit_img)
            refresh_image_controls(f);

        //(PVB ADD) //render the Option Menu if requested by clicking the tool "P"
        if (pre) {
            set_tool("P", true);
            showDisOption(); //disassembly and dump display option is initialized, and displayed, according to flags as global variables.
        }
        else {
            set_tool("P", false);
        }
        //(PVB ADD) //render the Search Menu if requested by clicking the tool "S"
        if (f.isSearchable) {
            set_tool("S", true);
            if (f.searchrequest) { _h('#search_controls',
        `<fieldset><legend>Search Menu:</legend><div><button type='button' onclick='s_c(4)'>+$1000</button> <button type='button' onclick='s_c(3)'>+$100</button>
        <button type='button' onclick='s_c(2)'>+$10</button> <button type='button' onclick='s_c(1)'>+$1</button></div>
        <div><button type='button' onclick='s_c(-4)'>-$1000</button> <button type='button' onclick='s_c(-3)'>-$100</button>
        <button type='button' onclick='s_c(-2)'>-$10</button> <button type='button' onclick='s_c(-1)'>-$1</button></div>
        <button type='button' onclick='s_c(0)'>Reset Search</button><span> Search Offset in Datafile: $${hdx(_shown.offst)}<br /></fieldset>`);
            }
        }
        else set_tool("S", false);
    }

    var _keyboard;
    function render_kb(vis) {
        var kb = _q(".keyboard");
        if (!_keyboard) {
            var s = `<div>`;
            for (var y = 0; y < 16; y++) {
                s += '<div>';
                for (var x = 0; x < 16; x++)
                    s += '<span title="$' + hex(y*16+x) + '">' + String.fromCharCode(x + y * 16 + 0xE000) + '</span>'; //(PVB ADD) the title = display the hexa code
                s += '</div>';
            }
            kb.innerHTML = s;
            kb.onclick = e => keyboard(e.target.innerText);
            _keyboard = kb;
        }

        //vis = vis && _q("#atari_text");
        kb.style.display = vis ? "block" : "none";
        keyboard();
    }

    function toggle_kb() {
        render_kb(_q(".keyboard").style.display != "block");
    }
    function set_tool(name, v) {
        set_class(_q("#" + name), "dimmed", !v);
    }
    
    //(PVB ADD) Reset tools function to disable / dim all tools
    function reset_tools() {
        var tl = ['H', 'P', 'E', 'S', 'M'];
        tl.forEach(t => _q("#" + t).classList.add("dimmed"));
    }
    //(PVB End of ADD)
    //(PVB MOD) Add the P for Print & Display Option, E for Extract and S for Search menus, M for Modify
    function floater(evt) {
        var t = evt.target.innerText;
        if (t == String.fromCharCode(0xE000)) //Heart Symbol
            toggle_kb();
        else if (t == "I")
            invert_selection();
        else if (t == "D")
            disassemble_selection();
        else if (t == "O")
            open();
        else if (!_shown) //if no file shown then do nothing for following buttons
            return;
        else if (t == "H")
            toggle_hex();
        //(PVB ADD) the 'P' menu for Display and Print Option Menu
        else if (t == "P") 
            toggle_disoption(false);
        //(PVB ADD) the 'E' menu for Extract Menu
        else if (t == "E") 
            toggle_extract();
        //(PVB ADD) the 'S' menu for Search Menu
        else if (t == "S")
            toggle_search();
        //(PVB ADD) the 'M' menu for Modify Menu
        else if (t == "M")
            modify_file_control();
        //(PVB end of ADD)
    }
    //(PVB ADD) display_HexEditor(s) function is called to display or hide the Hex Editor
    function display_HexEditor(s) {
        if (s) { //display on
            _h("#file", "");
            str = `<iframe class="hexed" src="atari8-bits_hex_editor.html" name ="hexed" id="hexedid" title="Hex Editor" onload=hexEdLoaded()></iframe>`;
            _h("#hexedframeid", str);
            console.log(">modify_file ==> Hex Editor activated");
            _bHexEd = true;
        }
        else{ //display off
            _h("#hexedframeid", "");
            _g("hexedframeid").style.height = "0px";
            console.log(">modify_file ==> Hex Editor desactivated and closed!");
            _bHexEd = false;
        }
    }
    //(PVB ADD) modify_file_control() function called by Tool click "M"
    function modify_file_control() {
        var s = _bHexEd; //actual tool status, resquest is the opposite
        display_HexEditor(!s); //toggle it
        if (s) refresh(); //in case of cancel Hex Editor request, refresh display
    }
    //(PVB ADD) function s_c() ///WIP// Search function development in progress
    function s_c(v) {
        if (_shown.dataOld) {
            var sact = v == 0 ? 0 : (Math.sign(v) * Math.pow(16, Math.abs(v)-1));
            console.log(v + "; " + sact);
            var datalen = _shown.dataOld.length;
            if (Math.abs(sact) >= datalen) return;
            if (sact == 0) {
                _shown.data = _shown.dataOld;
                _shown.offst = 0;
            } 
            var datatmp = new Uint8Array(datalen);
            _shown.offst += sact;
            if (_shown.offst >= datalen) _shown.offst -= datalen ;
            if (_shown.offst < 0) _shown.offst = datalen + sact;
            if (sact > 0) {
                datatmp.set(_shown.data.slice(sact, datalen), 0);
                datatmp.set(_shown.data.slice(0, sact), (datalen-sact));
            }
            else {
                datatmp.set(_shown.data.slice((datalen+sact), datalen), 0);
                datatmp.set(_shown.data.slice(0, (datalen+sact)), (-sact));
            }
            _shown.data = datatmp;
            refresh();
        }
    }
    //(PVB ADD) function get_hex(val) purpose is to convert the input text into the corresponding hex number
    function get_hex(val) {
        if (!val)
            val = 0;
        val = "0x" + val;
        return Number(val);
    }
    //(PVB ADD) function get_hex_or_dec(val) purpose is to convert the input text into dec or hex number (if $)
    function get_hex_or_dec(val) {
        const reDec = /[^0-9]/g;
        const reHex = /[^0-9A-Fa-f]/g;
        if (!val)
            return 0;
        if (val.lastIndexOf("$") == -1) { //no $, then it's a decimal
            if(!reDec.test(val))
                return Number(val);
            else return -1; //invalid
        }
        else if (val.lastIndexOf("$") == 0) { //this is hexa, starting with $ (if more than one $ then return value si greater than 0)
            val = val.replace("$","0"); //replace the first $
            if (reHex.test(val)) //hexa check fault (not usefull since we can trust the regex filter from the input field)
                    return -1; //invalid
            val = "0x" + val; // convert value from hexa with 0x...
            return Number(val);
        }
        else return -1; //invalid
    }
    //(PVB ADD) function extract_disass(sectSize, maxSize) is called by HTML event when clicking on "Extract & Disassemble" button
    //f.extract_launched // f.isExtractable // f.extract_menu_request
    function extract_disass(sectSize, maxSize) { 
        var ad = get_hex(_g("start_add").value);
        var txtArea = _g("extractinfo");
        var txt = "";
        if (ad < 0 || ad > 0xFFF9)
            txt += " >Error: check Disassembly Start value (no code after $FFF9)!";
        if (sectSize) { //(PVB COM) for the "disk" extract menu
            //previously//var ss = document.getElementById("start_sect").valueAsNumber;
            var ss = get_hex_or_dec(_g("start_sect").value);
            var so = get_hex_or_dec(_g("start_sect_off").value);
            var es = get_hex_or_dec(_g("end_sect").value);
            if (ss <= 0 || so < 0 || es <= 0)
                txt += " >Error: wrong input for Start, End Sector or Offset value (use '$' for hex number)!";
            else {
                if (ss > es)
                    txt += " >Error: Start Sector greater than End Sector!";
                if (sectSize > 128 && ss < es && ss < 4 && so > 127)
                    txt += " >Error: wrong Offset value (max $7F (127) for 3 first sectors)!";
                if (ss < es && ss > 3 && so > (sectSize - 1))
                    txt += " >Error: Offset value greater than Sector Size!"; 
                if ((ss == es && ss < 4 && so > 125) || (ss == es && ss > 3 && so > (sectSize - 3)))
                    txt += " >Error: check Offset value (need at least 3 bytes for 1 sector disassembly)!";
            }
            if (txt !== "") {
                txtArea.innerText = txt;
                console.log("extract_disass() =>Wrong number ! start_add:" + ad + ", start_sect:" + ss + ", end_sect:" + es + ", start_sect_off:" + so);
                return false;
            }     
            _shown.extracted_disk = {start_sect: ss, start_sect_off: so, end_sect: es, start_add: ad };
        }
        else { //(PVB COM) for the "file" extract menu
            var so = get_hex(_g("start_offset").value);
            var eo = get_hex(_g("end_offset").value);
            if (so >= maxSize || eo >= maxSize || so > eo || so < 0 || eo < 0)
                txt += " >Error: check Start and/or End Offset value!";
            if (txt !== "") {
                txtArea.innerText = txt;
                console.log("extract_disass() =>Wrong number ! start_add:" + ad + ", start_offset:" + so + ", end_offset:" + eo);
                return false;
            }     
            _shown.extracted_file = {start_offset: so, end_offset: eo, start_add: ad };
        }
        if (_shown) {
            _shown.extract_launched = true;
            console.log("extract_disass() =>_shown:"); //(PVB CONSOLE HINT)
            console.log(_shown); //(PVB CONSOLE HINT)
        }
        refresh();
        return false; //false in order to keep focus on the form with input fields
    }
    //(PVB ADD) extract_reset() function is called by HTML event when clicking on "ReShow Full Hex Dump"
    function extract_reset() {
        if (_shown.extract_menu_request && _shown.extract_menu_request == 1 ) { //Extract menu was displayed, so cancel it
            _shown.extract_menu_request = 0;
            if (_shown.extract_launched) { //An Extract was in progress, so cancel it
                _shown.extract_launched = false;
                delete _shown.extractedData;
                delete _shown.extracted_disk;
                delete _shown.extracted_file;
                _shown.extract_menu_request = false;
            }
            refresh();
        }
        return;
    }
    //(PVB ADD) apply_rommap(id) function is called by HTML event when changing the "ROM Memory Bank mapping type selection"
    function apply_rommap(id) {
        var selectRomType = _g("rommapid").value; //return the selected choice from the list like "Type_03"
        var f = get_file(id);
        var rf = f.rom;
        console.log("apply_rommap() =>Value:"); //(PVB CONSOLE HINT)
        // (PVB COM) note: not possible to change information text in the present apply_rommap() function. The following does not work:
        //txtArea = document.getElementById("rominfoid") and txtArea.innerText = 'REMINDER: Original CART type was ' + rf.romTypeTxt +` (` + rf.romName + `)`;
        //because refresh() is called to display the new selected type, cancelling info => So info text is updated in render_file().
        if (rf.oldRomType === undefined) { //on vient de faire une demande de changer le type
            rf.oldRomType = rf.romType; // sauvegarde de la valeur CART
            rf.oldRomName = rf.romTypeTxt + ": " + rf.romName; // sauvegarde du type + nom original
        }
        rf.romTypeTxt = selectRomType;
        rf.romType = Number(selectRomType.slice(5));
        if (!isNaN(rf.romType)) {//protection of convertion
            rf.romData[7] = rf.romType;
        }
        rf.romName = _romtypes[selectRomType].name;
        rf.romMachine = _romtypes[selectRomType].machine;
        rf.romMap = _romtypes[selectRomType].memmap;

        //in case of changing the rommap type, then update a5200eq and _bShowA5200Equates flags according to romMachine
        if (rf.romMachine == "5200") {
            rf.a5200eq = true;
            _bShowA5200Equates = 1;
        }
        else {
            if (rf.a5200eq) delete rf.a5200eq;
            _bShowA5200Equates = 0;
        }

        console.log(" ...oldRomType = " + rf.oldRomType); //(PVB CONSOLE HINT)
        console.log(" ...selectRomType = " + selectRomType); //(PVB CONSOLE HINT)
        /* this is a code for bank re-ordering.... used for Bounty Bob A5200 ROM
        if (rf.romType == 77) {
            var tmpData = new Uint8Array(rf.romData.length);
            for (var i=0; i < 16; i++)
                tmpData[i] = rf.romData[i];
            for (var i=0; i < 0x2000; i++)
                tmpData[i + 0x8010] = rf.romData[0x10 + i];
            for (var i=0; i < 0x8000; i++)
                tmpData[i + 0x10] = rf.romData[0x2010 + i];
            tmpData[7] = 7;
            rf.tmpData = tmpData;
        }*/
        // now reset_ext() and reset_hexdump() to redisplay the new Rom dump bank map
        reset_ext();
        reset_hexdump();
        refresh();
        return;
    }
    //(PVB End of ADD)

    function draggable(el, name) {
        //(PVB COM) name est par exemple "Donkey Kong.rom disassembly"; el = div.floated.disassembly
        var x0, y0;
        el.querySelector('.draggable').innerText = name;
        el.onmousedown = (e) => {
            e.preventDefault();
            x0 = e.clientX;
            y0 = e.clientY;
            document.onmouseup = () => {
                document.onmouseup = null;
                document.onmousemove = null;
            }
            document.onmousemove = (e) => {
                e.preventDefault();
                var x = x0 - e.clientX;
                var y = y0 - e.clientY;
                x0 = e.clientX;
                y0 = e.clientY;
                el.style.left = (el.offsetLeft - x) + "px";
                el.style.top = (el.offsetTop - y) + "px";
            }
        }
    }
    
    //(PVB ADD) open_mergedfile() function to open a merged Atari Executable file into a new file in the Tool
    function open_mergedfile() {
        load_one(mod_ext(_shown.name, "MERGED"), "xex", _shown.mergedfile, "", "isFile");
        delete _shown.mergedfile;
        refresh_containers();
    }
    //(PVB ADD) launch_test() function to create a new file in the Tool, this file is bytes-filled in order to test the Memory Equate
    function launch_test() { //to launch with CTRL+SHIFT+J
        alert("PVBest welcomes you to the secret test area!")
        var d = [];
        var i;
        d.push(0xA9, 0xFF);
        for (i = 0x0000; i< 0x580; i++) {
            d.push(0x8D, i & 0xFF, i >> 8 & 0xFF);
        }
        for (i = 0xD0; i< 0xD8; i++) {
            for (var j = 0x00; j< 0x30; j++) {
                d.push(0xAD, j, i, 0x8D, j, i);
            }
        }
        for (i = 0xD800; i< 0xD900; i++) {
            d.push(0x8D, i & 0xFF, i >> 8 & 0xFF);
        }
        d.push(0xAD, 0, 0xE0);
        for (i = 0xE400; i< 0x10000; i++) {
            d.push(0x20, i & 0xFF, i >> 8 & 0xFF);
        }
        d = new Uint8Array(d);
        load_one("pvb_test.dat", "dat", d, "", "isFile");
        refresh_containers();
    }
    //(PVB ADD) the hexEdLoaded() function to feed the Hex Editor with the data of file to modify when the event of the creation of the Hex Editor Frame is received
    function hexEdLoaded() {
        console.log(">HEXED>hexEdLoaded() IFrame of Hex Editor loaded! Now sending data to editor...");
        //feed the Hex Editor
        let sSize = _shown.type == "isDisk" ? _shown.atr.sector_size : 0;
        let dt = {eSize: sSize, hdata:_shown.data};
        let win = window.frames.hexed;
        win.postMessage(dt, "*");
    }
    //(PVB ADD) the receive_hexEditor(msg) function that processes the messages send by the Hex Editor Frame
    function receive_HexEditor(msg) {
        //alert(msg.txt);
        if (msg.winh) {
            let nh = msg.winh + "px";
            _g("hexedframeid").style.height = nh;
            return;
        }
        if (msg.hexdata) {
            console.log(">HEXED>hexEdLoaded() We have received data to save!");
            var d = new Uint8Array(msg.hexdata);
            _bModif = true;
            var naf = _shown.name;
            var nof = naf.lastIndexOf(".");
            if (nof != -1) naf = naf.slice(0, nof) + "_MODIF" + naf.slice(nof); //add _MODIF before the current extension
            else naf += "_MODIF";
            load_data(naf, d, ""); //load it into the tool, use load_data() that is better than load_one();
            refresh_containers(); //will close the Hex Editor
        }
        if (msg.closeHexED) {//no need to check
            refresh(); //will close the Hex Editor
        }
    }
    //(PVB ADD) function segs_merging(a, s) to merge nearby segments and cancel inner $FFFF headers of an Atari Executable file
    function segs_merging(a, s) { //a is the file uint8 data, and segs its extracted segments, got by get_xex_segs() in xex_dump() function
        var mod = 0;
        var gp;
        var re = [];
        var sg = [];
        a.forEach((b) => re.push(b)); //copy uint8 data in temp buffer
        s.forEach((b) => sg.push(b));//var sg = s.toSpliced(0,0); //copy of segment list array
        var i = sg.length - 1; //set last segment[i] of the file
        var opt = false; //nothing found yet
        while (i > 1) { // i == 1 when reaching the first segment that is the $FFFF header
            if (sg[i].ers && i > 1) { //last buggy segment can be cancelled, assuming first segment is OK, and only the last can be buggy
                re = re.slice(0, (sg[i-1].offset + sg[i-1].len)); //cancel the buggy segment
                console.log(" >segs_merging => has cancelled last buggy segment");
                sg.pop(); //remove it from seg list
                mod = 2; //file is modified
            }
            else if (sg[i].segid == 65535) { //file inner $FFFF header can be cancelled
                re.splice(sg[i].offset, 2); //cancel 2 bytes at sg[i].offset
                sg.splice(i, 1); //cancel the segment
                for (var j = i; j < sg.length; j++ ) {
                    sg[j].offset -= 2; //shift all offsets from 2 bytes
                }
                console.log(" >segs_merging => has cancelled inner $FFFF header");
                mod = 1; //file is modified
            }
            else if (!sg[i].start && !sg[i].end && i > 1 && i == (sg.length - 1)) { //start & end address are $0000 (only for last segment)
                re = re.slice(0, sg[i].offset - 4); //remove last 4 bytes from the data file buffer
                console.log(" >segs_merging => has cancelled $0000:$0000 segment");
                sg.pop(); //remove it from seg array
                mod = 2;
            }
            else {
                gp = sg[i].start - sg[i-1].end - 1; //this is the gap to merged between consecutive segment
                if (gp >= 0 && gp <= 128 && sg[i-1].end > 0x480 && sg[i].start < 0xC000) { //there is a valid gap to fill by 00 and merged => MAX 128 BYTES ($80)
                    console.log(" >segs_merging => has found a segment to merge with a gap of " + gp + " bytes");
                    re[sg[i-1].offset - 2] = re[sg[i].offset - 2]; //replace old end by new end, LSB
                    re[sg[i-1].offset - 1] = re[sg[i].offset - 1]; //replace old end by new end, MSB
                    if (gp) {
                        var gpb = Array(gp); //set the empty buffer, size is gp (gap size)
                        gpb.fill(0); //fill it with 00
                        //save last part of file data, after the header of seg[i]
                        var lp = re.slice(sg[i].offset, sg[sg.length - 1].offset + sg[sg.length - 1].len);
                        //keep the data up to the last segment (i-1), cancelling the segment (i) header
                        re = re.slice(0, (sg[i-1].offset + sg[i-1].len));
                        re = re.concat(gpb); // add the 00 data gap buffer just after the first part
                        re = re.concat(lp); // then add the last previpus saved part
                    }
                    else { //gap is zero byte, just cancel the segment (i) header of 4 bytes
                        re.splice(sg[i].offset -4, 4); //cancel 2 bytes at sg[i].offset
                    }
                    sg.splice(i, 1); //cancel the segment
                    for (var j = i; j < sg.length; j++ ) {
                        sg[j].offset = sg[j].offset - 4 + gp ; //shift all offsets from 4 bytes (header) added by the new gap bytes
                    }
                    console.log(" >segs_merging => has merge the two segments now from $" + hdx(sg[i-1].start) + " to $" + hdx(sg[i].end));
                    mod = 1; //file is modified
                }
            }
            if (mod == 1) { //mod==1
                i = sg.length - 1; //reset i to the last segment index of the segs array (reset the loop)
                opt = true; //keep in mind that the main file has been modified (i.e. merged)
            }
            else { //no mod or mod==2
                i--; //check previous segment of segs array
                if (mod == 2) opt = true; //keep in mind that the main file has been modified (i.e. merged)
            }
            mod = 0;  
        }
        //returns new merged uint8 data file if modif/merging is OK; returns null if nothing to merge nor optimization found
        return (opt ? new Uint8Array(re) : null);
    } 
    //(PVB end of ADD)
</script>
<head>
    <style>
        /* remove comment to activate google "Noto Sans Mono" font */
        /*@import url('https://fonts.googleapis.com/css2?family=Noto+Sans+Mono&display=swap');*/
    </style>
</head>
<body>
    <div class="floater atari keyboard"></div>
    <div class="floater disassembly" hidden>
        <span class='close-icon' onclick='this.parentElement.hidden = true'></span>
        <div class='draggable'>
        </div>
        <pre id='disassembly'></pre>
    </div>
    <div class="floater atari tools" onclick='floater(event)' id="tools">
        <span title='ATASCII Keyboard'>&#xE000</span><br />
        <span title='Open File'>O</span><br />
        <span id="H" class='dimmed' title='Toggle Hex View (force Hex Dump)'>H</span><br />
        <span id="I" class='dimmed' title='Invert Char Selection'>I</span><br />
        <span id="D" class='dimmed' title='Disassemble Char Selection'>D</span><br />
        <span id="P" class='dimmed' title='Hide/Show Global Display & Print Options Menu'>P</span><br />
        <span id="E" class='dimmed' title='Show/Hide File Extract & Disassemble Menu'>E</span><br />
        <span id="S" class='dimmed' title='Show/Hide File Picture or Font Search Menu'>S</span><br />
        <span id="M" class='dimmed' title='Modify Hex Code of Current file'>M</span><br />
    </div>
    <header>
        <h2>Atari 8-bit Rom Image File Explorer</h2>
        <div style="font-family: 'Atari';font-size: small;color: #666;padding-bottom: 8px;">
            For Atari <a href="https://en.wikipedia.org/wiki/Atari_5200">5200</a> and Atari <a href="https://en.wikipedia.org/wiki/Atari_8-bit_family">400/800/XL/XE & XEGS</a></div>
    </header>
    <div style="display:flex;flex-direction:row">
        <nav style="min-width:352px; max-width:352px; margin-right:8px;" id="toc">
            <div id="menu_container"></div>
            <p style="text-align:center;color:#999;font-weight:300">
                <span class='open' onclick='_q("#fe").click()'>Open</span>
                <br />Bug report, Support, Info & Manual ?
                <br />click here: <a href="https://github.com/pvbestinfoo/Atari_8-Bit_Rom_Image_File_Explorer">github.com/pvbestinfoo/Atari_8-Bit_Rom_Image_File_Explorer</a><br />
                <br /><i>Based upon ATR Image Explorer here:<br />
                <a href="https://github.com/rossumur/esp_8_bit">https://github.com/rossumur/esp_8_bit</a></i><br /><br />
                <i><b>Ctrl+O</b> opens File Dialog</i><br />
                <i><b>Ctrl+H</b> toggles Hex View</i><br />
                <i><b>Shift+Click</b> opens Keyboard in Editor</i><br />
            </p>
            <div style="font-size: xx-small;color: #99C;text-align: center;">MAY 2025 VERSION<br />by PVBest</div>
            <input type="file" id="fe" multiple style="display:none" aria-label="Drag files here">
        </nav>
        <main style="border:solid 1px #CCC">
            <div id="tabs"></div>
            <div id="hexedframeid" style="height: 0px; min-width: 610px;"></div>
        </main>
    </div>
    <script>load()</script>
</body>
</html>